#!/bin/bash

    # This program is free software: you can redistribute it and/or modify
    # it under the terms of the GNU General Public License as published by
    # the Free Software Foundation, either version 3 of the License, or
    # (at your option) any later version.

    # This program is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU General Public License for more details.

    # You should have received a copy of the GNU General Public License
    # along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Description {{{
# ---------------
#
# Melonpanel: my panel for my custom working environment centred around
# `bspwm`.  Melonpanel uses `lemonbar` to draw the system bar.  I just
# selected the name "melon" as an anagram for "lemon" and then switched
# "bar" with "panel".  This is to avoid naming conflicts where we could
# accidentally kill the wrong process or whatnot.
#
# This script contains all the modules that are used in my `lemonbar`
# panel.  The bar is part of my custom working environment centred
# around `bspwm`.  See my dotfiles, which are managed with GNU Stow:
# https://gitlab.com/protesilaos/dotfiles.
#
# Note that THIS IS WORK IN PROGRESS.  Check the various TODO tags
# scattered across this document.  I have opted for Lemonbar because it
# is included in the Debian repos and comes together with `bspwm` when
# running `apt install bspwm`.
#
# Melonpanel dependencies:
#   sudo apt install bspwm lemonbar xdo xfonts-terminus
#
# DEPRECATED but kept for reference:
# Module dependencies:
#   sudo apt install amixer mpd mpc
#
# Last reviewed 2019-03-22
#
# }}}

# General settings {{{
# --------------------

# Check if any lemonbar is running and kill it
if pgrep -xo lemonbar > /dev/null; then
    pkill -xo lemonbar
fi

# Melonpanel variables
# NOTE the descriptions for the Terminus typeface are copied from
# /etc/X11/fonts/misc/xfonts-terminus.alias
melonpanel_font='-xos4-terminus-medium-r-normal--12-120-72-72-c-60-iso10646-1'
melonpanel_height='20'

# }}}

# Colours for modules and bspwm indicators {{{
# --------------------------------------------

# These will style the various parts of the panel using shell variables.
# That file is used in other places as well to offer a convenient way of
# styling multiple tools in a manner that is centralised and
# straightforward.
source "$HOME/.local/share/my_colours/active-tempus-theme.sh"

COLOR_DEFAULT_FG="$foreground"
COLOR_DEFAULT_BG="$background"
COLOR_MONITOR_FG="$foregroundalt"
COLOR_MONITOR_BG="$color5"
COLOR_FOCUSED_MONITOR_FG="$foreground"
COLOR_FOCUSED_MONITOR_BG="$color6"
COLOR_FREE_FG="$foregroundalt"
COLOR_FREE_BG="$background"
COLOR_FOCUSED_FREE_FG="$background"
COLOR_FOCUSED_FREE_BG="$color2"
COLOR_OCCUPIED_FG="$color6"
COLOR_OCCUPIED_BG="$backgroundalt"
COLOR_ACTIVE_OCCUPIED_FG="$backgroundalt"
COLOR_ACTIVE_OCCUPIED_BG="$color5"
COLOR_FOCUSED_OCCUPIED_FG="$background"
COLOR_FOCUSED_OCCUPIED_BG="$color6"
COLOR_URGENT_FG="$background"
COLOR_URGENT_BG="$color1"
COLOR_FOCUSED_URGENT_FG="$background"
COLOR_FOCUSED_URGENT_BG="$color6"
COLOR_MONOCLE_FG="$background"
COLOR_MONOCLE_BG="$color3"
COLOR_FLAGS_FG="$background"
COLOR_FLAGS_BG="$color4"

# }}}

# Panel modules {{{
# -----------------
# 
# NOTE all functions that are meant to pipe their output to the panel
# will echo a majuscule (letter A-Z).  This is done to easily retrieve
# their output from the named pipe.  The letter has to be unique and,
# ideally, use common words that denote the function of the content of
# the command such as e.g. D for Date, N for Network...  Where this
# would lead to conflicts, find a synonym or something close enough.
#
# Any function that starts with "ancillary" is only meant to support the
# operations of another function.  Ancillary functions are used for
# formatting and the like.  They are not printed directly on the panel.
# Whereas functions called "my_SOMETHING" pass their output to the
# panel.

# Define date format as "Mon 1 Jan" (the %e omits the leading 0 from
# single digit dates, as opposed to %d == this is the same as %_d).
#
# Define the time in hours, minutes, seconds, using 24h format.  Update
# every second.
my_datetime() {
    while true; do
        echo "D" "$(date +'%a %e %b %T')"
        sleep 1s
    done
}

# TODO test ethernet
# TODO make WiFi test conditional on the existence of wireless capacity
#
# Check if the connection is established.  Print info.  Else display
# notice.
ancillary_my_network() {
	if [[ "$(nmcli -t -f STATE general status)" == 'connected' ]]; then
		echo "$(nmcli -t -f IN-USE,SIGNAL device wifi list | grep '^\*' | cut -d ':' -f 2)%"
	else
		echo "No Connection"
	fi
}

# TODO review the sleep interval
#
# Shows the name of the network and the signal strength.  Updated every
# hour.
my_network() {
	while true; do
		echo "N" "%{F$color5}Net%{F-}" "$(ancillary_my_network)"
		sleep 1h
	done
}

###### DEPRECATED but kept for future reference {{{
#### # Check if mpd is running, what is its state, and output the appropriate
#### # glyph.  If mpd is stopped or not running, omit the glyph.
#### ancillary_mpd_playing() {
####     local mpc_status=$(mpc status | grep "[[a-z]*]")
#### 
####     if [[ "$mpc_status" == *'playing'* ]]; then
####         echo "%{F$color2}$(echo -e '\ue0ed')%{F-}"
####     elif [[ "$mpc_status" == *'paused'* ]]; then
####         echo "%{F$color3}$(echo -e '\ue0ed')%{F-}" "(Paused)"
####     else
####         echo ''
####     fi
#### }
#### 
#### # Get a cleaner output of the mpc status.  We just want the first line
#### # which has the artist's name and the song title.  Then we want to make
#### # sure that long titles are trimmed and an indicator is appended to
#### # denote this.
#### ancillary_mpd_current() {
####     local mpc_status=$(mpc status | grep "[[a-z]*]")
####     local current_song_length="$(mpc status | head -n 1 | wc -c)"
####     local maxlen="60"
#### 
####     # if playing or paused
####     if [[ "$mpc_status" == *'p'* ]]; then
####         # Check if current mpc status has a length that is equal or higher
####         # than "maxlen".  If so trim the output to "maxlen" and append
####         # marker to denote the modification.
####         if [ "$current_song_length" -gt "$maxlen" ]; then
####             local current_song_trimmed="$(mpc status | head -n 1 | cut -c 1-${maxlen})"
####             printf "%s %s" "$current_song_trimmed" "[..]"
####         else
####             echo "$(mpc status | head -n 1)" 
####         fi
####     fi
#### }
####
#### # Here we include the status of mpd and of the current song, as defined
#### # above, and append its elapsed time / duration.  If there is no running
#### # mpd, nothing will be shown.  Update every second.
#### my_mpd_status() {
####     while true; do
####         echo "M" "$(ancillary_mpd_playing)" "$(ancillary_mpd_current)" \
#### 		"$(mpc status | grep -oe '[0-9]*:[0-9]*/[0-9]*:[0-9]*')" 
####         sleep 1s
####     done
#### }

###### DEPRECATED but kept for future reference
#### # This is where we retrieve the information about the temperature of the
#### # laptop's core.  Updated every five minutes.
#### my_temperature() {
#### 	# make this conditional on presence of temperature_path, else print
#### 	# empty string, but keep the TEMP indicator (to show the absence of
#### 	# the path).
#### 	if [ -f /sys/devices/platform/coretemp.0/hwmon/hwmon1/temp1_input ]; then
#### 		local temperature_path='/sys/devices/platform/coretemp.0/hwmon/hwmon1/temp1_input'
#### 	elif [ -f /sys/devices/platform/coretemp.0/hwmon/hwmon2/temp1_input ]; then
#### 		local temperature_path='/sys/devices/platform/coretemp.0/hwmon/hwmon2/temp1_input'
#### 	fi
#### 
####     while true; do
####         echo "H" "%{F$color1}$(echo -e '\ue0c3')%{F-}" "$(cat $temperature_path | cut -c 1-2)°"
####         sleep 5m
####     done
#### }
###### }}}

# TODO this should be contingent on the presence of a battery
# Show whether the battery is charging, discharging, or full.  Add the
# appropriate unicode glyph.
ancillary_my_battery_status() {
    local battery_path='/sys/class/power_supply/BAT0'
    local battery_status="$(cat $battery_path/status)"
	local battery_label='Bat'

    # TODO consider conditional logic when on plug
	if [ "$battery_status" == 'Charging' ]; then
		echo "%{F$color13}$battery_label ▒%{F-}"
	elif [ "$battery_status" == 'Discharging' ]; then
		echo "%{F$color11}$battery_label ░%{F-}"
	elif [ "$battery_status" == 'Full' ]; then
		echo "%{F$color2}$battery_label █%{F-}"
	else
		echo "%{F$color3}$battery_label ?%{F-}"
	fi
}

# TODO this should be contingent on the presence of a battery
# Get the output from the above ancillary function and present it
# together with the current battery level.  Update every minute.
my_battery() {
    local battery_path='/sys/class/power_supply/BAT0'

    while true; do
        echo "B" "$(ancillary_my_battery_status)" "$(cat "$battery_path/capacity")%"
        sleep 1m
    done
}

# Check if the volume is muted or not.  Output the appropriate
# indicators.
# TODO should this change if another output source is connected?  Test
# and adapt.
ancillary_my_volume_status() {
    if [ -x /usr/bin/amixer ]; then
        local volume_status="$(amixer get Master | tail -n 1 | grep -e '\[[on,off]*\]')"
        local volume_level="$(amixer get Master | tail -n 1 | grep -oe '[0-9]*%')"
		local volume_label='Vol'

        if [[ "$volume_status" == *'off'* ]]; then
            printf "%s %s" "%{F$color3}$volume_label%{F-}" "$volume_level (Muted)"
        else
            printf "%s %s" "%{F$color4}$volume_label%{F-}" "$volume_level"
        fi
    fi
}

# Present the content of the above ancillary function.  Update every
# minute.
my_volume() {
    while true; do
        echo "V" "$(ancillary_my_volume_status)"
        sleep 1m
    done
}

###### DEPRECATED but kept for future reference
#### # Modified version of the content of `own_script_current_layout`.  That
#### # is a separate file just because I need the functionality decoupled
#### # from the panel.  All we do here is print the language of the current
#### # layout.
#### #
#### # TODO HELP any better way than to spam this every second?  Just update
#### # if a change occurs?
#### my_current_keyboard_layout() {
####     while true; do
####         if [[ "$(setxkbmap -query | grep 'layout' | grep -o 'us')" == 'us' ]]; then
####             echo 'K''EN' # English (US QWERTY)
####         else
####             echo 'K''EL' # Greek
####         fi
####         sleep 1s
####     done
#### }

# }}}

# Piping and reading the output of the modules {{{
# ------------------------------------------------

# The design of this section has been heavily inspired/adapted from the
# examples provided by upstream bspwm.

# set path to named pipe used to store process data for these operations
melonpanel_fifo=/tmp/melonpanel_fifo

# make sure you delete any existing named pipe
if [ -e "$melonpanel_fifo" ]; then
    rm "$melonpanel_fifo"
fi

# create a new named pipe
mkfifo "$melonpanel_fifo"

# pipe the output of the modules to the fifo
my_battery > "$melonpanel_fifo" &
my_datetime > "$melonpanel_fifo" &
my_network > "$melonpanel_fifo" &
my_volume > "$melonpanel_fifo" &
bspc subscribe report > "$melonpanel_fifo" &

##### DEPRECATED these are from the modules that are no longer in use.
##### Kept for reference.
#### my_current_keyboard_layout > "$melonpanel_fifo" &
#### my_mpd_status > "$melonpanel_fifo" &
#### my_temperature > "$melonpanel_fifo" &

# Read the content of the fifo file.  We differantiate between modules
# based on the majuscule (letter A-Z) they piped into melonpanel_fifo
# (see modules above).  Here we just add a shorter variable to each
# module, which helps position it on the panel (the last printf).
melonpanel() {
    local num_mon=$(bspc query -M | wc -l)

    while read -r line ; do
        case $line in
            B*)
                # battery status
                bat="${line#?}"
                ;;
            D*)
                # current date and time
                date="${line#?}"
                ;;
####            H*)
####                # temperature level
####                hot="${line#?}"
####                ;;
####            K*)
####                # current keyboard language
####                key="${line#?}"
####                ;;
            N*)
                # network status
                net="${line#?}"
                ;;
####            M*)
####                # mpd status
####                mus="${line#?}"
####                ;;
            V*)
                # current date
                vol="${line#?}"
                ;;
            W*)
                # bspwm's state
                wm=
                IFS=':'
                set -- ${line#?}
                while [ $# -gt 0 ] ; do
                    item=$1
                    name=${item#?}
                    case $item in
                        [mM]*)
                            case $item in
                                m*)
                                    # monitor
                                    FG=$COLOR_MONITOR_FG
                                    BG=$COLOR_MONITOR_BG
                                    on_focused_monitor=
                                    ;;
                                M*)
                                    # focused monitor
                                    FG=$COLOR_FOCUSED_MONITOR_FG
                                    BG=$COLOR_FOCUSED_MONITOR_BG
                                    on_focused_monitor=1
                                    ;;
                            esac
                            [ $num_mon -lt 2 ] && shift && continue
                            wm="${wm}%{U${BG}}%{F${FG}} %{+u}${name}%{-u} %{F-}%{U-}"
                            ;;
                        [fFoOuU]*)
                            case $item in
                                f*)
                                    # free desktop
                                    FG=$COLOR_FREE_FG
                                    BG=$COLOR_FREE_BG
                                    ;;
                                F*)
                                    if [ "$on_focused_monitor" ] ; then
                                        # focused free desktop
                                        FG=$COLOR_FOCUSED_FREE_FG
                                        BG=$COLOR_FOCUSED_FREE_BG
                                    else
                                        # active free desktop
                                        FG=$COLOR_FREE_FG
                                        BG=$COLOR_FREE_BG
                                    fi
                                    ;;
                                o*)
                                    # occupied desktop
                                    FG=$COLOR_OCCUPIED_FG
                                    BG=$COLOR_OCCUPIED_BG
                                    ;;
                                O*)
                                    if [ "$on_focused_monitor" ] ; then
                                        # focused occupied desktop
                                        FG=$COLOR_FOCUSED_OCCUPIED_FG
                                        BG=$COLOR_FOCUSED_OCCUPIED_BG
                                    else
                                        # active occupied desktop
                                        FG=$COLOR_ACTIVE_OCCUPIED_FG
                                        BG=$COLOR_ACTIVE_OCCUPIED_BG
                                    fi
                                    ;;
                                u*)
                                    # urgent desktop
                                    FG=$COLOR_URGENT_FG
                                    BG=$COLOR_URGENT_BG
                                    ;;
                                U*)
                                    if [ "$on_focused_monitor" ] ; then
                                        # focused urgent desktop
                                        FG=$COLOR_FOCUSED_URGENT_FG
                                        BG=$COLOR_FOCUSED_URGENT_BG
                                    else
                                        # active urgent desktop
                                        FG=$COLOR_URGENT_FG
                                        BG=$COLOR_URGENT_BG
                                    fi
                                    ;;
                            esac
                            wm="${wm}%{F$FG}%{B$BG} ${name} %{B-}%{F-}"
                            ;;
                        [LG]*)
                            case $item in
                                LM*)
                                    # layout monocle
                                    FG=$COLOR_MONOCLE_FG
                                    BG=$COLOR_MONOCLE_BG
                                    ;;
                                LT*)
                                    # layout tiled
                                    FG=$COLOR_DEFAULT_FG
                                    BG=$COLOR_DEFAULT_BG
                                    ;;
                                G) # define it so that monocle does not paint the empty space
                                    FG=$COLOR_DEFAULT_FG
                                    BG=$COLOR_DEFAULT_BG
                                    ;;
                                G*?)
                                    FG=$COLOR_FLAGS_FG
                                    BG=$COLOR_FLAGS_BG
                                    ;;
                            esac
                            # layout, state and flags
                            wm="${wm}%{F$FG}%{B$BG} ${name} %{B-}%{F-}"
                            ;;
                    esac
                    shift
                done
        esac
        local laptop_external_monitor="$(xrandr --query | grep 'VGA1 connected')"
        if [ -n "$laptop_external_monitor" ]; then
            printf "%s%s\n" "%{Sf}%{l}${wm}%{r}${bat} ${vol} ${net} ${date} "\
            "%{Sl}%{l}${wm}%{r}${bat} ${vol} ${net} ${date} "
        else
            printf "%s\n" "%{Sf}%{l}${wm}%{r}${bat} ${vol} ${net} ${date} "
        fi
    done
}

# }}}
 
# Launch the panel with the given parameters {{{
# ----------------------------------------------

# NOTE the $foreground and $background are colours (see relevant section
# above).
melonpanel < "$melonpanel_fifo" | lemonbar -u 2 -p -g "x${melonpanel_height}" \
-F "$foreground" -B "$background" -f "$melonpanel_font" -n "Melonpanel" &

# Hide panel when windows are in full screen mode.  This does not work
# all the time, especially with lower `sleep` values, requiring a
# re-launch of melonpanel (pkill -x melonpanel && melonpanel).  I have
# yet to find a robust solution.  Source of this snippet (with minor
# adapatations by me): https://github.com/baskerville/bspwm/issues/484
until bar_id=$(xdo id -a 'Melonpanel')
do
  sleep 0.1
done

xdo below -t $(xdo id -n root) $bar_id &

# }}}

# vi:foldmethod=marker
