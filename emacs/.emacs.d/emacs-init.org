#+TITLE: GNU Emacs package configuration file
#+AUTHOR: Protesilaos Stavrou
#+EMAIL: public@protesilaos.com
#+OPTIONS: toc:nil
#+MACRO: export-date (eval (format-time-string "%F %R %z" (current-time)))

+ Created: 2019-08-15
+ Updated: *{{{export-date}}}*.

See this file's [[https://gitlab.com/protesilaos/dotfiles/commits/master/emacs/.emacs.d/emacs-init.org][upstream git history]].  Everything is part of my
dotfiles' repository.

#+TOC: headlines 8 insert TOC here, with eight headline levels

* Overview
:PROPERTIES:
:CUSTOM_ID: h:9ff13b78-42b8-49fe-9e23-0307c780de93
:END:
** Canonical links to this document
:PROPERTIES:
:CUSTOM_ID: h:0a9b72b3-aa4a-4c5c-a654-d4bc04b31bbd
:END:

+ HTML version :: [[https://protesilaos.com/dotemacs][protesilaos.com/dotemacs]]
+ Git repo :: [[https://gitlab.com/protesilaos/dotfiles][gitlab.com/protesilaos/dotfiles]]

** What is this
:PROPERTIES:
:CUSTOM_ID: h:8cfd5674-4997-44c7-bb7a-1869d5d53538
:END:

The present document, referred to in the source code version as
=emacs-init.org=, contains the bulk of my configurations for GNU Emacs.
It is designed using principles of "literate programming": a
combination of ordinary language and inline code blocks.  Emacs knows
how to parse this file properly so as to evaluate only the Elisp
("Emacs Lisp") included herein.  The rest is for humans to make sense
of my additions and their underlying rationale.

Literate programming allows us to be more expressive and deliberate.
Not only can we use typography to its maximum potential, but may also
employ techniques such as internal links between sections.  This makes
the final product much more useful for end users than, say, a terse
script.

Each section provides information about the code it contains.  In case
you feel something is missing, I maintain a [[#h:4e73b827-cdf3-46a2-81c5-55b6e95701b7][Frequently Asked Questions]]
section (when in doubt, or to offer feedback, suggestions, further
comments, etc., do [[https://protesilaos.com/contact][contact me]]).

In more practical terms, this document is written using =org-mode=.  It
contains all /package configurations/ for my Emacs setup.  To actually
work, it needs to be initialised from another file that only covers the
absolute essentials.

*** Contents of my init.el (for Emacs 27+)
:PROPERTIES:
:CUSTOM_ID: h:584c3604-55a1-49d0-9c31-abe46cb1f028
:END:

The =emacs-init.org= is loaded from an other file, named =init.el= per the
Emacs conventions.  Mine is designed to add the community-driven MELPA
archive to the list of package repositories, configure =use-package= (see
[[#h:cfa129a4-3394-4911-9097-4544df4e6ed9][comprehensive explanation below]]) and then load the file with my
configurations (i.e. the present document).

#+begin_example emacs-lisp
(setq straight-use-package-by-default nil)

(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

(straight-use-package 'use-package)

;; Configure `use-package' prior to loading it.
(eval-and-compile
  (setq use-package-always-ensure nil)  ; ESSENTIAL for `straight.el'
  (setq use-package-always-defer nil)
  (setq use-package-always-demand nil)
  (setq use-package-expand-minimally nil)
  (setq use-package-enable-imenu-support t)
  (setq use-package-compute-statistics nil)
  ;; The following is VERY IMPORTANT.  Write hooks using their real name
  ;; instead of a shorter version: after-init ==> `after-init-hook'.
  ;;
  ;; This is to empower help commands with their contextual awareness,
  ;; such as `describe-symbol'.
  (setq use-package-hook-name-suffix nil))

;; provides `straight-x-clean-unused-repos' (part of `straight.el')
(use-package straight-x)

(use-package vc
  :config
  (setq vc-follow-symlinks t)) ; Because my dotfiles are managed that way

;; ;; For my custom libraries
;; (add-to-list 'load-path "~/.emacs.d/lisp/")
;; (add-to-list 'load-path "~/.emacs.d/themes/")
;; (add-to-list 'load-path "~/.emacs.d/straight/repos/")

;; I create an "el" version of my Org configuration file as a final step
;; before closing down Emacs.  This is done to load the latest version
;; of my code upon startup.
;;
;; Also helps with initialisation times.  Not that I care too much about
;; those… Hence why I no longer bother with deferring package loading
;; either by default or on a case-by-case basis.
(let* ((conf "~/.emacs.d/emacs-init")
       (el (concat conf ".el"))
       (org (concat conf ".org")))
  (if (file-exists-p el)
      (load-file el)
    (use-package org)
    (org-babel-load-file org)))
#+end_example

**** The "early init" for Emacs 27+
:PROPERTIES:
:CUSTOM_ID: h:874944d8-7ac0-4115-aa21-6ff4e005f6f6
:END:

Starting with Emacs 27.1, an =early-init.el= is now required to control
things with greater precision.  Its code is as follows:

#+begin_example emacs-lisp
;; Initialise installed packages
(setq package-enable-at-startup t)

;; Allow loading from the package cache.
(setq package-quickstart t)

;; Do not resize the frame at this early stage.
(setq frame-inhibit-implied-resize t)
#+end_example

These adjustments are of paramount importance due to changes in the
way Emacs initialises the package manager. Prior to Emacs 27.1, the
=init.el= was supposed to handle that task by means of calling
=package-initialize=.  Whereas for Emacs 27.1, the default behaviour is
to start the package manager /before/ loading the user's init file.

*** About use-package
:PROPERTIES:
:CUSTOM_ID: h:cfa129a4-3394-4911-9097-4544df4e6ed9
:END:

This is a tool that streamlines /the configuration of packages/.  It
handles everything from assigning key bindings, setting the value of
customisation options, writing hooks, declaring a package as a
dependency of another, and so on.

=use-package= *is not a package manager*, in the sense of installing,
removing, listing packages.  It only /configures/ things using a
declarative syntax.  The package manager of Emacs is =package.el= while
there are other tools available from third parties, such as =straight.el=.
I currently use the latter (as of early December 2020).

The three types of =use-package= declarations that I use:

1. To set up external packages.  Those are denoted by the inclusion of
   =:straight t=, or variations thereof, which means that /the package
   manager/ should make sure the package is installed.

2. To configure default packages.  No =:straight= keyword is needed for
   those.

3. To declare custom or otherwise irregular packages that are not
   available in any repository and which I handle manually and plan to
   review at a later date.  Those include a =:load-path= that makes their
   code available to my environment.

In several package declarations you will see a =:diminish= keyword that
leverages [[#h:b31005e3-c475-4be9-87fd-85b404550d8c][the diminish package]].  This affects the so-called "lighter"
that each minor-mode may define.  The lighter is the piece of text that
a tool will append to the mode line.  For example, Flyspell's lighter is
"Fly".  With =:diminish= we demand that the lighter be removed (the
information is still available when running =C-h m=).

I set the variable =use-package-hook-name-suffix= to nil in order to
always type in the proper name of a hook.  The default behaviour is to
omit the suffix for convenience.  But that means that we can no longer
benefit from the contextual awareness of help/documentation commands
(e.g. =C-h o= over any of the symbols/functions/variables below will put
the thing at point as the first completion option).

Settings that do not have a corresponding package are declared using the
special =use-package emacs= notation.

Last but not least, you should be warned of a common error with handling
package installs while using the standard =package.el= (with or without
=use-package=): if Emacs complains that the package you want no longer
exists, it means that *you must refresh your package index* because there
is a new version of that package, so the old one that is still
registered on your list has been removed from the source.  Do that with
either =M-x package-refresh-contents= or by calling the package browser
=M-x list-packages=.

The following snippet of elisp sets up and configures =use-package= to my
liking.  It is already referenced in the previous section concerning the
[[#h:584c3604-55a1-49d0-9c31-abe46cb1f028][Contents of my init.el (for Emacs 27+)]].  This is due to changes in how
Emacs 27.1 starts up.  Whereas before I used to configure =use-package=
from inside this document.

#+begin_example emacs-lisp
(straight-use-package 'use-package)

;; Configure `use-package' prior to loading it.
(eval-and-compile
  (setq use-package-always-ensure nil)  ; ESSENTIAL for `straight.el'
  (setq use-package-always-defer nil)
  (setq use-package-always-demand nil)
  (setq use-package-expand-minimally nil)
  (setq use-package-enable-imenu-support t)
  (setq use-package-compute-statistics nil)
  ;; The following is VERY IMPORTANT.  Write hooks using their real name
  ;; instead of a shorter version: after-init ==> `after-init-hook'.
  ;;
  ;; This is to empower help commands with their contextual awareness,
  ;; such as `describe-symbol'.
  (setq use-package-hook-name-suffix nil))
#+end_example

*** About the source code version of this document
:PROPERTIES:
:CUSTOM_ID: h:f738cdfc-a6ff-46cb-9962-31f754280af5
:END:

In the =org-mode= version of this document, I make sure that the
above-referenced code blocks are not declared as an =emacs-lisp= source
but rather as mere examples, so they are not accidentally parsed by
the actual setup.

Actual code blocks are wrapped between =#+begin_src= and =#+end_src= tags
(not visible in the website version of this page).  For Emacs 27.1,
such templates can be quickly inserted with =C-c C-,= (this works both
for empty blocks and active regions).  For more on the matter, refer
to [[#h:4e8347de-415e-4804-b383-d61499e05ca1][Org's section further below]].

As for the various settings included herein, you can learn /even more/
about them by using [[https://protesilaos.com/codelog/2019-08-24-emacs-docs-discovery/][Emacs' built-in documentation]] (great for discovering
new features and pieces of functionality).

Additionally, you will notice some metadata tags specific to =org-mode=
below each heading.  These are generated by the functions that are
defined in the package declaration for =org-id=.  The idea is to keep
anchor tags consistent when generating a new HTML version of this
document.

This metadata also makes it possible to create immutable internal links,
whenever a reference is needed.  To create such links, you can use =C-c l=
to capture the unique ID of the current section and then =C-c C-l= to
create a link (the former is defined in the [[#h:4e8347de-415e-4804-b383-d61499e05ca1][Org package declaration]]—this
is an internal link in action).

** COPYING
:PROPERTIES:
:CUSTOM_ID: h:1b9e6455-ba10-4683-88d4-738ecc41cdf6
:END:

Copyright (c) 2019-2020 Protesilaos Stavrou <info@protesilaos.com>

This file is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or (at
your option) any later version.

This file is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this file.  If not, see <http://www.gnu.org/licenses/>.

* Base settings
:PROPERTIES:
:CUSTOM_ID: h:4d42f3e3-e96f-4125-a819-0544a21d45f3
:END:

This section contains the relatively few configurations that are needed
prior to the setup of everything else.

** Common auxiliary functions (prot-common.el)
:PROPERTIES:
:CUSTOM_ID: h:c82dcbfa-97d0-4f7c-85af-768ce90f1372
:END:

There are a few utilities that I keep re-using in various parts of my
Emacs code base.  To keep things modular, I place them all in a
dedicated =prot-common.el= file, which can then be marked as a dependency
by other libraries of mine.  As such, all we do in this package
declaration is load the file.

#+begin_src emacs-lisp
(use-package prot-common
  :straight (:local-repo "prot-lisp")
  :demand)
#+end_src

And here is =prot-common.el= in its totality.  It is available as a file
in [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]] (same for all my Emacs libraries):

#+include: straight/repos/prot-lisp/prot-common.el src emacs-lisp :tangle no

** Common custom functions (prot-simple.el)
:PROPERTIES:
:CUSTOM_ID: h:ae48fe61-a3c3-4132-8986-785f9bfbeafb
:END:

=prot-simple.el= contains a wide range of commands that are broadly in
line with the built-in =simple.el= and =lisp.el= libraries.  While I could
offer an overview of each item in my library, I feel the code and
concomitant documentation strings are clear enough for you to peruse the
source directly (reproduced further below).

Given that this is a foundational piece of my Emacs setup, its package
declaration serves as the appropriate place to disable various GUI
elements that I do not want to keep around, as well as re-bind or free
up some common key combinations.

#+begin_src emacs-lisp
(use-package prot-simple
  :straight (:type built-in)
  :demand
  :init
  ;; Configure some common Emacs elements
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (setq use-file-dialog nil)
  (setq use-dialog-box t)               ; only for mouse events
  (setq inhibit-splash-screen t)
  :config
  (setq prot-simple-insert-pair-alist
	    '(("' Single quote" . (39 39))           ; ' '
	      ("\" Double quotes" . (34 34))         ; " "
	      ("` Elisp quote" . (96 39))            ; ` '
	      ("‘ Single apostrophe" . (8216 8217))  ; ‘ ’
	      ("“ Double apostrophes" . (8220 8221)) ; “ ”
	      ("( Parentheses" . (40 41))            ; ( )
	      ("{ Curly brackets" . (123 125))       ; { }
	      ("[ Square brackets" . (91 93))        ; [ ]
	      ("< Angled brackets" . (60 62))        ; < >
	      ("« Εισαγωγικά Gr quote" . (171 187))  ; « »
	      ("= Equals signs" . (61 61))           ; = =
	      ("* Asterisks" . (42 42))              ; * *
	      ("_ underscores" . (95 95))))          ; _ _
  :bind (;; General commands
	     ("C-z" . nil)
	     ("C-x C-z" . nil)
	     ("C-h h" . nil)
	     ("M-`" . nil)
	     ("s-h" . prot-simple-describe-symbol)
	     ("s-H" . (lambda ()
		            (interactive)
		            (prot-simple-describe-symbol '(4))))
	     ;; Commands for lines
	     ("C-S-w" . prot-simple-copy-line-or-region)
	     ("C-S-y" . prot-simple-yank-replace-line-or-region)
	     ("M-SPC" . cycle-spacing)
	     ("M-o" . delete-blank-lines)   ; alias for C-x C-o
	     ("M-k" . prot-simple-kill-line-backward)
	     ("C-S-n" . prot-simple-multi-line-next)
	     ("C-S-p" . prot-simple-multi-line-prev)
	     ("<C-return>" . prot-simple-new-line-below)
	     ("<C-S-return>" . prot-simple-new-line-above)
	     ;; Commands for text insertion or manipulation
	     ("C-'" . prot-simple-insert-pair-completion)
	     ("M-'" . prot-simple-insert-pair-completion)
	     ("<C-M-backspace>" . backward-kill-sexp)
	     ("M-c" . capitalize-dwim)
	     ("M-l" . downcase-dwim)        ; "lower" case
	     ("M-u" . upcase-dwim)
	     ;; Commands for object transposition
	     ("C-t" . prot-simple-transpose-chars)
	     ("C-x C-t" . prot-simple-transpose-lines)
	     ("C-S-t" . prot-simple-transpose-paragraphs)
	     ("C-x M-t" . prot-simple-transpose-sentences)
	     ("C-M-t" . prot-simple-transpose-sexps)
	     ("M-t" . prot-simple-transpose-words)
	     ;; Commands for marking objects
	     ("M-@" . prot-simple-mark-word)       ; replaces `mark-word'
	     ("C-M-SPC" . prot-simple-mark-construct-dwim)
	     ("C-M-d" . prot-simple-downward-list)
         ;; Commands for paragraphs
         ("M-Q" . prot-simple-unfill-region-or-paragraph)
         ;; Commands for windows
         ("s-m" . prot-simple-monocle)
         ;; Commands for buffers
         ("M-=" . count-words)
         ("<C-f2>" . prot-simple-rename-file-and-buffer)
         ("s-k" . prot-simple-kill-buffer-current))
  :hook (kill-emacs-hook . prot-common-rebuild-emacs-init))
#+end_src

These are the contents of the =prot-simple.el= library (find the file in
[[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]] (as with all my Elisp code)):

#+include: straight/repos/prot-lisp/prot-simple.el src emacs-lisp :tangle no

** Remove modeline "lighters"
:PROPERTIES:
:CUSTOM_ID: h:b31005e3-c475-4be9-87fd-85b404550d8c
:END:

As was noted in the section [[#h:cfa129a4-3394-4911-9097-4544df4e6ed9][about `use-package']] we can remove the
so-called "lighter" text that modes append to the mode line.  This is
all that Diminish does and you will see a =:diminish= keyword in the
relevant packages.

If you actually want to edit the lighters, check the Delight package.

#+begin_src emacs-lisp
(use-package diminish
  :straight t
  :after use-package)
#+end_src

** Put customisation settings in a "custom.el"
:PROPERTIES:
:CUSTOM_ID: h:b24ce3fc-a12c-4d21-93d7-c1e7bd36a65d
:END:

When you install a package or use the various customisation interfaces
to tweak things to your liking, Emacs will append a piece of Elisp to
your init file.  In my experience, this is a common source of
inconsistencies, arising from a conflict between the user's code and
what is stored in that added =custom= snippet.

As such, I prefer to have all "custom" code stored in a separate,
disposable file that I do not keep under version control.  When
something does not seem to work as intended it is easy to edit
=~/.emacs.d/custom.el= or outright delete it.

#+begin_src emacs-lisp
(use-package cus-edit
  :config
  (defvar prot/custom-file "~/.emacs.d/custom.el")

  (setq custom-file prot/custom-file)

  (defun prot/cus-edit ()
    (let ((file prot/custom-file))
      (unless (file-exists-p file)
        (make-empty-file file))
      (load-file file)))
  :hook (after-init-hook . prot/cus-edit))
#+end_src

** Modus themes (my highly accessible themes)
:PROPERTIES:
:CUSTOM_ID: h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6
:END:

This is a project I started as soon as I switched to Emacs in July 2019.
About a year later the themes became part of upstream Emacs, available
for Emacs version 28 (as of version 0.12.0 of the themes).  I have
benefited a lot from community contributions, of which I am most
thankful of, as discussed in [[https://protesilaos.com/codelog/2020-08-27-emacs-modus-themes-core/][My Modus themes are now shipped with Emacs]]
(2020-08-27).

The Modus themes are designed for accessible readability.  They conform
with the highest accessibility standard for colour contrast between
foreground and background values.  This stands for a minimum contrast
ratio of 7:1, also known as the WCAG AAA standard (the highest of its
kind).

The themes are "Modus Operandi" (light) and "Modus Vivendi" (dark).  The
source code is available [[https://gitlab.com/protesilaos/modus-themes][on their GitLab page]] while you can read the
HTML version of [[https://protesilaos.com/modus-themes][their manual on my website]].  If you have the package
installed or are using Emacs >=28, you can read the manual from the
built-in Info reader.  Evaluate: =(info "(modus-themes) Top")=.

The manual covers everything from the basics to more advanced,
"do-it-yourself" cases.

The list of supported packages is comprehensive and a lot of work goes
into getting the details right.  Plus, there are *lots of customisation
options* to tweak the looks of the themes (note though that the values I
set for those variables in the following code block are not indicative
of my preferences, as I always try different combinations to test things
across a range of scenaria).

Lastly, if you are curious about the underlying methodology, read my
essay [[https://protesilaos.com/codelog/2020-03-17-design-modus-themes-emacs/][on the design of the Modus themes]] (2020-03-17).  And here are some
more resources from my website for those who are really into the minutia
and wish to get a glimpse of how much work goes into this project:

+ [[https://protesilaos.com/codelog/2020-05-10-modus-operandi-palette-review/][Modus Operandi theme subtle palette review]] (2020-05-10)
+ [[https://protesilaos.com/codelog/2020-06-13-modus-vivendi-palette-review/][Modus Vivendi theme subtle palette review]] (2020-06-13)
+ [[https://protesilaos.com/codelog/2020-07-04-modus-themes-faint-colours/][Modus themes: new "faint syntax" option]] (2020-07-04)
+ [[https://protesilaos.com/codelog/2020-07-08-modus-themes-nuanced-colours/][Modus themes: major review of "nuanced" colours]] (2020-07-08)
+ [[https://protesilaos.com/codelog/2020-08-09-modus-themes-paren-match/][Modus themes: review "paren-match" colours]] (2020-08-09)
+ [[https://protesilaos.com/codelog/2020-08-28-notes-emacs-theme-devs/][Notes for aspiring Emacs theme developers]] (2020-08-28)

#+begin_src emacs-lisp
(use-package modus-themes
  :straight (:local-repo "modus-themes")
  :init
  (setq modus-themes-slanted-constructs t
        modus-themes-bold-constructs t
        modus-themes-fringes nil ; {nil,'subtle,'intense}
        modus-themes-mode-line 'moody ; {nil,'3d,'moody}
        modus-themes-syntax nil ; {nil,'faint,'yellow-comments,'green-strings,'yellow-comments-green-strings,'alt-syntax,'alt-syntax-yellow-comments}
        modus-themes-intense-hl-line nil
        modus-themes-paren-match 'subtle-bold ; {nil,'subtle-bold,'intense,'intense-bold}
        modus-themes-links 'neutral-underline ; {nil,'faint,'neutral-underline,'faint-neutral-underline,'no-underline}
        modus-themes-no-mixed-fonts nil
        modus-themes-prompts nil ; {nil,'subtle,'intense}
        modus-themes-completions nil ; {nil,'moderate,'opinionated}
        modus-themes-region 'bg-only-no-extend ; {nil,'no-extend,'bg-only,'bg-only-no-extend}
        modus-themes-diffs 'bg-only ; {nil,'desaturated,'fg-only,'bg-only}
        modus-themes-org-blocks nil ; {nil,'grayscale,'rainbow}
        modus-themes-headings ; Read the manual for this one
        '((t . nil))
        modus-themes-variable-pitch-headings nil
        modus-themes-scale-headings nil
        modus-themes-scale-1 1.1
        modus-themes-scale-2 1.15
        modus-themes-scale-3 1.21
        modus-themes-scale-4 1.27
        modus-themes-scale-5 1.33)
  :config
  ;; A simpler version of this is also in the manual.  The hook is
  ;; triggered by `modus-themes-toggle', `modus-themes-load-operandi',
  ;; `modus-themes-load-vivendi'.
  (defun prot/modus-themes-custom-faces ()
    "Tweak faces after `modus-themes-after-load-theme-hook'."
    (set-face-attribute 'cursor nil
                        :background (modus-themes-color-alts 'blue 'green-alt))
    (set-face-attribute 'header-line nil :inherit 'variable-pitch)
    (set-face-attribute 'tab-bar nil :inherit 'variable-pitch)
    (set-face-attribute 'mode-line nil :inherit 'variable-pitch)
    (set-face-attribute 'mode-line-inactive nil :inherit 'variable-pitch)
    (set-face-attribute 'mode-line-buffer-id nil :weight 'normal)
    (set-face-attribute 'line-number nil
                        :background 'unspecified
                        :foreground (modus-themes-color 'fg-unfocused))
    (set-face-attribute 'line-number-current-line nil
                        :background 'unspecified
                        :foreground (modus-themes-color 'red-alt-other)))

  ;; Also check my package declaration for `prot-fonts' because I use
  ;; the `modus-themes-after-load-theme-hook' for some typeface-related
  ;; tweaks (as those are made at the "face" level).
  :hook ((after-init-hook . modus-themes-load-operandi)
         (modus-themes-after-load-theme-hook . prot/modus-themes-custom-faces))
  :bind ("<f5>" . modus-themes-toggle))
#+end_src

*** Rainbow mode for colour testing
:PROPERTIES:
:CUSTOM_ID: h:9061c694-5f45-46b0-a878-6bcfb018e18d
:END:

The following package reads a colour value, such as hexadecimal RGB,
and sets the background for the value in that colour.  Quite useful
when reviewing my themes (=rainbow-mode= is activated manually).

#+begin_src emacs-lisp
(use-package rainbow-mode
  :straight t
  :diminish
  :commands rainbow-mode
  :config
  (setq rainbow-ansi-colors nil)
  (setq rainbow-x-colors nil))
#+end_src

** Typeface configurations
:PROPERTIES:
:CUSTOM_ID: h:7a4dd5b8-724d-4f7c-b5ee-01d8ac98bda9
:END:

Any font I choose must support Latin and Greek character sets, be
readable at both small and large sizes, preferably offer roman and
italic variants with corresponding bold weights, not be too thin, not
have too short of an x-height, not be too wide, not have a name that
directly advertises some brand, not try to call too much attention to
its details, be equally readable against light and dark backdrops, and
use the =*.ttf= spec which yields the best results on GNU/Linux.

While there are many good free/libre options available, only a handful
of them cover my fairly demanding needs.  Some look good at large point
sizes.  Others lack Greek characters.  While a few of them are virtually
unreadable when cast on a light background (bitmap fonts in particular).
The section on [[#h:e03b6415-a18f-4058-b9b0-5721d38c6c50][Font configurations (prot-fonts.el)]] defines typefaces
that I consider suitable for my needs.

Lastly, note that on a modern GNU/Linux system that uses the =fontconfig=
library, per-user fonts are stored in =~/.local/share/fonts=.

*** Font configurations (prot-fonts.el)
:PROPERTIES:
:CUSTOM_ID: h:e03b6415-a18f-4058-b9b0-5721d38c6c50
:END:

Moving on to my configurations, =prot-fonts.el= is a library I have
written which contains lots of extras pertaining to my typeface
configurations and preferences.

Some highlights:

+ =prot-fonts-set-fonts= is a command that lets me select with completion
  a predetermined set of font configurations depending on the display
  context (more on completion in [[#h:98d3abcc-f34e-4029-aabc-740f0b6421f8][Completion framework and extras]]).  Such
  a "context" is configurable: I define them as "laptop", "desktop",
  etc.  When the function is executed non-interactively, it can be given
  an arbitrary font size as well as family names for the
  {mono,proportionately}-spaced typefaces.

+ =prot-fonts-fonts-per-monitor= sets the appropriate font family and size
  depending on whether I am only on my laptop or have connected to it an
  external monitor.  In the latter case we use the "desktop" context.

+ =prot-fonts-bold-face= lets me associate a list of typefaces with
  desired weights for their "bold" variation.  This practically means
  that if my font family has lots of weights, such as "light",
  "extrabold", "semibold", I can control what constitutes the normal one
  and what should be used for heavy emphasis.  Note that this only works
  if your theme of choice use the =bold= face to assign such emphasis
  instead of hard-wiring the =:weight bold= property.  [[#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6][My Modus themes]] are
  designed to account for such a requirement (the default remains the
  bold weight property---no need to specify that).

Now a few notes about setting fonts in Emacs.

While there are many ways to define a baseline or fallback font family,
I find that the most consistent one in terms of overall configuration is
to do it at the "face" level.  Faces are understood as the domain of
themes, though themes are just Elisp programs hence there is no real
distinction here and it is perfectly fine to have one program define
some properties of a face while another specifies some others.  The key
is to make those complementary, so that one does not override the other.
Put concretely, =prot-fonts.el= sets properties such as =:family=, while my
themes handle things like colours.

To appreciate this point, consider that in Emacs parlance a "face"
signifies a construct that groups together several display attributes,
such as a foreground and a background colour, as well as all
typography-related values.  Multiple assignments of value can expand the
face's specifications, unless one explicitly overrules a given property.

With regard to fonts, there are three faces that are of immediate
interest: the =default=, =variable-pitch=, and =fixed-pitch=.  The first is
the session's main typeface, the second specifies a proportionately
spaced font, and the third does the same for a monospaced family.

To understand the syntax used in =prot-fonts.el=, read the documentation
in =C-h f set-face-attribute=.  In essence, by changing the =default= face
we are specifying the family that should be used /in case no other
applies/ for the given construct.  This is actually a good idea because
there are many scenaria where you want a face to retain its own
attributes (e.g. let =org-mode= inline code be presented in its monospaced
font while using a variable width typeface for the main text---see, in
particular, [[#h:77d14350-978d-4820-ab7f-4641706c445a][Custom extensions for "focus mode" (prot-logos.el)]]).

Relevant blog posts of mine:

+ [[https://protesilaos.com/codelog/2020-08-28-notes-emacs-theme-devs/][Notes for aspiring Emacs theme developers]] (2020-08-28)
+ [[https://protesilaos.com/codelog/2020-09-05-emacs-note-mixed-font-heights/][Emacs: note on mixed font heights]] (2020-09-05)

#+begin_src emacs-lisp
(use-package prot-fonts
  :straight (:type built-in)
  :after modus-themes                   ; Because I use its hook
  :init
  (setq prot-fonts-typeface-sets-alist
        '((laptop . (105 "Hack" "DejaVu Sans Condensed"))
          (desktop . (110 "Hack" "DejaVu Sans"))
          (reader . (150 "Iosevka Comfy" "FiraGO"))
          (presentation . (160 "Hack" "DejaVu Sans"))))
  (setq prot-fonts-monospaced-list
        '("Hack" "DejaVu Sans Mono" "Iosevka Comfy" "Source Code Pro"
          "Ubuntu Mono" "Fantasque Sans Mono" "Fira Code" "Monoid"))
  (setq prot-fonts-heights-list
        '(100 105 110 120 130 140 150 160 170 180 190))
  (setq prot-fonts-line-spacing-alist
        '(("Source Code Pro" . 1)
          ("Ubuntu Mono" . 2)))
  (setq prot-fonts-laptop-desktop-keys-list '(laptop desktop))
  (setq prot-fonts-max-small-resolution-width 1366)
  (setq  prot-fonts-bold-weight-alist
         '(("Iosevka Comfy" . semibold)
           ("Source Code Pro" . semibold)))
  :config
  ;; This is defined in Emacs' C code, though I feel this is a good
  ;; place to put it.
  (setq x-underline-at-descent-line t)
  ;; And this just sets the right font depending on whether my laptop is
  ;; connected to an external monitor or not.
  (prot-fonts-fonts-per-monitor)
  :hook ((prot-fonts-set-typeface-hook . prot-fonts-line-spacing)
         (prot-fonts-set-typeface-hook . prot-fonts-bold-face)
         ;; See theme section for this hook
         (modus-themes-after-load-theme-hook . prot-fonts-bold-face))
  :bind ("C-c f" . prot-fonts-set-fonts-dwim))
#+end_src

This is the source code of =prot-fonts.el= (you can always find the file
if you directly clone [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]).

#+include: straight/repos/prot-lisp/prot-fonts.el src emacs-lisp :tangle no

*** Simple font suitability test
:PROPERTIES:
:CUSTOM_ID: h:9035a1ed-e988-4731-89a5-0d9e302c3dea
:END:

Here is a test I have come up with to make an initial assessment of the
overall quality of a monospaced font that is meant to work well in a
programming context: /can you discern each character at a quick glance?/
If yes, your choice of typeface is good /prima facie/, otherwise search
for something else.

Note that this test is not perfect, since many typefaces fall short in
less obvious ways, such as the space between the characters.  Also note
that the website version of this document may not accurately represent
the typeface I am using.

#+begin_example
()[]{}<>«»‹›
6bB8&
0ODdoaoOQGC
I1tilIJL|
!¡ij
5$§SsS5
17ZzZ2
9gqpG6
hnmMN
uvvwWuuwvy
x×X
.,·°%
¡!¿?
:;
`''"‘’“”
—-~≈=≠+*_
…⋯
...

Sample character set
Check for monospacing and Greek glyphs

ABCDEFGHIJKLMNOPQRSTUVWXYZ
abcdefghijklmnopqrstuvwxyz
0123456789
~!@#$%^&*+
`'"‘’“”.,;:…
()[]{}—-_=|<>/\
ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩ
αβγδεζηθικλμνξοπρστυφχψω

// NOTE that I got this from Hack's website:
// https://source-foundry.github.io/Hack/font-specimen.html
//  The four boxing wizards jump
#include <stdio.h> // <= quickly.
int main(int argc, char **argv) {
  long il1[]={1-2/3.4,5+6==7/8};
  int OxFaced=0xBAD||"[{(CQUINE";
  unsigned O0,l1,Z2,S5,G6,B8__XY;
  printf("@$Hamburgefo%c`",'\n');
  return ~7&8^9?0:l1|!"j->k+=*w";
}
#+end_example

*** Bidirectional writing and ~so-long.el~
:PROPERTIES:
:CUSTOM_ID: h:1d0e8ab3-d779-41d4-b478-d735dc3ad7ae
:END:

I only ever write/read in Latin and Greek alphabets.  So, while I
appreciate the fact that Emacs can natively handle other scripts, I have
no use for that particular feature.  Setting the default directionality
to what my languages use can help improve the responsiveness of Emacs in
some cases.

Consistent performance is the reason to also enable =global-so-long-mode=,
built into Emacs versions >= 27, which allows the active major mode to
gracefully adapt to buffers with very long lines.  What "very long"
means is, of course, configurable: =M-x find-library so-long= covers
several customisation options, though I find that the defaults require
no further intervention from my part.

The code below is a minor adaptation of the insights of Alain M. Lafon
in the [[https://200ok.ch/posts/2020-09-29_comprehensive_guide_on_handling_long_lines_in_emacs.html][Comprehensive guide on handling long lines in Emacs]] (2020-09-29).

#+begin_src emacs-lisp
(use-package emacs
  :config
  (setq-default bidi-paragraph-direction 'left-to-right)
  (setq bidi-inhibit-bpa t))

(use-package so-long
  :config
  (global-so-long-mode 1))
#+end_src

* Selection candidates and search methods
:PROPERTIES:
:CUSTOM_ID: h:5c060e2e-231d-4896-a5d2-b3fb4134764e
:END:
** Completion framework and extras
:PROPERTIES:
:CUSTOM_ID: h:98d3abcc-f34e-4029-aabc-740f0b6421f8
:END:

As discussed in my video about [[https://protesilaos.com/codelog/2019-08-18-emacs-buffers-windows/][Emacs' buffer and window management]],
the optimal way of using Emacs is through searching and narrowing
selection candidates.  Spend less time worrying about where things are
on the screen and more on how fast you can bring them into focus.  This
is, of course, a matter of realigning priorities, as we still wish to
control every aspect of the interface.

*** Orderless completion style
:PROPERTIES:
:CUSTOM_ID: h:7b1374dd-6b1f-4548-8fbf-1034230c80e0
:END:

The, dare I say, /sublime/ [[https://github.com/oantolin/orderless][“orderless” package]] is developed by Omar
Antolín Camarena.  It provides the =orderless= completion style for
efficient out-of-order grouped pattern matching.  The components can be
determined using several styles, such as regexp, flex, prefix,
initialism (check its README because there are lots of variations).
Delimiters are literal spaces by default, but can be configured to match
other characters, with hyphens and slashes being likely choices.  As
such, Orderless can supersede---and for most cases improve upon---the
completion styles that come built into Emacs, adding to them the
powerful out-of-order capability.

The =prot-orderless.el= contains the few tweaks I introduce (full code
further below).  In particular, it defines two style dispatchers.  Those
are single characters that acquire a special meaning while at the end of
a given input.  With the equals sign appended to a sequence of
characters, we call =prot-orderless-literal-dispatcher= which instructs
orderless to match that sequence as a literal string.  While a comma
reads it as an initialism, per =prot-orderless-initialism-dispatcher=.

Note that the =orderless= completion style is added to the minibuffer's
customisation option for =completion-styles=.  That is defined in the
section about [[#h:c110e399-3f43-4555-8427-b1afe44c0779][Minibuffer configurations and extras]].

#+begin_src emacs-lisp
(use-package prot-orderless
  :straight (:type built-in)
  :demand)

(use-package orderless
  :straight t
  :demand
  :after prot-orderless
  :config
  (setq orderless-component-separator " +")
  (setq orderless-matching-styles
        '(orderless-flex
          orderless-strict-leading-initialism
          orderless-regexp
          orderless-prefixes
          orderless-literal))
  (setq orderless-style-dispatchers
        '(prot-orderless-literal-dispatcher
          prot-orderless-initialism-dispatcher))
  ;; SPC should never complete: use it for `orderless' groups.
  :bind (:map minibuffer-local-completion-map
              ("SPC" . nil)))
#+end_src

These are the contents of the =prot-orderless.el= library (get the file
from [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]] (as with all my Elisp code)):

#+include: straight/repos/prot-lisp/prot-orderless.el src emacs-lisp :tangle no

*** Minibuffer configurations and extras (prot-minibuffer.el)
:PROPERTIES:
:CUSTOM_ID: h:c110e399-3f43-4555-8427-b1afe44c0779
:END:

The code block below is specifically about the minibuffer setup.  *This
does not cover the visualisation of completion candidates*, which is
handled by Icomplete---those are defined in the next section about
[[#h:b6b13f4f-91f5-416d-9934-b51b4d87770c][Icomplete configurations and extras]].

Here is an overview of the settings covered herein:

+ Completion styles :: I mostly rely on [[#h:7b1374dd-6b1f-4548-8fbf-1034230c80e0][the Orderless completion style]].
  An exception is a niche functionality of the =partial-completion= style
  (built-in): with it you can navigate to a filesystem path like
  =~/.l/s/fo= for =~/.local/share/fonts=.  So my recommendation is to use
  those two styles to cover every case.

+ Recursive minibuffers :: I enable recursive minibuffers.  This
  practically means that you can start something in the minibuffer,
  switch to another window, call the minibuffer again, run some
  commands, and then move back to what you initiated in the original
  minibuffer.  To exit, hit =C-]= (=abort-recursive-edit=), though the
  regular =C-g= should also do the trick.

  The =minibuffer-depth-indicate-mode= will show a depth indicator,
  represented as a number, next to the minibuffer prompt, if a recursive
  edit is in progress.

+ Key bindings :: Note the nuances in the behaviour between =RET= and =C-j=.
  With the Return key, we instruct the minibuffer to expand the current
  candidate and then exit the session, if possible.  Whereas =C-j= is
  meant to insert the minibuffer's contents exactly as they are and exit
  immediately.  You need the latter in cases where you want =foo= but the
  match is for =foobar=.

  The key bindings in the pattern of =s-KEY= follow the principles I
  outline in my [[#h:fbba4dea-9cc8-4e73-bffa-02aab10a6703][note about the use of the Super key]].  They are included
  here because they related to minibuffer-centric actions.

Also check my configurations about the [[#h:2733674b-51f9-494e-b34d-e8842ac4ef96][minibuffer history]].  After
several months of full time usage, I am confident in the built-in
mechanism's ability to sort things well enough and to surface the
results I am most likely interested in, based on previous selections.

Finally note that =prot-minibuffer.el= contains a few extensions that help
me focus the minibuffer or the completions' window.  It also provides
three commands that are pertinent to the =*Completions*= buffer: kill-save
the symbol at point, insert it at point in the most recently used
window, insert and then exit all recirsive minibuffers.  In practice,
those three commands are not part of my day-to-day workflow, because I
normally rely on [[#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984][Embark for extended minibuffer actions]].  At any rate,
the =prot-minibuffer.el= is reproduced after this set of =use-package=
declarations.  For its =:hook= also check [[#h:cf9086c1-1b33-4127-a716-de94259e14a0][Cursor appearance and tweaks]].

#+begin_src emacs-lisp
(use-package prot-minibuffer
  :straight (:type built-in)
  :demand
  :bind (("s-v" . prot-minibuffer-focus-mini-or-completions)
         :map completion-list-mode-map
         ("M-v" . prot-minibuffer-focus-mini)
         ("h" . prot-simple-describe-symbol) ; from `prot-simple.el'
         ;; Those are generic actions for the "*Completions*" buffer.  I
         ;; normally use `embark' and its own buffers.
         ("w" . prot-minibuffer-completions-kill-symbol-at-point)
         ("i" . prot-minibuffer-completions-insert-symbol-at-point)
         ("j" . prot-minibuffer-completions-insert-symbol-at-point-exit))
  :hook (minibuffer-setup-hook . prot-minibuffer-mini-cursor))

(use-package minibuffer
  :demand
  :after prot-minibuffer
  :config
  (setq completion-styles '(orderless partial-completion))
  (setq completion-category-defaults nil)
  (setq completion-cycle-threshold 3)
  (setq completion-flex-nospace nil)
  (setq completion-pcm-complete-word-inserts-delimiters t)
  (setq completion-pcm-word-delimiters "-_./:| ")
  (setq completion-show-help nil)
  (setq completion-ignore-case t)

  ;; The following two are updated in Emacs 28.  They concern the
  ;; *Completions* buffer.
  (setq completions-format 'one-column)
  (setq completions-detailed t)

  (setq read-buffer-completion-ignore-case t)
  (setq read-file-name-completion-ignore-case t)

  (setq enable-recursive-minibuffers t)
  (setq read-answer-short t)
  (setq resize-mini-windows t)
  (setq minibuffer-eldef-shorten-default t)

  (file-name-shadow-mode 1)
  (minibuffer-depth-indicate-mode 1)
  (minibuffer-electric-default-mode 1)

  ;; Defines, among others, aliases for common minibuffer commands to
  ;; Super-KEY.  Normally these should go in individual package
  ;; declarations, but their grouping here makes things easier to
  ;; understand.  Besides, they are related to the minibuffer.
  :bind (("s-b" . switch-to-buffer)
         ("s-B" . switch-to-buffer-other-window)
         ("s-f" . find-file)
         ("s-F" . find-file-other-window)
         ("s-d" . dired)
         ("s-D" . dired-other-window)
         :map minibuffer-local-completion-map
         ("<return>" . minibuffer-force-complete-and-exit) ; exit with completion
         ("C-j" . exit-minibuffer)      ; force input unconditionally
         :map completion-list-mode-map
         ("n" . next-line)
         ("p" . previous-line)
         ("f" . next-completion)
         ("b" . previous-completion)))
#+end_src

And here is =prot-minibuffer.el= (from [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: straight/repos/prot-lisp/prot-minibuffer.el src emacs-lisp :tangle no

*** Icomplete configurations and extras (prot-icomplete.el)
:PROPERTIES:
:CUSTOM_ID: h:b6b13f4f-91f5-416d-9934-b51b4d87770c
:END:

The following package declaration is for the built-in interactive
minibuffer-based completion interface: =icomplete=.  Remember that the
underlying completion mechanisms are handled by the minibuffer
itself---see section on [[#h:c110e399-3f43-4555-8427-b1afe44c0779][Minibuffer configurations and extras]].

Overview of the following package declaration:

+ The values of all variables that pertain to the delay of feedback are
  meant to introduce /some/ delay in the feedback I get when the list of
  candidates is long.  This paradoxically makes things feel faster while
  I am still typing because by that time the list has been narrowed to
  my input.  Put differently, you can always type prior to viewing the
  minibuffer's prompt.

+ For versions of Emacs above 27, there is a minor mode called =fido=
  (Fake IDO, where =ido= is an alternative option to Icomplete that tries
  to do more than just completion).  This new mode changes some of the
  primary key bindings and commands of =icomplete= so that it meets the
  expectations of Ido users.  It is not meant as a fully fledged
  replacement of Ido, as its scope is much narrower, at least for the
  time being.  In practice though, =fido= is just a tweaked =icomplete= and
  is, in fact, part of the =icomplete.el= library.  If you are curious,
  check the source code for both =icomplete= and =ido= with the help of the
  command =find-library=.  *I do not use Fido*, though I think it is a
  welcome step in the right direction, which is that of gradually
  deprecating Ido by bringing its good ideas into Icomplete while
  ensuring consistency with the latest standards in upstream Emacs.
  That granted, you can always bind some Fido command without activating
  the minor mode.

+ The keybindings I specify define motions that ensure consistency
  between regular editing and the rotation of the candidates' list.  The
  default =icomplete= keys for those tasks leave much to be desired.

+ As with the same keys for the minibuffer, note the nuances in the
  behaviour between =RET= and =C-j= (=icomplete-force-complete-and-exit= and
  =exit-minibuffer= respectively).  With the former we instruct Icomplete
  to expand the current candidate and then exit the minibuffer session
  /if possible/.  Whereas =C-j= is meant to insert exactly what is in the
  minibuffer, which can be tricky in some circumstances.  Use the latter
  when Icomplete is matching =foobar= but you only want =foo= (needed when
  renaming files or when creating links in Org to non-existent
  candidates).  This also applies to cases where =completing-read= has a
  non-nil =require-match= argument, but you still want to input something
  that is not part of the candidates' list (this can break some
  commands, so use it wisely).

Now a few words about =prot-icomplete.el=, which is copied right after the
following =use-package= declarations.

+ =prot-icomplete-truncate= ensures that long lines are truncated instead
  of being visually broken into two lines.  This is an extra measure to
  ensure that =icomplete-prospects-height= is always set to =1=.

+ The minor mode =prot-icomplete-actions= contains three common actions
  for minibuffer interactions and is only meant to serve as a
  lightweight alternative to [[#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984][Embark's extended minibuffer actions]].  I
  normaly use Embark, but keep this around just in case.  The fact that
  it is a minor mode lets me bind its keys to the mode's activation,
  keeping everything else in tact.

  1. =prot-icomplete-kill-completion= (=M-\ w=) will save the current
     candidate to the top of the kill-ring.

  2. =prot-icomplete-insert-completion= (=M-\ i=) will insert the current
     candidate in the buffer from where the minibuffer was called.

  3. =prot-icomplete-insert-completion-exit= (=M-\ j=) will do as above, but
     also exit all recursive minibuffers.

#+begin_src emacs-lisp
(use-package prot-icomplete
  :straight (:type built-in)
  :demand
  :config
  ;; Only use this if you do not want `embark'
  (prot-icomplete-actions -1)

  ;; Hooks' syntax is controlled by the `use-package-hook-name-suffix'
  ;; variable.  The "-hook" suffix is intentional.
  :hook (icomplete-minibuffer-setup-hook . prot-icomplete-truncate))

(use-package icomplete
  :demand
  :after prot-minibuffer
  :config
  (setq icomplete-delay-completions-threshold 100)
  (setq icomplete-max-delay-chars 2)
  (setq icomplete-compute-delay 0.2)
  (setq icomplete-show-matches-on-no-input t)
  (setq icomplete-hide-common-prefix nil)
  (setq icomplete-prospects-height 1)
  (setq icomplete-separator (propertize " · " 'face 'shadow))
  ;; (setq icomplete-separator " │ ")
  ;; (setq icomplete-separator " ┆ ")
  ;; (setq icomplete-separator " ¦ ")
  ;; (setq icomplete-separator " ┆ ")
  (setq icomplete-with-completion-tables t)
  (setq icomplete-tidy-shadowed-file-names t)

  (fido-mode -1)                        ; Emacs 27.1
  (icomplete-mode 1)

  :bind (:map icomplete-minibuffer-map
              ("C-," . nil)             ; disable defaults
              ("C-." . nil)             ; same
              ("<tab>" . icomplete-force-complete)
              ("<return>" . icomplete-force-complete-and-exit) ; exit with completion
              ("C-j" . exit-minibuffer) ; force input unconditionally
              ("C-n" . icomplete-forward-completions)
              ("<right>" . icomplete-forward-completions)
              ("<down>" . icomplete-forward-completions)
              ("C-p" . icomplete-backward-completions)
              ("<left>" . icomplete-backward-completions)
              ("<up>" . icomplete-backward-completions)
              ;; The following command is from Emacs 27.1
              ("<C-backspace>" . icomplete-fido-backward-updir)))
#+end_src

Below are the contents of =prot-icomplete.el= (a standalone file is
available as part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]] (as with all my Elisp code)):

#+include: straight/repos/prot-lisp/prot-icomplete.el src emacs-lisp :tangle no

*** Icomplete vertical mode (icomplete-vertical)
:PROPERTIES:
:CUSTOM_ID: h:c8325f81-b5a9-47a6-b4d1-dfe1c54a44d1
:END:

Icomplete displays its list horizontally by default.  This is how I like
it for many cases, because the candidates are often short and I do not
want to have the window layout undergo any mutations in size as the
minibuffer expands and contracts.  A horizontal, one-line-tall Icomplete
is okay.

There are, however, cases where verticality provides a genuine usability
boost: when the candidates are naturally long.  To that end I set the
helper function =icomplete-vertical-toggle= to a convenient key binding
inside the minibuffer.  I invoke the toggle whenever the need arises.

#+begin_src emacs-lisp
(use-package icomplete-vertical
  :straight (:host github :repo "oantolin/icomplete-vertical" :branch "master")
  :after (minibuffer icomplete) ; do not forget to check those as well
  :config
  (setq icomplete-vertical-prospects-height (/ (frame-height) 6))
  (icomplete-vertical-mode -1)
  :bind (:map icomplete-minibuffer-map
              ("C-v" . icomplete-vertical-toggle)))
#+end_src

*** Completion annotations (marginalia)
:PROPERTIES:
:CUSTOM_ID: h:09d657c7-eb4d-4fe3-987a-4a2cf419bb40
:END:

This is a utility jointly developed by Daniel Mendler and Omar Antolín
Camarena that provides annotations to completion candidates.  It is
meant to be a framework-agnostic tool, so it works nicely with Consult,
Icomplete vertical, and Embark.

Refer to the relevant sections:

+ [[#h:c110e399-3f43-4555-8427-b1afe44c0779][Minibuffer configurations and extras (prot-minibuffer.el)]].
+ [[#h:b6b13f4f-91f5-416d-9934-b51b4d87770c][Icomplete configurations and extras (prot-icomplete.el)]].
+ [[#h:c8325f81-b5a9-47a6-b4d1-dfe1c54a44d1][Icomplete vertical mode (icomplete-vertical)]].
+ [[#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb][Enhanced minibuffer commands (consult.el and prot-consult.el)]].
+ [[#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984][Extended minibuffer actions and more (embark.el and prot-embark.el)]].

#+begin_src emacs-lisp
(use-package marginalia
  :straight (:host github :repo "minad/marginalia" :branch "main")
  :demand
  :config
  (marginalia-mode)
  (setq marginalia-annotators '(marginalia-annotators-heavy
                                marginalia-annotators-light))
  :bind (:map minibuffer-local-completion-map
              ("C-i" . marginalia-cycle-annotators)))
#+end_src

*** Enhanced minibuffer commands (consult.el and prot-consult.el)
:PROPERTIES:
:CUSTOM_ID: h:9c9401d6-8c53-4276-be4c-3bff345d3eeb
:END:

Daniel Mendler's Consult is a new entry to the ecosystem of small,
modular tools that work with the standard Emacs completion framework.
It provides enhanced versions of several common commands, like
=switch-to-buffer=, while it offers useful functionality, such as the
ability to visualise---and revisit---items in the mark ring.

While this section in a work-in-progress, note that my =prot-consult.el=
defines some quick and dirty extensions that add minor visual feedback
to the various jump actions that Consult makes possible.

#+begin_src emacs-lisp
;; TODO: configure pattern-matching on a per-command basis
(use-package consult
  :straight (:host github :repo "minad/consult" :branch "master")
  :config
  (setq consult-line-numbers-widen t)
  (setq consult-preview-buffer nil)
  (setq consult-preview-mark t)
  (setq consult-preview-line t)
  (setq consult-preview-outline nil)
  (setq completion-in-region-function #'consult-completion-in-region)
  (consult-preview-mode 1)
  :bind (("M-s s" . consult-outline)
         ("M-s M-s" . consult-outline)
         ("M-s m" . consult-mark)
         ("M-s l" . consult-line)
         :map minibuffer-local-completion-map
         ("<tab>" . minibuffer-force-complete)))

(use-package prot-consult
  :straight (:type built-in)
  :after prot-pulse
  :config
  (setq prot-consult-add-advice-set-hooks t)
  (setq prot-consult-command-centre-list '(consult-line consult-mark))
  (setq prot-consult-command-top-list '(consult-outline))

  (prot-consult-set-up-hooks-mode 1))
#+end_src

Here is =prot-consult.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: straight/repos/prot-lisp/prot-consult.el src emacs-lisp :tangle no

*** Extended minibuffer actions and more (embark.el and prot-embark.el)
:PROPERTIES:
:CUSTOM_ID: h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984
:END:

Embark, aka "Emacs Mini-Buffer Actions Rooted in Keymaps", is another
neat library by Omar Antolín Camarena.  It provides common actions
through what essentially amounts to a prefix key.  Your main point of
entry to this tool is the =embark-act= command: bind it to a convenient
key combination that will make it easy for you to use it and, thus,
maximise its potential.

The premise of Embark is that targets are interpreted based on their
context, so you are automagically presented with a list of relevant
commands that apply to them.  For example, while running a minibuffer
completion against files, =embark-act= will provide access to standard
filesystem operations such as to copy, rename, delete the current
candidate.

All those types of interaction are grouped together in keymaps.  So our
example for file names corresponds to =embark-file-map=.  Expect to find
the equivalent in =embark-buffer-map=, =embark-region-map=, and so on.

To learn which keymap's contents get enabled in the present context,
follow up the =embark-act= key with =C-h= (remember that this conforms with
the Emacs convention of using =C-h= as a suffix to display help about
possible key chords that complete what has already been typed in---if
you are new to Emacs, consult my note on [[#h:83730fe8-d917-4d94-96f4-bbc5c900fe38][How do you learn Emacs?]]).
Embark's README offers instructions on how to use =which-key= instead of
this method.  So please adapt things to your liking.

While Embark is touted as a tool for minibuffer actions, it is easier to
think of it as the equivalent of a right-click/context menu, with
=embark-act= performing the primary function of the right-click call.
This is because you can use Embark outside of a minibuffer session, such
as when the point is over a file name, URL, symbol.  Same for the active
region.  Making =embark-act= second nature will help you gain access to
commands you seldom use, or at least be reminded of their presence.

A more nuanced command you can benefit from is =embark-act-noexit=.  It
behaves like its counterpart except that it does not exit the minibuffer
while inside one.  Use it when you need to string together a series of
actions pertaining to the present list of candidates.

Because Embark is all about keymaps whose scope is a given context, you
can easily extend it with your own functions.  Do you have a command
that, say, operates on files?  Add an entry for it in =embark-file-map=.

Apart from actions, Embark contains two key components for operating on
groups of candidates:

+ =embark-occur= pops a buffer that lists all candidates. The buffer can
  be presented as a grid, or a list, with the possibility to manually
  toggle between the two with =embark-occur-toggle-view=.  The list view
  provides useful annotations, such as the first line of a command's doc
  string.  Embark's "occur buffer" also has a live-updating version,
  which is what I normally use to get live feedback on what I am
  matching against.

+ =embark-export= gathers the list of candidates and tries to display them
  in the appropriate major mode.  If you are completing against file
  names, this command will export the list to Dired (also refer to the
  section on [[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][Dired (directory editor, file manager)]]).  While it will use
  Ibuffer when the list consists of buffers (check [[#h:06290f9c-491c-45b2-b213-0248f890c83d][Ibuffer and extras]]).
  Otherwise it falls back to =embark-occur=.

Now a few words about =prot-embark.el= that is reproduced after the
following block with the package configurations:

+ =prot-embark--live-occur-window= ensures that Embark's live occur buffer
  shrinks and expands to match the window's contents.  This is done
  internally and should require no further intervention.

+ =prot-embark-live-occur-toggle= toggles the display of the live occur
  buffer.  It also fires =prot-embark-live-occur-hook= as its final step.

+ The customisation option =prot-embark-live-occur-disable-icomplete=
  controls whether the aforementioned toggle should have an effect on
  Icomplete ([[#h:b6b13f4f-91f5-416d-9934-b51b4d87770c][Icomplete configurations and extras (prot-icomplete.el)]]).
  If yes, then Icomplete gets disabled whenever the live occur buffer is
  present and is re-enabled once live occur switches off or the
  minibuffer exits.  Two functions handle this task: (i)
  =prot-embark--icomplete-toggle=, and (ii) =prot-embark-icomplete-hooks=.

#+begin_src emacs-lisp
(use-package embark
  :straight (:host github :repo "oantolin/embark" :branch "master")
  :demand
  :after prot-minibuffer
  :config
  (setq embark-occur-initial-view-alist
        '((t . list)))
  (setq embark-occur-minibuffer-completion t)
  (setq embark-live-occur-delay 0.3)
  (setq embark-completing-read-delay 0.6)
  (setq embark-annotator-alist '((t . embark-annotation-function-metadatum)))
  :hook (embark-occur-mode-hook . (lambda () (toggle-truncate-lines -1)))
  :bind (("C-," . embark-act)
         :map minibuffer-local-completion-map
         ("C-," . embark-act)
         ("C-." . embark-act-noexit)
         ("M-q" . embark-occur-toggle-view) ; parallel of `fill-paragraph'
         ("M-o" . embark-export) ; falls back to `embark-occur'
         ("M-v" . embark-switch-to-live-occur)
         :map embark-occur-mode-map
         ("," . embark-act)
         ("M-t" . toggle-truncate-lines)
         ("M-q" . embark-occur-toggle-view)
         ("M-v" . prot-minibuffer-focus-mini) ; from `prot-minibuffer.el'
         ("M-q" . embark-occur-toggle-view)))

(use-package prot-embark
  :straight (:type built-in)
  :demand
  :after embark
  :config
  (setq prot-embark-live-occur-disable-icomplete t)
  (prot-embark-icomplete-hooks-mode 1)
  :bind (:map embark-occur-mode-map
         ("h" . prot-simple-describe-symbol)  ; from `prot-simple.el'
         :map minibuffer-local-completion-map
         ("C-l" . prot-embark-live-occur-toggle)))
#+end_src

This is =prot-embark.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: straight/repos/prot-lisp/prot-embark.el src emacs-lisp :tangle no

*** Imenu (dynamic completion-based buffer navigation)
:PROPERTIES:
:CUSTOM_ID: h:77284937-ad9d-44cc-8a3e-80f6ed9e3def
:END:

=imenu.el= is a built-in library that constructs an index of buffer
positions pointing to semantically relevant constructs.  With =M-x imenu=
it displays the list through a completion interface.  Selecting an item
repositions the point there.  Simple yet super effective!

Combine it with the sheer power of the completion framework or the
possibility to further extend it with little helper snippets and you get
a whole new way of thinking about navigating a buffer.

By default, =imenu= is designed to not refresh the index it builds,
offering a "Rescan" option instead.  I find that too conservative for my
case, opting instead for automatic rescaning.  This has the desirable
side-effect of removing the manual refresh command from the list.

While my =prot-pulse.el= library provides some extensions to an already
well-designed tool (check [[#h:6bbc41d6-da7c-4301-84c6-c5887c29283f][prot-pulse.el (highlight cursor position)]]).
Namely, to make Imenu's line jumping more predictable by repositioning
it at the top, adding a subtle colour pulse, and revealing any hidden
text below the heading when used in Org or Outline modes.

Make sure to watch my [[https://protesilaos.com/codelog/2020-07-20-emacs-outline-imenu/][video demo of outline-minor-mode and imenu]]
(2020-07-20), with the proviso that it was recorded with earlier
versions of my code.  For Org, you need to set =org-imenu-depth= to a high
value (refer to the section on [[#h:4e8347de-415e-4804-b383-d61499e05ca1][Org-mode (personal information manager)]]).

#+begin_src emacs-lisp
(use-package imenu
  :config
  (setq imenu-use-markers t)
  (setq imenu-auto-rescan t)
  (setq imenu-auto-rescan-maxout 600000)
  (setq imenu-max-item-length 100)
  (setq imenu-use-popup-menu nil)
  (setq imenu-eager-completion-buffer t)
  (setq imenu-space-replacement " ")
  (setq imenu-level-separator "/")
  :after prot-pulse
  :hook ((imenu-after-jump-hook . prot-pulse-recentre-top)
         (imenu-after-jump-hook . prot-pulse-show-entry)))
#+end_src

**** Flimenu (flat imenu index)
:PROPERTIES:
:CUSTOM_ID: h:9be8e9ec-e1f2-477b-92d9-d050aef00d50
:END:

This package offers a global and a local minor mode for flattening the
index of =imenu=.  By default Imenu produces a multi-level index, where
appropriate.  For example, it will put the heading of this section under
that of its parent: [[#h:77284937-ad9d-44cc-8a3e-80f6ed9e3def][Imenu (dynamic completion-based buffer navigation)]].
So to navigate to this point, you need to select the parent and then the
child path.  Good for a tree view REVIEW.
But not great for fuzzy-style search through the completion UI, because
it slows down things considerably, while not offering any typographic or
layout means of recognising the structure at first sight.

In other words, a multi-level completion interface leaves much to be
desired.  By enabling the =flimenu-global-mode= we get a flat list for the
completion-based interaction with =imenu=.  Now we can just search
directly for any item on the list.  Great!

To make things even better, we can still access the fully fledged tree
presentation of =imenu-list=, as it operates independently.

Lastly, =flimenu= could also be used as a toggle, by virtue of its local
minor mode, though I cannot think of a scenario where I would want that,
given the aforementioned.

#+begin_src emacs-lisp
(use-package flimenu
  :straight t
  :after imenu
  :config
  (flimenu-global-mode 1))
#+end_src

*** Projects (project.el and prot-project.el)
:PROPERTIES:
:CUSTOM_ID: h:7862f39e-aed0-4d02-9f1e-60c4601a9734
:END:

Starting with Emacs 28, the current development target, =project.el=
contains lots of interesting additions that make it an all-round useful
tool.  Chief among them is a new prefix key bound to =C-x p=.  This has
good mnemonic value, like those for tabs (=C-x t=) and registers (=C-x r=).

A "project" is, in our case, a directory whose contents are related to
each other in terms of the end product they can provide.  Think, for
example, how Emacs' source code is a single "project" that delivers the
program we use.  In practical terms, a project is a version controlled
directory (or directory tree).  For my case that means =git= though other
backends are also supported (same principle as with VC---see section on
[[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][Generic version control framework]]).

Using any of the commands listed in =C-x p C-h= will append the current
project to a list of "known projects", stored in the dynamically updated
=project--list= variable, whose contents are stored in a file defined by
=project-list-file= (remember that =C-h= can be added to any key sequence to
show its extensions and the commands associated with them---read my
brief guide on [[#h:83730fe8-d917-4d94-96f4-bbc5c900fe38][How do you learn Emacs?]]).  It is then possible to switch
between your projects and proceed to immediately perform an action on
them with =C-x p p=.  A menu with possible commands will appear once you
select a project.  That is customisable via =project-switch-commands=.

Also note that =C-x p p= (=project-switch-project=) can be used to store a
new version-controlled directory in the =project--list=.  Look for the
=... (choose a dir)= option.

Now an overview of the =prot-project.el= commands, which build on top of
an otherwise comprehensive system (full code further below):

+ =prot-project-commit-log= produces a list with the most recent commits
  in the project.  The default count is controlled by a customisation
  option: =prot-project-commit-log-limit=.  In case there is no project
  being acted upon, the command first prompts for completion against the
  project list.

+ =prot-project-find-subdir= provides completion for subdirectories in the
  current project.  It opens the match in a Dired buffer.  When no
  project is present, it prompts for completion.

+ =prot-project-magit-status= produces the =magit-status= buffer for the
  current project or prompts for completion.

+ =prot-project-retrieve-tag= lets you switch to an earlier tagged commit
  or branch using completion.  As always, when no project is present, it
  asks for one before doing its work.

To aid me in my work, I copied code from Manuel Uberti's website (also
referenced in the source code below this configuration block):

+ [[https://www.manueluberti.eu/emacs/2020/11/14/extending-project/][Extending project.el]] (2020-11-14)
+ [[https://www.manueluberti.eu/emacs/2020/11/21/flymake-projects/][Restricting Flymake to my projects]] (2020-11-21)

#+begin_src emacs-lisp
(use-package project
  :demand
  :init
  (setq project-switch-commands
        '((?f "File" project-find-file)
          (?s "Subdir" prot-project-find-subdir)
          (?g "Grep" project-find-regexp)
          (?d "Dired" project-dired)
          (?b "Buffer" project-switch-to-buffer)
          (?q "Query replace" project-query-replace-regexp)
          (?t "Tag switch" prot-project-retrieve-tag)
          (?m "Magit" prot-project-magit-status)
          (?v "VC dir" project-vc-dir)
          (?l "Log VC" prot-project-commit-log)
          (?e "Eshell" project-eshell)))
  :bind ("C-x p q" . project-query-replace-regexp)) ; C-x p is `project-prefix-map'

(use-package prot-project
  :straight (:type built-in)
  :demand
  :init
  (setq prot-project-project-roots '("~/Git/Projects/" "~/Git/build/"))
  (setq prot-project-commit-log-limit 25)
  (setq prot-project-large-file-lines 1000)
  :bind (("C-x p <delete>" . prot-project-remove-project)
         ("C-x p l" . prot-project-commit-log)
         ("C-x p m" . prot-project-magit-status)
         ("C-x p s" . prot-project-find-subdir)
         ("C-x p t" . prot-project-retrieve-tag)))
#+end_src

This is =prot-project.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: straight/repos/prot-lisp/prot-project.el src emacs-lisp :tangle no

*** Completion for recent files and directories (prot-recentf.el)
:PROPERTIES:
:CUSTOM_ID: h:5723c4bb-ff6c-449f-bb60-be66fab3f137
:END:

This is a built-in minor mode that keeps track of the files you have
opened, allowing you to revisit them faster.  Its true power consists in
the fact that its data, maintained in =recentf-list=, is a simple
variable.  This means that we can access it through any relevant piece
of Elisp functionality.

To that end, the functions I define in =prot-recentf.el= are meant to
either control the contents of the list or allow me to access them
through my completion framework or a dedicated file listing.

Note that there exists a built-in =recentf-open-files= function for
accessing the recent files through a bespoke buffer.  I find that I have
no use for it.

#+begin_src emacs-lisp
(use-package recentf
  :config
  (setq recentf-save-file "~/.emacs.d/recentf")
  (setq recentf-max-saved-items 200)
  (setq recentf-exclude '(".gz" ".xz" ".zip" "/elpa/" "/ssh:" "/sudo:"))
  :hook (after-init-hook . recentf-mode))

(use-package prot-recentf
  :after recentf
  :config
  (add-to-list 'recentf-keep #'prot-recentf-keep-default-predicate)
  :bind (("s-r" . prot-recentf-recent-files)
         ("C-x C-r" . prot-recentf-recent-dirs)))
#+end_src

This is a copy of =prot-recentf.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: straight/repos/prot-lisp/prot-recentf.el src emacs-lisp :tangle no

*** In-buffer completions
:PROPERTIES:
:CUSTOM_ID: h:98876022-57cc-40de-936e-4ee42cefd69a
:END:

After trying the popular third-party "Company" package, I felt that it
did not offer much of an added value to my typing experience, while its
popup feature detracted from the otherwise frugal aesthetics of my
setup.  Furthermore, I felt like it was adding a second type of
completion paradigm while ignoring the original one, i.e. the
minibuffer---again, an offense against simplicity.

What I have in this section is a few simple tweaks and built-in ways to
complete terms while typing text in a buffer.  I think that, for most
cases, the minibuffer can be used effectively to perform in-buffer
completion.

**** Dabbrev (dynamic word completion)
:PROPERTIES:
:CUSTOM_ID: h:57dcf193-0c4e-4ee6-9b2d-6892558b0a84
:END:

This is Emacs' own approach to dynamic/arbitrary text completion inside
the buffer: "dynamic abbreviation" or else =dabbrev=.  This mechanism
works by reading all text before point to find a suitable match.
Different scenaria determine whether it should also look forward and in
other buffers.

In essence, Dabbrev can help you type again what you already have.  It
will not draw findings from some knowledge bank, nor will it try to read
your mind (though Emacs will definitely have an =M-x= conduit to such a
technology).

With =dabbrev-expand= we make an attempt to complete the text at point.
Repeated invocations will cycle through the candidates.  No feedback is
provided, much in the same way yanking from the kill-ring works.
Whereas =dabbrev-completion= benefits from minibuffer interactivity,
courtesy of =contrib/completing-read-in-region= that was defined in the
section right above.

The =dabbrev-abbrev-char-regexp= is configured to match both regular words
and symbols (e.g. words separated by hyphens).  This makes it suitable
both for code and ordinary language.

While the =dabbrev-abbrev-skip-leading-regexp= is instructed to also
expand words and symbols that start with any of these: =$=, =*=, =/=, ===, ='=.
This regexp may be expanded in the future, but the idea is to be able to
perform completion in contexts where the known word/symbol is preceded
by a special characters.  For example, in the =org-mode= version of this
document, all inline code must be placed between the equals sign.  So
now typing the ===, then a letter, will still allow me to expand text
based on that input.

To check what I have on regular expressions, see further below my
configurations and documentation for [[#h:6c6759c8-3ae3-40b0-8356-05cc0975e12a][re-builder and visual-regexp]].

The =prot/dabbrev-completion= is based on [[https://www.reddit.com/r/emacs/comments/jix6od/weekly_tipstricketc_thread/gaid3f4/][an idea shared]] by Omar Antolín
Camarena on Reddit.  It helps you continue with a =dabbrev-completion=
sequence that encompasses multiple words.  Take Omar's full name for
example.  I typed =Om= then =s-/= (=prot/dabbrev-completion=) to find the form
I was looking for using minibuffer completion.  Then followed it up with
two =s-/=.  It filled in the rest of the name without prompting me for
completion again.  Nice and simple!

#+begin_src emacs-lisp
(use-package dabbrev
  :after (minibuffer icomplete) ; read those as well
  :config
  (setq dabbrev-abbrev-char-regexp "\\sw\\|\\s_")
  (setq dabbrev-abbrev-skip-leading-regexp "[$*/=']")
  (setq dabbrev-backward-only nil)
  (setq dabbrev-case-distinction 'case-replace)
  (setq dabbrev-case-fold-search t)
  (setq dabbrev-case-replace 'case-replace)
  (setq dabbrev-check-other-buffers t)
  (setq dabbrev-eliminate-newlines t)
  (setq dabbrev-upcase-means-case-search t)

  ;; FIXME: this is not reliable
  (defun prot/dabbrev-completion ()
    "Expand current phrase or call `dabbrev-completion'."
    (interactive)
    (let* ((abbrev (dabbrev--abbrev-at-point))
           (ignore-case-p (dabbrev--ignore-case-p abbrev))
           (completion-list (dabbrev--find-all-expansions abbrev ignore-case-p)))
      (cond
       ((when (and (eq completion-list nil)
                   (not (eq last-repeatable-command 'mode-exit)))
          (insert " ")
          (dabbrev-expand 1)))
       (t
        (dabbrev-completion)))))

  :bind (("M-/" . dabbrev-expand)
         ("C-M-/" . prot/dabbrev-completion)
         ("s-/" . prot/dabbrev-completion)))
#+end_src

**** Skeletons and abbreviations
:PROPERTIES:
:CUSTOM_ID: h:33cd69cc-1a50-4abb-9f09-cae98dc8998b
:END:

/NOTE 2020-06-08: Pending major review./

This section stores all the "skeletons" I define.  These are snippets of
text, typically templates or code statements, that are meant to speed up
typing.  While abbreviations are shorter versions of terms that
automatically expand into what they correspond to.  I combine skeletons
with abbreviations.

*Please note that these will be very simplistic at first.*  I am aware
that they can be abstracted using elisp—need to learn more on that
front.  Also note that wherever you see =" _ "= it signifies the
position of the cursor after the skeleton has been inserted.

#+begin_src emacs-lisp
(use-package abbrev
  :diminish
  :config
  (setq abbrev-file-name "~/.emacs.d/abbrevs")
  (setq only-global-abbrevs nil)

  ;;;;;;;;;;;;;;;;;;;;;;
  ;; simple skeletons ;;
  ;;;;;;;;;;;;;;;;;;;;;;
  (define-skeleton protesilaos-com-skeleton
    "Adds a link to my website while prompting for a possible
  extension."
    "Insert website extension: "
    "https://protesilaos.com/" str "")
  (define-abbrev global-abbrev-table "meweb"
    "" 'protesilaos-com-skeleton)

  (define-skeleton protesilaos-gitlab-skeleton
    "Adds a link to my GitLab account while prompting for a
  possible extension.  Makes it easy to link to my various git
  repos."
    "Website extension: "
    "https://gitlab.com/protesilaos/" str "")
  (define-abbrev global-abbrev-table "megit"
    "" 'protesilaos-gitlab-skeleton)

  ;; (define-skeleton org-block-skeleton
  ;;   "Insert an org block, querying for type."
  ;;   "Type: "
  ;;   "#+begin_" str "\n"
  ;;   _ - \n
  ;;   "#+end_" str "\n")
  ;;
  ;; (define-skeleton org-use-package
  ;;   "Org source block with `use-package' declaration."
  ;;   "Package: "
  ;;   "#+begin_src emacs-lisp\n"
  ;;   "(use-package " _ ")\n"
  ;;   "#+end_src\n")
  ;; (define-abbrev global-abbrev-table "meup"
  ;;   "" 'org-use-package)
  ;;
  ;; (define-skeleton markdown-jekyll-blog
  ;;   ""
  ;;   ""
  ;;   "---\n"
  ;;   (concat "title: '" (read-from-minibuffer
  ;;                       "Blog Title: ") "'\n")
  ;;   (concat "excerpt: '" (read-from-minibuffer
  ;;                         "Excerpt (max 156 chars): ") "'\n")
  ;;   "---\n\n"
  ;;   "")
  ;; (define-abbrev global-abbrev-table "mejb"
  ;;   "" 'markdown-jekyll-blog)
  :bind (("C-x a e" . expand-abbrev) ; default, just here for visibility
         ("C-x a u" . unexpand-abbrev))
  :hook ((text-mode-hook . abbrev-mode)
         (git-commit-mode-hook . abbrev-mode)))
#+end_src

** Configurations for—or extensions to—built-in search commands
:PROPERTIES:
:CUSTOM_ID: h:67dac9fe-5c15-437d-bb3e-26b293affa45
:END:

These are meant to enhance the functionality of tools that are already
shipped with Emacs.

*** Isearch, occur, and extras (prot-search.el)
:PROPERTIES:
:CUSTOM_ID: h:b67687ee-25a3-4bf4-a924-180ccb63c629
:END:

The built-in search mechanisms, defined in the libraries =isearch.el= and
=replace.el= are minimal in their presentation, yet powerful in their
applications.  There are the main points of entry to the commands they
offer:

+ =isearch-forward= (=C-s=) prompts for a string after point and offers live
  feedback on its progress.  =isearch-backward= (=C-r=) moves in the
  opposite direction.

  - Two distinct keys may seem redundant at first, but you really
    appreciate this level of precision when recording keyboard macros
    (see, for example, my video about [[https://protesilaos.com/codelog/2020-01-21-emacs-isearch-kmacro/][Isearch powers in keyboard macros]]
    (2020-01-21)).

  - Use =C-M-s= and =C-M-r= for running a search against a regular
    expression, or call =isearch-toggle-regexp= (=M-r=) after starting a
    regular isearch.

+ =query-replace= (=M-%=) replaces all matches of a string and asks you for
  confirmation on each of them.  If you check its help page (press =?=
  after invoking the command), you will learn that =!= stands for an
  affirmative answer to all, which is a standard in all such prompts.

  - =query-replace-regexp= (=C-M-%=) does the same for regular expressions.

+ =occur= (=M-s o=) places all matches of a regular expression or string in
  a dedicated buffer.  That can function as an index for moving to the
  relevant points in the buffer, but also as a means of refactoring all
  matches at once.  Just make the =*Occur*= buffer editable with =e=.
  Running =occur= with a numeric argument provides N lines of context
  around the given match.

The beauty of the Occur and Replace commands is that they can be
initiated from within an active Isearch session, using the same keys.
So =C-s INPUT M-s o= will search for input and then run =occur= on it.  Try
=C-h k C-s= to get a help menu with all the extra keys you can use with
=isearch=.  These are the ones I use the most:

| Key chord | Description                  |
|-----------+------------------------------|
| C-s C-w   | Search char or word at point |
| M-s .     | Search for symbol at point   |
| M-s o     | Run `occur' on regexp        |
| M-s h r   | Highlight regexp             |
| M-s h u   | Undo the highlight           |
| C-s M-r   | Toggle regexp search         |
| M-%       | Run `query-replace'          |
| C-M-%     | `query-replace-regexp'       |

Every one of the above, except the first item, can be executed on their
own, or as extensions of =C-s= (and variants).

The Occur and Replace operations are aware of the active region, so if
you highlight, say, a paragraph and do =M-%= you will only replace matches
inside of that area (while not relevant to our point, this also works
for =undo= (=C-/=), which is super useful).  Though one can achieve pretty
much the same result by leveraging Emacs' narrowing commands, like
=narrow-to-defun= (learn about all of them with =C-x n C-h=)

Now here is a neat trick I discovered a while ago that makes Isearch
even better for most tasks: the ability to interpret a space as a
wildcard.  This is due to the combined effect of the values assigned to
the variables =search-whitespace-regexp=, =isearch-lax-whitespace=,
=isearch-regexp-lax-whitespace=.  So you can now search for something like
=se di bu al= and it will return =setq display-buffer-alist=.  And you can
still combine it with all of the aforementioned!  Note that *this affects
regular searches* (the standard =C-s= and =C-r=).  The regexp-sensitive
functions =C-M-s= and =C-M-r= remain in tact.  You can always toggle
whitespace matching behaviour while performing a search, with =M-s SPC=
(revert back to just literal spaces).

Now on to my =prot-search.el= library which provides some extensions to
an already well-designed architecture (the code is reproduced after the
package declarations).

+ =prot-search-isearch-other-end= simply places point at the opposite end
  of the current match.  Particularly helpful while recording keyboard
  macros.  This is to work around the default behaviour of Isearch which
  puts the point at either the beginning or the end of the match,
  depending on the direction it is moving in.  For single words or
  balanced expressions this is not an issue because you can always
  confirm+exit a search by using a motion key (so, for example, move to
  the end of the matching word with =M-f=).  There are, however, matches
  that are not limited to such boundaries, especially with the wildcard
  hack mentioned above.  For those cases moving to the opposite end
  might require multiple key presses, which is bad when trying to record
  an efficient keyboard macro.  Note though that you can achieve the
  same result by changing the direction the search is moving towards
  with =C-s= or =C-r= (though I still prefer my minor addition).

+ =prot-search-isearch-abort-dwim= deletes the entirety of the
  non-matching input while leaving the valid parts in place.  Otherwise
  it behaves like a standard backward character deletion. The built-in
  method to remove the entirety of a mismatched input is to hit =C-g=
  following a failed search.  However, I find that the choice of key
  binding can prove problematic, since =C-g= also exits a successful
  search, while I also prefer a "do-what-I-mean" behaviour.

+ =prot-search-isearch-replace-symbol= runs a forward-looking
  =query-replace= for the symbol at point.  Simple and effective for
  quickly refactoring a given function/variable name (and one of the
  reasons why I have never needed an extra package for such tasks).

+ =prot-search-isearch-beginning-of-buffer= and its counterpart
  =prot-search-isearch-end-of-buffer= move to the first or last instance
  of the symbol at point.  They also accept a numeric argument, which
  they interpret as an offset.  In practice, this is the same as running
  =M-s . M-s <= or =M-s . M-s >=.

+ =prot-search-occur-urls= gathers all URLs in the current buffer and
  places them in an Occur buffer /without their context/ while also making
  them clickable (we say that it "buttonises" them).

+ =prot-search-occur-browse-url= gathers all URLs in the buffer and
  prompts you to select one with completion.  It then browses that item
  using whatever browser you have for =browse-url-browser-function=.

#+begin_src emacs-lisp
(use-package isearch
  :diminish
  :config
  (setq search-highlight t)
  (setq search-whitespace-regexp ".*?")
  (setq isearch-lax-whitespace t)
  (setq isearch-regexp-lax-whitespace nil)
  (setq isearch-lazy-highlight t)
  ;; All of the following variables were introduced in Emacs 27.1.
  (setq isearch-lazy-count t)
  (setq lazy-count-prefix-format nil)
  (setq lazy-count-suffix-format " (%s/%s)")
  (setq isearch-yank-on-move 'shift)
  (setq isearch-allow-scroll 'unlimited)
  :bind (:map minibuffer-local-isearch-map
         ("M-/" . isearch-complete-edit)
         :map isearch-mode-map
         ("C-g" . isearch-cancel)       ; instead of `isearch-abort'
         ("M-/" . isearch-complete)))

(use-package replace
  :config
  (setq list-matching-lines-jump-to-current-line t)
  :hook ((occur-mode-hook . hl-line-mode)
         (occur-mode-hook . (lambda ()
                              (toggle-truncate-lines t))))
  :bind (("M-s M-o" . multi-occur)
         :map occur-mode-map
         ("t" . toggle-truncate-lines)))

(use-package prot-search
  :straight (:type built-in)
  :bind (("M-s %" . prot-search-isearch-replace-symbol)
         ("M-s M-<" . prot-search-isearch-beginning-of-buffer)
         ("M-s M->" . prot-search-isearch-end-of-buffer)
         ("M-s u" . prot-search-occur-urls)
         ("M-s M-u" . prot-search-occur-browse-url)
         :map isearch-mode-map
         ("<backspace>" . prot-search-isearch-abort-dwim)
         ("<C-return>" . prot-search-isearch-other-end)))
#+end_src

Here is =prot-search.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: straight/repos/prot-lisp/prot-search.el src emacs-lisp :tangle no

*** Regular expressions: re-builder and visual-regexp
:PROPERTIES:
:CUSTOM_ID: h:6c6759c8-3ae3-40b0-8356-05cc0975e12a
:END:

To learn more about regular expressions, read the relevant pages in
the official manual.  Assuming you have this installed properly on
your system, run =C-h r i regexp= to get to the starting chapter.

Also watch my ~35 minute-long [[https://protesilaos.com/codelog/2020-01-23-emacs-regexp-primer/][primer on Emacs regexp]] (2020-01-23).

Emacs offers a built-in package for practising regular expressions.
By default, =re-builder= uses Emacs-style escape notation, in the form
of double backslashes.  You can switch between the various styles by
using =C-c TAB= inside of the regexp builder's buffer.  I choose to keep
this style as the default.  Other options are =string= and =rx=.

#+begin_src emacs-lisp
(use-package re-builder
  :config
  (setq reb-re-syntax 'read))
#+end_src

Another option (though the two are not mutually exclusive) is to use
the third-party package =visual-regexp=.  This one is meant as a drop-in
replacement for =query-replace= (and the regexp variant).  I prefer not
to use it that way, but only invoke it via =M-x= when I need to test a
regular expression that I would then replace with something else.  The
major upside of this tool is that it highlights groups individually
and offers a live preview of the replacement, making it absolutely
great when dealing with complex sets of regexp constructs.

#+begin_src emacs-lisp
(use-package visual-regexp
  :straight t
  :config
  (setq vr/default-replace-preview nil)
  (setq vr/match-separator-use-custom-face t))
#+end_src

*** wgrep (writable grep)
:PROPERTIES:
:CUSTOM_ID: h:42624165-f4cb-4318-abce-c11232426880
:END:

With =wgrep= we can directly edit the results of a =grep= and save the
changes to all affected buffers.  In principle, this is the same as what
the built-in =occur= offers.  We can use it to operate on a list of
matches by leveraging the full power of Emacs' editing capabilities
(e.g. keyboard macros, query and replace a regexp...).

#+begin_src emacs-lisp
(use-package wgrep
  :straight t
  :commands wgrep
  :config
  (setq wgrep-auto-save-buffer t)
  (setq wgrep-change-readonly-file t)
  :bind (:map grep-mode-map
              ("e" . wgrep-change-to-wgrep-mode)
              ("C-x C-q" . wgrep-change-to-wgrep-mode)))
#+end_src

*** ripgrep (rg.el)
:PROPERTIES:
:CUSTOM_ID: h:31622bf2-526b-4426-9fda-c0fc59ac8f4b
:END:

This is a package that allows us to interface with the external command
line program called "ripgrep".  My [[https://protesilaos.com/codelog/2020-03-25-emacs-ripgrep-rg/][video demo of rg.el]] (2020-03-25)
covers the main features of this tool.

What I find particularly appealing about =rg.el= is that it follows the
interface paradigms of built-in Emacs functions, such as =grep= or =occur=.
With regard to the latter, it even uses the same key to convert the
results' buffer into an editable one: =e= (the ability to write changes is
provided by the =wgrep= package that [[#h:42624165-f4cb-4318-abce-c11232426880][I define right above]]).

Furthermore, =rg.el= interfaces with =ibuffer=, another built-in package, to
list saved searches (see my =prot/rg-save-search-as-name= in the package
declaration below).  Saved searches are regular buffers.  You can switch
to any of them the normal way.

While inside of an =rg.el= buffer, hit =m= to produce a transient menu from
where you can refine your search.  This works just like =magit=.  In
addition, you can consult the universal =C-h m= for documentation
concerning the major mode you are in.

Concerning the key bindings for navigating the results buffer, I find
that the standard motions should retain their general function, while
moving between file headings can be done with =M-{n,p}=.

=rg.el= is designed in such a way that it offers useful functionality
without depending on a particular completion framework (e.g. Ivy, Helm).
I consider this an advantage, especially when combined with the overall
alignment of this package with standard Emacs tools.

Also see my configurations for [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][project-related commands]].

#+begin_src emacs-lisp
(use-package rg
  :straight t
  :config
  (setq rg-group-result t)
  (setq rg-hide-command t)
  (setq rg-show-columns nil)
  (setq rg-show-header t)
  (setq rg-custom-type-aliases nil)
  (setq rg-default-alias-fallback "all")

  (rg-define-search prot/rg-vc-or-dir
    "RipGrep in project root or present directory."
    :query ask
    :format regexp
    :files "everything"
    :dir (or (vc-root-dir)              ; search root project dir
             default-directory)         ; or from the current dir
    :confirm prefix
    :flags ("--hidden -g !.git"))

  (rg-define-search prot/rg-ref-in-dir
    "RipGrep for thing at point in present directory."
    :query point
    :format regexp
    :files "everything"
    :dir default-directory
    :confirm prefix
    :flags ("--hidden -g !.git"))

  (defun prot/rg-save-search-as-name ()
    "Save `rg' buffer, naming it after the current search query.

This function is meant to be mapped to a key in `rg-mode-map'."
    (interactive)
    (let ((pattern (car rg-pattern-history)))
      (rg-save-search-as-name (concat "«" pattern "»"))))

  :bind (("M-s g" . prot/rg-vc-or-dir)
         ("M-s r" . prot/rg-ref-in-dir)
         :map rg-mode-map
         ("s" . prot/rg-save-search-as-name)
         ("C-n" . next-line)
         ("C-p" . previous-line)
         ("M-n" . rg-next-file)
         ("M-p" . rg-prev-file)))
#+end_src

*** Cross-references (xref.el)
:PROPERTIES:
:CUSTOM_ID: h:594bca38-542c-4aac-95f5-349f034c6802
:END:

This is a tool that gets used by a variety of tools, including
=project.el= (see [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Projects (project.el and prot-project.el)]]).  Xref
provides helpful commands for code navigation and discovery, such as
=xref-find-definitions= (=M-.=) and its counterpart =xref-pop-marker-stack=
(=M-,=).  I like the way it is set up by default and have no need to
configure it further.

#+begin_src emacs-lisp
(use-package xref
  :config
  (setq xref-show-definitions-function #'xref--show-defs-minibuffer)
  (setq xref-search-program 'ripgrep))  ; Emacs 28
#+end_src

* Directory, buffer, window management
:PROPERTIES:
:CUSTOM_ID: h:402cb0db-1e93-4b1f-8f6d-e17b4409fb86
:END:
** Dired (directory editor, file manager)
:PROPERTIES:
:CUSTOM_ID: h:c519300f-8a9a-472b-b26d-c2f49adbdb5d
:END:

The directory editor abbreviated as "Dired" (which I pronounce like
"tired", "mired", etc.) is a built-in tool that performs file management
operations inside of an Emacs buffer.  It is simply superb!  I use it
daily for a number of tasks.

You can interactively copy, move (rename), symlink, delete files and
directories, handle permissions, compress or extract archives, run shell
commands, combine Dired with regular editing capabilities as part of a
keyboard macro, search[+replace] across multiple files, encrypt/decrypt
files, and more.  Combine that with the possibility of matching items
with regular expressions or creating an editable Dired buffer and you
have everything you need to maximise your productivity.

Check some of my videos:

+ [[https://protesilaos.com/codelog/2019-08-12-emacs-dired-tweaks/][Dired tweaks and refinements]] (2019-08-12).
+ [[https://protesilaos.com/codelog/2019-09-03-emacs-dired-macros/][Use Dired and keyboard macros]] (2019-09-03).
+ [[https://protesilaos.com/codelog/2019-09-19-dired-narrow/][Techniques to narrow Dired]] (2019-09-19).
+ [[https://protesilaos.com/codelog/2019-11-16-emacs-dired-chmod/][Change multi-file permissions with Dired]] (2019-11-16).
+ [[https://protesilaos.com/codelog/2019-11-13-emacs-bongo-music/][Music management with Dired and Bongo]] (2019-11-13).
+ [[https://protesilaos.com/codelog/2019-11-18-emacs-dired-bongo/][Dired+Bongo and macros to handle music playlists]] (2019-11-18).
+ [[https://protesilaos.com/codelog/2019-12-08-emacs-multi-replace/][Search and replace across multiple files (not Dired-specific)]] (2019-12-08).

*** Base settings for Dired
:PROPERTIES:
:CUSTOM_ID: h:751a310d-c63e-461c-a6e1-dfdfdb01cb92
:END:

The options here are meant to do the following:

+ Copy and delete recursively.  No need to be prompted about each
  action.

+ While in detailed view, search only file names while point is on one
  of them, else apply the query to all the rest.

+ Deletion sends items to the system's Trash, making it safer than the
  standard =rm=.

+ Reformat output.  Sort directories first.  Show dotfiles and place
  them before anything else.  Omit implicit directories (the single and
  double dots).  Use human-readable size units.  There are also options
  for tweaking the behaviour of =find-name-dired=, in the same spirit,
  even though I no longer use that, due to my =prot-dired.el= (more
  below).  To learn everything about these switches, you need to read
  the manpage of =ls=.  You can do so with =M-x man RET ls=.

  - Note that =dired-listing-switches= and =find-ls-option= are configured
    to show hidden directories and files /before/ their non-hidden
    counterparts.  If you want to reverse this order, you must include
    the =-X= option (such as =-AFXhlv --group-directories-first=).

+ Hide all the details by default (permissions, size, etc.).  Those can
  easily be toggled on using the left parenthesis =(=.  Also enable
  highlighting of the current line, which makes it even easier to spot
  the current item (I do not enable this globally, because I only want
  it for line-oriented interfaces, such as Dired's, but not for text
  editing).

+ While having two dired buffers open, the rename and copy operations
  will place the path of the inactive one as the target destination.
  When multiple dired buffers are present, this works between the curent
  and most recently used ones.

+ For Emacs 27.1, Dired can automatically create destination directories
  for its copy and rename operations.  So you can, for example, move
  =file= to =/non-existent-path/file= and you will get what you want right
  away.

+ For Emacs 27.1, renaming a file of a version-controlled repository
  (git) will be done using the appropriate VC mechanism.

The commands with the =contrib/= prefix in =dired-aux= are copied from the
[[https://github.com/oantolin/emacs-config][Emacs configurations of Omar Antolín Camarena]].  They let you insert the
path of a bookmarked directory while performing an action such as
copying and renaming/moving a file.

While =prot-dired.el= (reproduced after the package configurations)
contains a set of commands that are conceptually related to those
present in [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Projects (project.el and prot-project.el)]], as well as the
ones in [[#h:06290f9c-491c-45b2-b213-0248f890c83d][the Ibuffer section]].  In short, they leverage the =fd= executable
to recursively search for directories or directories+files from the root
of the current version-controlled directory tree, if inside one, or just
the present working directory.

Finally, to see how I get commits for marked files that belong to a
given version-controlled (git) repo, see my =prot/vc-print-log= from the
section of this document on the [[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][Generic version control (VC) framework]].

#+begin_src emacs-lisp
(use-package dired
  :config
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'always)
  (setq delete-by-moving-to-trash t)
  (setq dired-listing-switches
        "-AGFhlv --group-directories-first --time-style=long-iso")
  (setq dired-dwim-target t)
  ;; Hooks' syntax is controlled by the `use-package-hook-name-suffix'
  ;; variable.  The "-hook" suffix is intentional.
  :hook ((dired-mode-hook . dired-hide-details-mode)
         (dired-mode-hook . hl-line-mode)))

(use-package dired-aux
  :config
  (setq dired-isearch-filenames 'dwim)
  ;; The following variables were introduced in Emacs 27.1
  (setq dired-create-destination-dirs 'ask)
  (setq dired-vc-rename-file t)

  (defun contrib/cdb--bookmarked-directories ()
    (bookmark-maybe-load-default-file)
    (cl-loop for (name . props) in bookmark-alist
             for fn = (cdr (assq 'filename props))
             when (and fn (string-suffix-p "/" fn))
             collect (cons name fn)))

  (defun contrib/cd-bookmark (bm)
    "Insert the path of a bookmarked directory."
    (interactive
     (list (let ((enable-recursive-minibuffers t))
             (completing-read
              "Directory: " (contrib/cdb--bookmarked-directories) nil t))))
    (when (minibufferp)
      (delete-region (minibuffer-prompt-end) (point-max)))
    (insert (cdr (assoc bm (contrib/cdb--bookmarked-directories)))))

  :bind (:map dired-mode-map
              ("C-+" . dired-create-empty-file)
              ("M-s f" . nil)
              :map minibuffer-local-filename-completion-map
              ("C-c d" . contrib/cd-bookmark)))

(use-package prot-dired
  :straight (:type built-in)
  :bind (("M-s d" .  prot-dired-fd-dirs)
         ("M-s z" . prot-dired-fd-files-and-dirs)))

;; NOTE: deprecated in favour of prot-dired
(use-package find-dired
  :disabled
  :after dired
  :config
  (setq find-ls-option
        '("-ls" . "-AGFhlv --group-directories-first --time-style=long-iso"))
  (setq find-name-arg "-iname"))

(use-package async :straight t)

(use-package dired-async
  :after (dired async)
  :hook (dired-mode-hook . dired-async-mode))
#+end_src

These are the contents of =prot-dired.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: straight/repos/prot-lisp/prot-dired.el src emacs-lisp :tangle no

*** wdired (writable dired)
:PROPERTIES:
:CUSTOM_ID: h:ab318722-fe96-4044-8811-f04f2ed74c06
:END:

This is the editable state of a dired buffer.  You can access it with
=C-x C-q=.  Write changes to files or directories, as if it were a
regular buffer, then confirm them with =C-c C-c=.

+ While in writable state, allow the changing of permissions.
+ While renaming a file, any forward slash is treated like a directory
  and *is created directly* upon successful exit.

#+begin_src emacs-lisp
(use-package wdired
  :after dired
  :commands wdired-change-to-wdired-mode
  :config
  (setq wdired-allow-to-change-permissions t)
  (setq wdired-create-parent-directories t))
#+end_src

*** image-dired (image thumbnails and previews)
:PROPERTIES:
:CUSTOM_ID: h:30e647cb-aee5-45d9-93b4-dc4e855fd0a6
:END:

This tool offers facilities for generating thumbnails out of a selection
of images and displaying them in a separate buffer.  An external program
is needed for converting the images into thumbnails: =imagemagick=.  Other
useful external packages are =optipng= and =sxiv=.  The former is for
operating on PNG files, while the latter is a lightweight image viewer.

I feel this process is a bit cumbersome and can be very slow if you try
to generate lots of images at once.  The culprit is the image converter.

#+begin_src emacs-lisp
(use-package image-dired
  :config
  (setq image-dired-external-viewer "xdg-open")
  (setq image-dired-thumb-size 80)
  (setq image-dired-thumb-margin 2)
  (setq image-dired-thumb-relief 0)
  (setq image-dired-thumbs-per-row 4)
  :bind (:map image-dired-thumbnail-mode-map
              ("<return>" . image-dired-thumbnail-display-external)))
#+end_src

*** dired-subtree (tree-style view/navigation)
:PROPERTIES:
:CUSTOM_ID: h:6f25c4c1-c504-44e8-8fe5-280d780f0897
:END:

Tree-style navigation means that the subdirectories of the current Dired
buffer can be expanded and contracted in place.  It then is possible to
perform the same kind of folding on their subdirectories, and so on.

This is, in my opinion, a far more intuitive interaction than the
default way of inserting subdirectories in the current buffer below
their parent (type =i= over the target dir).  There still are uses for
that technique, but tree-style navigation is easier for day-to-day
tasks.

What I have here:

+ The tab key will expand or contract the subdirectory at point.
+ =C-TAB= will behave just like org-mode handles its headings: hit it
  once to expand a subdir at point, twice to do it recursively, thrice
  to contract the tree.
+ I also have Shift-TAB for contracting the subtree /when the point is
  inside of it/.

#+begin_src emacs-lisp
(use-package dired-subtree
  :straight t
  :after dired
  :config
  (setq dired-subtree-use-backgrounds nil)
  :bind (:map dired-mode-map
              ("<tab>" . dired-subtree-toggle)
              ("<C-tab>" . dired-subtree-cycle)
              ("<S-iso-lefttab>" . dired-subtree-remove)))
#+end_src

*** dired-x (extra Dired functions)
:PROPERTIES:
:CUSTOM_ID: h:56cbacd7-1fe6-447c-a77f-645edbaa3c6c
:END:

These are some additional features that are shipped with Emacs.  The one
I need the most is =dired-jump= and its "other window" variant.  These are
among my favourite commands.  They will always take you to the directory
that contains the current buffer.

'Jumping' works even when you are inside buffers that do not visit
files, such as Magit, Diff, or Eshell.  This is its most valuable
quality!  Edit a file then proceed to do some file management, then
invoke =previous-buffer= or =winner-undo= to go back to where you were (I
have a few key bindings for those in the [[#h:12591f89-eeea-4b12-93e8-9293504e5a12][Window configuration section]]).
Everything happens naturally.  Emacs' interconnectedness at its best!

I keep =dired-clean-confirm-killing-deleted-buffers= to =t= as a safety
mechanism: if a file is ever deleted by accident I can use its buffer to
restore it.  Never happened in practice, but still.

While in =dired-mode=, if you need to open all marked files at once, you
can hit =F=.  It calls =dired-do-find-marked-files=.

#+begin_src emacs-lisp
(use-package dired-x
  :after dired
  :config
  (setq dired-clean-up-buffers-too t)
  (setq dired-clean-confirm-killing-deleted-buffers t)
  (setq dired-x-hands-off-my-keys t)    ; easier to show the keys I use
  (setq dired-bind-man nil)
  (setq dired-bind-info nil)
  :bind (("C-x C-j" . dired-jump)
         ("s-j" . dired-jump)
         ("C-x 4 C-j" . dired-jump-other-window)
         ("s-J" . dired-jump-other-window)
         :map dired-mode-map
         ("I" . dired-info)))
#+end_src

*** dired-like view for the trash directory
:PROPERTIES:
:CUSTOM_ID: h:954adfb4-8f2c-4665-bb5b-e098926341b0
:END:

=trashed= applies the principles of =dired= to the management of the user's
filesystem trash.  Use =C-h m= to see the docs and keybindings for its
major mode.

Basically, its interaction model is as follows:

- =m= to mark for some deferred action, such as =D= to delete, =R= to restore.
- =t= to toggle the status of all items as marked.  Use this without marks
  to =m= (mark) all items, then call a deferred action to operate on them.
- =d= to mark for permanent deletion.
- =r= to mark for restoration.
- =x= to execute these special marks.

#+begin_src emacs-lisp
(use-package trashed
  :straight t
  :config
  (setq trashed-action-confirmer 'y-or-n-p)
  (setq trashed-use-header-line t)
  (setq trashed-sort-key '("Date deleted" . t))
  (setq trashed-date-format "%Y-%m-%d %H:%M:%S"))
#+end_src

** Working with buffers
:PROPERTIES:
:CUSTOM_ID: h:137f16fe-4f88-4b4d-bd71-cd978c9fdcd5
:END:

*** Unique names for buffers
:PROPERTIES:
:CUSTOM_ID: h:60a70340-49dc-4f45-b147-12a4141db42b
:END:

These settings make it easier to work with multiple buffers.  When two
buffers have the same name, Emacs will try to disambiguate them by
displaying their element of differentiation in accordance with the style
of =uniquify-buffer-name-style=.  While =uniquify-strip-common-suffix= will
remove the part of the file system path they have in common.

All such operations are reversed once an offending buffer is removed
from the list, allowing Emacs to revert to the standard of displaying
only the buffer's name.

#+begin_src emacs-lisp
(use-package uniquify
  :config
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-strip-common-suffix t)
  (setq uniquify-after-kill-buffer-p t))
#+end_src

*** Ibuffer and extras (dired-like buffer list manager)
:PROPERTIES:
:CUSTOM_ID: h:06290f9c-491c-45b2-b213-0248f890c83d
:END:

=ibuffer.el= ships with Emacs and it provides a drop-in replacement for
=list-buffers=.  Compared to its counterpart, it allows for granular
control over the buffer list and is more powerful overall.  For this
reason I bind it to =C-x C-b=.

Overview of its features:

- mark and delete buffers same way you do in =dired= (see the previous
  sections on [[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][dired (directory editor, file manager)]]);
- mark by a predicate, such as name, major mode, etc.;
- sort buffers by name, filesystem path, major mode, size;
- run =occur= on the marked buffers (remember: Occur produces a buffer
  that you can edit once you enable the editable state with =e=);
- run =query-replace= or =query-replace-regexp= on marked buffers.

Run the universal help command for major mode documentation (=C-h m=)
while inside =ibuffer= to get a detailed list of all available commands
and their key bindings.

With regard to the following package declaration, these are my tweaks to
the default behaviour and presentation:

+ Prompt for confirmation only when deleting a modified buffer.
+ Hide the summary.
+ Do not open on the other window; use the current one.
+ Do not show empty filter groups.
+ Do not cycle movements.  So do not go to the top when moving downward
  at the last item on the list.

Also watch my [[https://protesilaos.com/codelog/2020-04-02-emacs-intro-ibuffer/][introduction to Ibuffer]] (2020-04-02).

Now some extras that I introduced after I published that video, which
pertain to my =prot-ibuffer.el= library (copied in its entirety below the
package declarations):

+ =prot-ibuffer-buffers-major-mode= produces a filtered list of buffers
  that match the major mode of the current buffer and lets you pick one
  using minibuffer completion.  With an optional prefix argument (=C-u=)
  it places the results in an Ibuffer list.

+ =prot-ibuffer-buffers-vc-root= filters the list to items that match the
  current buffer's version-controlled directory.  In practice, this
  fills the same niche as the built-in =project-switch-to-buffer= (for
  Emacs 28+), with the crucial difference that it neither reads from nor
  writes to the list of known projects (also check my configurations for
  [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Projects (project.el and prot-project.el)]]).  When called with an
  optional prefix argument, this command puts its matching candidates in
  an Ibuffer view.

For those two I received guidance from Omar Antolín Camarena with regard
to the use of =read-buffer= and the =lambda= passed to it (any errors are my
own).  This method informs other tools that this type of completion
pertains to buffers, so they can adapt accordingly.  See, in particular,
[[#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984][Extended minibuffer actions and more (embark.el and prot-embark.el)]].

#+begin_src emacs-lisp
(use-package ibuffer
  :config
  (setq ibuffer-expert t)
  (setq ibuffer-display-summary nil)
  (setq ibuffer-use-other-window nil)
  (setq ibuffer-show-empty-filter-groups nil)
  (setq ibuffer-movement-cycle nil)
  (setq ibuffer-default-sorting-mode 'filename/process)
  (setq ibuffer-use-header-line t)
  (setq ibuffer-default-shrink-to-minimum-size nil)
  (setq ibuffer-formats
        '((mark modified read-only locked " "
                (name 30 30 :left :elide)
                " "
                (size 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " " filename-and-process)
          (mark " "
                (name 16 -1)
                " " filename)))
  (setq ibuffer-saved-filter-groups nil)
  (setq ibuffer-old-time 48)
  :hook (ibuffer-mode-hook . hl-line-mode)
  :bind (("C-x C-b" . ibuffer)
         :map ibuffer-mode-map
         ("* f" . ibuffer-mark-by-file-name-regexp)
         ("* g" . ibuffer-mark-by-content-regexp) ; "g" is for "grep"
         ("* n" . ibuffer-mark-by-name-regexp)
         ("s n" . ibuffer-do-sort-by-alphabetic)  ; "sort name" mnemonic
         ("/ g" . ibuffer-filter-by-content)))

(use-package prot-ibuffer
  :straight (:type built-in)
  :bind (("M-s b" . prot-ibuffer-buffers-major-mode)
         ("M-s v" . prot-ibuffer-buffers-vc-root)))
#+end_src

Here is =prot-ibuffer.el= (find everything in [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: straight/repos/prot-lisp/prot-ibuffer.el src emacs-lisp :tangle no

*** Scratch buffers per-major-mode
:PROPERTIES:
:CUSTOM_ID: h:2695bfa4-89b4-4d7f-aa6e-8ef42f9177aa
:END:

This package will produce a buffer that matches the major mode of the
one you are currently in.  Use it with =M-x scratch=.  Doing that with a
prefix argument (=C-u=) will prompt for a major mode instead.  Simple yet
super effective!

The =prot/scratch-buffer-setup= simply adds some text in the buffer and
renames it appropriately for the sake of easier discovery.  I got the
idea of copying the region from [[https://gist.github.com/eev2/52edbfdb645e26aefec19226c0ca7ad0][a snippet shared by eev2 on GitHub]].

#+begin_src emacs-lisp
(use-package scratch
  :straight t
  :config
  (defun prot/scratch-buffer-setup ()
  "Add contents to `scratch' buffer and name it accordingly.
If region is active, add its contents to the new buffer."
  (let* ((mode major-mode)
         (string (format "Scratch buffer for: %s\n\n" mode))
         (region (with-current-buffer (current-buffer)
                     (if (region-active-p)
                         (buffer-substring-no-properties
                          (region-beginning)
                          (region-end)))
                     ""))
         (text (concat string region)))
    (when scratch-buffer
      (save-excursion
        (insert text)
        (goto-char (point-min))
        (comment-region (point-at-bol) (point-at-eol)))
      (forward-line 2))
    (rename-buffer (format "*Scratch for %s*" mode) t)))
  :hook (scratch-create-buffer-hook . prot/scratch-buffer-setup)
  :bind ("C-c s" . scratch))
#+end_src

** Window configuration
:PROPERTIES:
:CUSTOM_ID: h:12591f89-eeea-4b12-93e8-9293504e5a12
:END:

I believe that Emacs' true power lies in its buffer management rather
than its multiplexing.  The latter becomes inefficient at scale, since
it tries to emulate the limitations of the real world, namely, the
placement of things on a desk.

By leveraging the power of the computer, we can use search methods to
easily reach any item.  There is no need to remain confined to the idea
of a finite space (screen real estate) that needs to be carefully
managed.

That granted, Emacs' multiplexing can be turned into a powerhouse as
well, covering everything from window placement rules, to the recording
of history and layouts, as well as directional or direct window
navigation.

*** Window rules and basic tweaks
:PROPERTIES:
:CUSTOM_ID: h:3d8ebbb1-f749-412e-9c72-5d65f48d5957
:END:

The =display-buffer-alist= and all other functions grouped together with
=prot/window-dired-vc-root-left= are considered *experimental and subject
to review*.  The former is intended as a rule-set for controlling the
display of windows.  While the latter serves as a series of tangible
examples of passing certain rules programmatically, in combination with
a few relevant extras.  The objective is to create a more intuitive
workflow where targeted buffer groups or types are always shown in a
given location, on the premise that predictability improves usability.

For each buffer action in =display-buffer-alist= we can define several
functions for selecting the appropriate window.  These are executed in
sequence, but my usage thus far suggests that a simpler method is just
as effective for my case.

Everything pertaining to buffer actions is documented at length in the
[[https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html#Top][GNU Emacs Lisp Reference Manual]], currently corresponding to version
26.3.  Information can also be found via =C-h f display-buffer= and, for
my settings, =C-h f display-buffer-in-side-window=.

With regard to the contents of the =:bind= keyword of the =window= library,
most key combinations are complementary to the standard ones, such as
=C-x 1= becoming =s-1=, =C-x o= turning into =s-o= and the like.  They *do not
replace* the defaults: they just provide more convenient access to their
corresponding functions.  They all involve the Super key, following the
norms described in the [[#h:fbba4dea-9cc8-4e73-bffa-02aab10a6703][introductory note on the matter]].  Concerning the
=balance-windows-area= I find that it is less intrusive than the original
=balance-windows= normally bound to the same =C-x +=.

For a demo of the =display-buffer-alist= and the functions that
accompany it, watch my [[https://protesilaos.com/codelog/2020-01-07-emacs-display-buffer/][video on rules for buffer placement]]
(2020-01-07).

#+begin_src emacs-lisp
(use-package window
  :init
  (setq display-buffer-alist
        '(;; top side window
          ("\\*Bongo-Elfeed Queue.*"
           (display-buffer-reuse-window display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . -2))
          ("\\*\\(elfeed-mpv-output\\|world-clock\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . -1))
          ("\\*\\(Flymake\\|Package-Lint\\|vc-git :\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 0)
           (window-parameters . ((no-other-window . t))))
          ("\\*Messages.*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 1)
           (window-parameters . ((no-other-window . t))))
          ("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\)\\*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 2)
           (window-parameters . ((no-other-window . t))))
          ;; bottom side window
          ("\\*\\(Output\\|Register Preview\\).*"
           (display-buffer-in-side-window)
           (window-width . 0.16)       ; See the :hook
           (side . bottom)
           (slot . -1)
           (window-parameters . ((no-other-window . t))))
          ("\\*\\(Completions\\|Embark Live Occur\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . bottom)
           (slot . 0)
           (window-parameters . ((no-other-window . t))))
          (".*\\(e?shell\\|vterm\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . bottom)
           (slot . 1))
          ;; left side window
          ("\\*Help.*"
           (display-buffer-in-side-window)
           (window-width . 0.20)       ; See the :hook
           (side . left)
           (slot . 0)
           (window-parameters . ((no-other-window . t))))
          ;; right side window
          ("\\*Faces\\*"
           (display-buffer-in-side-window)
           (window-width . 0.25)
           (side . right)
           (slot . 0)
           (window-parameters
            . ((no-other-window . t)
               (mode-line-format
                . (" "
                   mode-line-buffer-identification)))))
          ("\\*Custom.*"
           (display-buffer-in-side-window)
           (window-width . 0.25)
           (side . right)
           (slot . 1))
          ;; bottom buffer (NOT side window)
          ("\\*\\vc-\\(incoming\\|outgoing\\).*"
           (display-buffer-at-bottom))))
  (setq window-combination-resize t)
  (setq even-window-sizes 'height-only)
  (setq window-sides-vertical nil)
  (setq switch-to-buffer-in-dedicated-window 'pop)
  ;; Hooks' syntax is controlled by the `use-package-hook-name-suffix'
  ;; variable.  The "-hook" suffix is intentional.
  :hook ((help-mode-hook . visual-line-mode)
         (custom-mode-hook . visual-line-mode))
  :bind (("s-n" . next-buffer)
         ("s-p" . previous-buffer)
         ("s-o" . other-window)
         ("s-2" . split-window-below)
         ("s-3" . split-window-right)
         ("s-0" . delete-window)
         ("s-1" . delete-other-windows)
         ("s-5" . delete-frame)
         ("C-x _" . balance-windows)
         ("C-x +" . balance-windows-area)
         ("s-q" . window-toggle-side-windows)))
#+end_src

*** Window history (winner-mode)
:PROPERTIES:
:CUSTOM_ID: h:6b4f7792-6ccd-45d5-b262-01d200639072
:END:

Winner is a built-in tool that keeps a record of buffer and window
layout changes.  It then allows us to move back and forth in the
history of said changes.  I have it enabled by default, while I assign
its two main functions to Super and the right/left arrow keys.

#+begin_src emacs-lisp
(use-package winner
  :hook (after-init-hook . winner-mode)
  :bind (("<s-right>" . winner-redo)
         ("<s-left>" . winner-undo)))
#+end_src

Windmove is also built into Emacs.  It provides functions for selecting
a window in any of the cardinal directions.  I use the Vim keys while
holding down Super and Meta because other mnemonics-based actions
involving just Super or Meta are already occupied.

*** Tabs for window layouts (and prot-tab.el)
:PROPERTIES:
:CUSTOM_ID: h:63ad472f-c9c2-40ad-9675-1dc529487788
:END:

Starting with version 27.1, Emacs has built-in support for two distinct
concepts of "tabs":

1. Work spaces that contain windows in any given layout.
2. A list of buffers presented as buttons at the top of the window.

The former, represented by the =tab-bar= library, is best understood as
the equivalent of "virtual desktops", as these are used in most desktop
environments or window managers.

The latter, implemented in =tab-line=, is the same as the tabs you are
used to in web browsers.  Each buffer is assigned to a single tab.
Clicking on the tab takes you to the corresponding buffer.

I do not need the =tab-line= as I find such tabs to be inefficient at
scale.  Finding a buffer through search mechanisms is generally faster:
it does not matter whether you have ten or a hundred buffers on the list
(unless, of course, they all have similar names in which case you are in
trouble either way---do not forget to check my [[#h:06290f9c-491c-45b2-b213-0248f890c83d][Ibuffer settings]]).

On the other hand, the work spaces (=tab-bar=) are very useful for
organising the various applications that are running inside of Emacs.
You can, for example, have your current project on tab (workspace) 1,
your email and news reader on 2, music on 3, and so on.  Of course, this
can also be achieved by using separate frames for each of these, though
I generally prefer working in a single frame (plus you can define a
window configuration or frameset in a register---see [[#h:6bdfe4d1-f97a-4d89-ab68-e87448a95fea][relevant section]]).

For me tabs are useful as groups of buffers in a given window
configuration.  I do not want a persistent bar with buttons that
introduces extra visual clutter.  Switching to tabs is done through
completion, specifically =prot-tab-select-tab-dwim=.

All settings I configure here are meant to work in accordance with this
abstract conception of "tabs are work spaces".  Here are the main key
chords for =tab-bar= (they will all work properly if you keep the mode
active):

| Key     | Description                       |
|---------+-----------------------------------|
| C-x t b | Open a buffer in a new tab        |
| C-x t d | Open a directory in a new tab     |
| C-x t f | Open a file in a new tab          |
| C-x t 0 | Close current tab                 |
| C-x t 1 | Close all other tabs              |
| C-x t 2 | Open current buffer in new tab    |

These are consistent with the standard commands for handling windows and
accessing buffers/files in the "other window" (the =C-x 4 KEY= pattern).
There is also a command for giving a name to the current tab, accessed
via =C-x t r=, though I find I do not use it.

Here my settings, followed by the entirety of =prot-tab.el=.

#+begin_src emacs-lisp
(use-package tab-bar
  :init
  (setq tab-bar-close-button-show nil)
  (setq tab-bar-close-last-tab-choice 'tab-bar-mode-disable)
  (setq tab-bar-close-tab-select 'recent)
  (setq tab-bar-new-tab-choice t)
  (setq tab-bar-new-tab-to 'right)
  (setq tab-bar-position nil)
  (setq tab-bar-show nil)
  (setq tab-bar-tab-hints nil)
  (setq tab-bar-tab-name-function 'tab-bar-tab-name-all)
  :config
  (tab-bar-mode -1)
  (tab-bar-history-mode -1)
  :bind (("<s-tab>" . tab-next)
         ("<S-s-iso-lefttab>" . tab-previous)))

(use-package prot-tab
  :straight (:type built-in)
  :after tab-bar
  :bind (("<f8>" . prot-tab-tab-bar-toggle)
         ("C-x t t" . prot-tab-select-tab-dwim)
         ("s-t" . prot-tab-select-tab-dwim)))

;; This is only included as a reference.
(use-package tab-line
  :disabled
  :commands (tab-line-mode global-tab-line-mode)
  :config
  (global-tab-line-mode -1))
#+end_src

The =prot-tab.el= code, which is in [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]:

#+include: straight/repos/prot-lisp/prot-tab.el src emacs-lisp :tangle no

*** Directional window motions (windmove)
:PROPERTIES:
:CUSTOM_ID: h:230d96c8-a955-4b82-844d-9de9a1b7c531
:END:

While =C-x o= (=other-window=) is very useful when working with two or three
windows, it can become tiresome.  Thankfully, Emacs comes with a
built-in package to move to a window in the given direction.  I bind the
cardinal directions to Super+Ctrl plus the Vim keys (heresy!), with
aliases for the arrows you find on a standard keyboard's number pad.

The =windmove-create-window= specifies what should happen when trying to
move past the edge of the frame.  The idea with this is to allow it to
create a new window with the contents of the current buffer.  I tried it
for a while but felt that the times it would interfere with my layout
where more than those it would actually speed up my workflow.

#+begin_src emacs-lisp
(use-package windmove
  :config
  (setq windmove-create-window nil)     ; Emacs 27.1
  :bind (("C-s-k" . windmove-up)
         ("C-s-l" . windmove-right)
         ("C-s-j" . windmove-down)
         ("C-s-h" . windmove-left)
         ;; numpad keys clockwise: 8 6 2 4
         ("<kp-up>" . windmove-up)
         ("<kp-right>" . windmove-right)
         ("<kp-down>" . windmove-down)
         ("<kp-left>" . windmove-left)))
#+end_src

*** Transposition and rotation of windows
:PROPERTIES:
:CUSTOM_ID: h:753ea060-57e4-4dba-9bf9-b6337e478839
:END:

The =transpose-frame= library defines a set of commands for shifting the
layout of Emacs windows.  Rather than me describing how these work, I
strongly encourage you to read the "Commentary" section in the source
code.  Do it with =M-x find-library transpose-frame=.

#+begin_src emacs-lisp
(use-package transpose-frame
  :straight t
  :commands (transpose-frame
             flip-frame
             flop-frame
             rotate-frame
             rotate-frame-clockwise
             rotate-frame-anticlockwise)
  :bind (("C-s-t" . flop-frame) ; what I consider "transpose" in this context
         ("C-s-r" . rotate-frame-clockwise)))
#+end_src

* Applications and utilities
:PROPERTIES:
:CUSTOM_ID: h:fa8bd8af-de14-489b-bc56-1a9bb3ef9f0f
:END:

This section includes configurations for programs like email clients,
news reader, music players…  Anything you would normally see in a
standalone application.  The end goal is to eventually integrate every
aspect of my computing inside of Emacs.

** Custom extensions for "focus mode" (prot-logos.el)
:PROPERTIES:
:CUSTOM_ID: h:77d14350-978d-4820-ab7f-4641706c445a
:END:

My =prot-logos.el= (copied verbatim after the package declaration)
provides the necessary infrastructure for my preferred "focus mode"
aesthetic.  Everything is toggled with =prot-logos-focus-mode=.  An
overview of its components, which are contingent on other features:

+ =variable-pitch-mode= (mixed fonts) :: This is a built-in mode that
  remaps the =default= face's font family to a proportionately spaced one
  (also see [[#h:e03b6415-a18f-4058-b9b0-5721d38c6c50][Font configurations (prot-fonts.el)]]).  It is quite
  aggressive as it affects all other faces, unless the active theme
  makes provisions to retain fixed typographic spacing for those
  elements that require it, such as code blocks and indentation (refer
  to [[#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6][Modus themes (my highly accessible themes)]]).  By activating this
  mode, we get a pleasant, prose-friendly effect.

+ Olivetti (centred buffer content) :: I spend much of my time in Emacs
  reading and writing long form texts.  It is nice to be able to easily
  toggle a mode that centres the buffer, allowing for greater comfort.
  Olivetti fulfils that niche very nicely.  It is not aggressive in its
  interface requirements, respects my [[#h:c392fef1-17b7-4cc0-b0e2-2b3edd0eed3c][existing line settings]] and my
  preference for [[#h:1ae84fae-efc1-4bcc-9542-55b4ab8391a3][auto-filling text]], while it does not introduce any kind
  of functionality beyond the scope of bringing the current window's
  buffer to the centre of the view.  This is exactly what I need.  Any
  other enhancement, such as a larger font size can be delegated to a
  specialised instrument.

+ =org-tree-slide= and =org-indent= :: The former is a third-party package
  and the latter is part of the Org distribution.  What the first does
  is to convert headings into pseudo slides.  While the other indents
  content visually, without actually affecting the underlying initial
  spacing, to match the heading's depth.  Those two are disabled by
  default and the =prot-logos-org-presentation= toggle determines
  whether they should be activated.

+ Fringes :: There is also a function that disables fringes on the edge
  of the window.  This ensures that we do not see that area and any
  indicators that may be placed on it (refer to [[#h:26a4fac6-33e2-4f6c-8589-9463df8525c9][Fringe mode]] for the
  relevant configurations, while their overall presentation is
  controlled by the active theme).

+ Scroll lock :: Sometimes I want the cursor to remain centred on the
  screen.  This is controlled by the variable =prot-logos-scroll-lock=.

+ Modeline :: The variable =prot-logos-hidden-modeline= can be set to =t= to
  hide the modeline while entering the focused state.  For me this is
  mostly useful for presentations.  The technical implementation of this
  idea is based on [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][a code snippet by William Ranking]] (who is the
  developer of =olivetti-mode=).

All those combined contribute to an outcome that is appropriate for long
reading or writing sessions, as well as presentations.  I intentionally
do not introduce any font-resizing effect, as my needs vary in that
regard depending on the context (though do refer to the =prot-fonts.el= I
linked to earlier).

For video demonstrations, albeit with earlier versions of my code, watch
these:

+ [[https://protesilaos.com/codelog/2020-07-16-emacs-focused-editing/][“Focused editing” tools for Emacs]] (2020-07-16)
+ [[https://protesilaos.com/codelog/2020-07-17-emacs-mixed-fonts-org/][Configuring mixed fonts for Org mode and others]] (2020-07-17)

#+begin_src emacs-lisp
(use-package face-remap :diminish buffer-face-mode)

(use-package olivetti
  :straight t
  :diminish
  :config
  (setq olivetti-body-width 0.7)
  (setq olivetti-minimum-body-width 80)
  (setq olivetti-recall-visual-line-mode-entry-state t))

(use-package org-tree-slide
  :straight t
  :diminish
  :config
  (setq org-tree-slide-breadcrumbs nil)
  (setq org-tree-slide-header nil)
  (setq org-tree-slide-slide-in-effect nil)
  (setq org-tree-slide-heading-emphasis nil)
  (setq org-tree-slide-cursor-init t)
  (setq org-tree-slide-modeline-display nil)
  (setq org-tree-slide-skip-done nil)
  (setq org-tree-slide-skip-comments t)
  (setq org-tree-slide-fold-subtrees-skipped t)
  (setq org-tree-slide-skip-outline-level 8)
  (setq org-tree-slide-never-touch-face t)
  (setq org-tree-slide-activate-message
        (format "Presentation %s" (propertize "ON" 'face 'success)))
  (setq org-tree-slide-deactivate-message
        (format "Presentation %s" (propertize "OFF" 'face 'error)))
  :bind (:map org-tree-slide-mode-map
         ("<C-down>" . org-tree-slide-display-header-toggle)
         ("<C-right>" . org-tree-slide-move-next-tree)
         ("<C-left>" . org-tree-slide-move-previous-tree)))

(use-package prot-logos
  :straight (:type built-in)
  :diminish visual-line-mode
  :config
  (setq prot-logos-org-presentation nil)
  (setq prot-logos-scroll-lock nil)
  (setq prot-logos-hidden-modeline nil)
  :bind ("<f9>" . prot-logos-focus-mode))
#+end_src

And here is =prot-logos.el= in its totality.  It is available as a file in
[[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]] (same for all my Emacs libraries):

#+include: straight/repos/prot-lisp/prot-logos.el src emacs-lisp :tangle no

** USLS --- Unassuming Sidenotes of Little Significance
:PROPERTIES:
:CUSTOM_ID: h:787df548-0d95-4512-a61d-27852198f561
:END:

This is a library that I am developing to help me flesh out my
note-taking system.  In essence, =usls= is a set of helper functions
around standard Emacs tools, such as =find-file=, =dired=, and internal
libraries like =thingatpt=.  It has no external dependencies whatsoever.
This blog post of mine documents the principles and general ideas about
it: [[https://protesilaos.com/codelog/2020-10-08-intro-usls-emacs-notes/][My simple note-taking system for Emacs (without Org)]] (2020-10-08).

Because this is standard Emacs stuff, I can always benefit from the rest
of my setup, such as to search for file contents in the current
directory.  See [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Generic completion for projects and directory trees]] and
[[#h:b6b13f4f-91f5-416d-9934-b51b4d87770c][Icomplete configurations and extras]].

In the =usls.el= code I wanted to respect key binding conventions, but on
my own setup I can do whatever I want.  So let us make sure we use a
more convenient set of key combinations.  The other options I have here
are for the sake of visibility and are left to their default values.

The code for this project is on the [[https://gitlab.com/protesilaos/usls][USLS Gitlab repo]] and reproduced in
the subsequent code block.

#+begin_src emacs-lisp
(use-package usls
  :straight (:type built-in)
  :config
  (setq usls-directory "~/Documents/notes/")
  (setq usls-known-categories '(economics philosophy politics))
  (setq usls-file-type-extension ".txt") ; {.txt,.org,.md}
  (setq usls-subdir-support nil)
  (setq usls-file-region-separator 'line) ; {'line,'heading, OR string of your choice}
  (setq usls-file-region-separator-heading-level 1)
  :bind (("C-c n d" . usls-dired)
         ("C-c n f" . usls-find-file)
         ("C-c n n" . usls-new-note)
         ("C-c n a" . usls-append-region-buffer-or-file)
         :map usls-mode-map
         ("C-c n i" . usls-id-insert)
         ("C-c n l" . usls-follow-link)))
#+end_src

Here is the =usls.el= code, which is also part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]] (as
with all my Elisp code):

#+include: straight/repos/prot-lisp/usls.el src emacs-lisp :tangle no

** TMR Must Recur (just my simplistic timer)
:PROPERTIES:
:CUSTOM_ID: h:c90ba6fa-ebec-42a2-98a6-3ff9027b1ffa
:END:

Sometimes I need to set off a timer with a notification.  I used to rely
on a homegrown shell script for such a task, but where is the fun in
that?

=tmr.el= satisfies my curiosity to experiment with Elisp, while it also
provides the =tmr= function that I only ever use from Eshell or through
=eval-expression= (=M-:=).

=tmr= works by accepting a number, which it interprets as a count of
minutes.  It can also read strings, such as "1h" for 1 hour and "30s"
for 30 seconds.  Once the time elapses, it produces a system
notification as well as a message in the echo area with information
about the start and end times (review the echo area log with =C-h e=).
Then it plays back some otherwise annoying sound, just to be sure that
you feel an urge to quit whatever caught your attention in the meantime.

#+begin_src emacs-lisp
(use-package tmr
  :straight (:type built-in)
  :config
  (setq tmr-sound-file
        "/usr/share/sounds/freedesktop/stereo/alarm-clock-elapsed.oga"))
#+end_src

This is its code (from [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: straight/repos/prot-lisp/tmr.el src emacs-lisp :tangle no

** Version control tools
:PROPERTIES:
:CUSTOM_ID: h:0e2fe4c7-9d4b-4570-a293-9a9629021ff7
:END:

*** Diff-mode (and prot-diff.el extensions)
:PROPERTIES:
:CUSTOM_ID: h:2ff46d23-09d5-4d92-b0af-2339dc19719f
:END:

This covers the standard =diff-mode.el=, which I use quite often, such as
while interfacing with the built-in Version Control framework (see the
[[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][section on VC]]), or while browsing various code-related newsgroups
through Gnus (refer to the [[#h:5ad80664-3163-4d9d-be65-462637d77903][email settings]]).

Overview of my preferences for how diffs should look:

+ Always start the buffer in a read-only state.  A typo will mess things
  up when trying to apply a patch.
+ After applying a diff hunk (=diff-apply-hunk= with =C-c C-a=) move on to
  the next one.
+ Update hunk headers automatically following an edit to the diff.
+ Do not show word-wise ("refined") changes upon activation.  I prefer
  to do so manually.  All such highlights are removed if you generate
  the buffer again (with =g= as expected) and the default is to not show
  word-wise changes.
+ Do not prettify headers.  I like the standard "patch" looks.  It also
  makes it easier to copy the diff elsewhere.

Now some notes on my =prot-diff.el= extensions, combined with a
description of the basics of =diff-mode= (as always you can get
documentation about the current buffer's major mode with =C-h m=---read
[[#h:83730fe8-d917-4d94-96f4-bbc5c900fe38][How do you learn Emacs?]] in the FAQ section appended to this document):

+ =prot-diff-buffer-dwim= will produce a diff that compares the current
  buffer to the last saved state of the underlying file.  If the buffer
  has no unsaved edits, the command will produce a diff that compares
  the file to its last registered version-controlled state.  Calling the
  command with an optional prefix argument (=C-u=) will enable word-wise
  highlighting across the diff.

+ =prot-diff-refine-dwim= is how I manually control word-wise diff
  highlights.  By default, the command will turn on refined changes
  throughout the buffer.  If called with an optional prefix argument, it
  will operate only on the diff hunk at point.  If the region is active,
  it will instead apply fontification to the diff hunks encompassed by
  the region.  And if word-wise highlights are already present, the
  command will remove everything and leave point back where it was.

+ =prot-diff-narrow-dwim= narrows to the diff hunk at point.  If narrowing
  is already present, it widens the buffer.  When invoked with an
  optional prefix argument, it narrows to the current file.

+ =C-c C-c= or =M-o= takes you to the point of the changes in the source
  file.  If you run this of the diff hunk's heading, you go to the
  beginning of the context.  But if you place the point somewhere inside
  of the diff's added changes or context, you will visit that exact
  position in the original file (does not work for removed text because
  technically it does not exist).

+ When working with patches to source code, which are distributed
  e.g. through email, you can apply the current hunk with =C-c C-a= or
  test for compatibility with =C-c C-t=.  This is a nice way to easily
  merge contributions from others, without having to go through the
  workflow of some proprietary Git/Version-Control forge.

+ With =M-n= and =M-p= you move between hunks.  With =M-}= and =M-{= or =M-N=, =M-P=
  do the same between files.

The =prot-diff-*= commands are part of my =prot-diff.el= library, reproduced
in its entirety after this set of package declarations.

*Pro tip:* enable =outline-minor-mode= to make diff sections foldable.
Check [[#h:a8e737b8-7c90-4c68-8814-acf2f637ffa1][Outline mode, outline minor mode, and extras (prot-outline.el)]].

Also read these sections:

+ [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Projects (project.el and prot-project.el)]].
+ [[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][Generic version control (VC) framework]].

#+begin_src emacs-lisp
(use-package diff-mode
  :config
  (setq diff-default-read-only t)
  (setq diff-advance-after-apply-hunk t)
  (setq diff-update-on-the-fly t)
  ;; The following are from Emacs 27.1
  (setq diff-refine nil)                ; I do it on demand
  (setq diff-font-lock-prettify nil)    ; better for patches
  (setq diff-font-lock-syntax 'hunk-also))

(use-package prot-diff
  :straight (:type built-in)
  ;; `prot-diff-buffer-dwim' replaces the default for `vc-diff' (which I
  ;; bind to another key---see VC section).
  :bind (("C-x v =" . prot-diff-buffer-dwim)
         :map diff-mode-map
         ("C-c C-b" . prot-diff-refine-dwim) ; replace `diff-refine-hunk'
         ("C-c C-n" . prot-diff-narrow-dwim)))
#+end_src

This is =prot-diff.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: straight/repos/prot-lisp/prot-diff.el src emacs-lisp :tangle no

*** Generic version control (VC) framework
:PROPERTIES:
:CUSTOM_ID: h:31deeff4-dfae-48d9-a906-1f3272f29bc9
:END:

VC is a generic framework that works with several version control
systems, else "backends".  In practice though, I only ever use it with
=git=.  Compared with =magit= (see section on [[#h:76d1b392-e693-40dc-b320-d4c1047115ab][Magit configs]]), =vc= offers a
more abstract, buffer-oriented workflow that, I feel, covers all common
version control cases.

With VC we can track and ignore files, commit changes, view diffs and
logs, push and pull from a remote…  Everything you would expect from a
version control system.  But I am not sure it is possible or convenient
to perform tasks such as staging only a particular part of a diff,
handling multiple remotes, interactively rebasing the commit log, etc.

As such, I employ VC as my generalist interface to the most common Git
interactions: diffs, commits, logs.  While I rely on Magit for expedient
access to the more advanced features of Git, all of which are rendered
approachable through an interactive/modal interface.

I started using VC with this a common scenario: to produce a diff of my
current changes formatted as a ready-to-apply patch.  This is done with
=vc-diff= (also see the =vc-git-diff-switches= variable).  A diff hunk can
be applied while in the =*vc-diff*= buffer by hitting =C-c C-a=.  Fairly
easy.  One can always save the diff buffer using the standard =C-x C-w=
command (=write-file=).  Use these to send patches (e.g. via email),
without having to go through proprietary web tools.

Another nice feature is a region-specific commit log with =C-x v h=
(=vc-region-history=).  Highlight a region and run the command to get a
clear view of how it took form.  Quite an easy way to "git blame".  For
a more macroscopic view of the file's entire history you can always rely
on =C-x v g= or my alias =C-x v a= which calls =vc-annotate=.  Commits are
colour-coded with those on the red side of the spectrum being the newest
ones, while those on the blue end representing the older ones.

=C-x v v= (=vc-next-action=) is a hidden gem: a paradigm of minimalism done
right.  On a new project it will first ask you for a backend.  Selecting
=git= will run =git init=.  Invoking the command again will track the file
and commit the changes.  If the file is already being tracked, it will
just proceed to the next step.  It always follows a logical sequence
which translates into a powerful metaphor of going through the process
of committing changes to files.

The commit buffer presents you with a summary section followed by the
body of the commit message, separated by an empty line (shown as a
border) as per the conventions that govern good commit messages.  In the
lower part you can see the affected files (just the current file by
default).  The standard =C-c C-c= confirms the commit, while =C-c C-k=
cancels it.  Furthermore, there is =C-c C-f= to view the file set
concerned (in case it is not already visible below the message area), as
well as =C-c C-d= to produce a diff of what is being committed.

You can review the commit log for the current file with =C-x v l=
(=vc-print-log=) or for the entirety of the current project with =C-x v L=
(=vc-print-root-log=).  From there you can display any diff with =d= or find
the prior state of the commit at point with =f=.  Use the latter as a
starting point for reverting to a prior state.  Also note that while
inside the root log view, you can use an active region to show diffs in
that range of commits.

With =vc-dir=, which I rebind to the more logical "project" mnemonic of
=C-x v p= (=prot/vc-dir-project=), you can mark with =m= several files to add
to a commit.  Use =M= to mark all files with the same status.  This mode
offers easy access to the standard VC actions.  To commit the file at
point or the marked ones hit =v=.  To push do =P=.  Same principle for
diffs, logs, etc.

By the way, rebinding =vc-dir= has another upside of allowing its original
key binding to be assigned to =vc-diff=; which in turn makes that
mnemonically consistent with the =C-x v D= sequence, else =vc-root-diff=
(make sure to check my key re-bindings or aliases).

Some more common actions (read their docstrings for further help):

| Command         | Key chord | VC-dir key |
|-----------------+-----------+------------|
| vc-update       | C-x v +   | +          |
| vc-push         | C-x v P   | P          |
| vc-log-incoming | C-x v I   | I          |
| vc-log-outgoing | C-x v O   | O          |

Based on these (and there are more), you can already see how VC may be
used as your main tool for version control, from committing changes, to
pulling/pushing from/to a remote, viewing commit logs, etc.  It depends
on your needs and preferences.  Run =C-x v C-h= to get a full list of the
possible commands.  Read the docstring of each command for further
information.  Then in each of the various VC modes try =C-h m= for further
help.  Also consult the manual and make liberal use of =C-h f= or =C-h v=.

Changes to all tracked files are highlighted in the fringe thanks to the
=diff-hl= package which is [[#h:5b71e71f-353f-4290-951b-3fc575c0fcba][defined elsewhere in this document]] (as I
consider it an "interface" element).  Any rules that control the
placement of VC-related (and other) buffers are defined in the section
on [[#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][window rules and basic tweaks]] (specifically, refer to the variable
=display-buffer-alist=).

Also watch my [[https://protesilaos.com/codelog/2020-03-30-emacs-intro-vc/][Introduction to the Emacs Version Control framework]]
(2020-03-30).

*Careful with the keybindings* I define.  Many of them do other things by
default and /I might still review them further/.  When in doubt, stick
with the defaults.

#+begin_src emacs-lisp
;; TODO 2020-12-09: put all my code in prot-vc.el and review it
(use-package vc
  :config
  (setq vc-find-revision-no-save t)

  (use-package add-log
    :config
    ;; I use a different account for git commits
    (setq add-log-mailing-address "info@protesilaos.com")
    (setq add-log-keep-changes-together t))

  (use-package log-view
    :config
    (defun prot/vc-print-log (&optional arg)
      "Like `vc-print-log' but for a custom fileset.

With optional prefix ARG (\\[universal-argument]), query for a
number to limit the log to.  Then prompt the user for matching
files in the `default-directory'.  A literal space delimits
multiple files (inserting a space will renew the prompt, asking
for another file match).

In a `dired-mode' buffer, print log for the file at point, or any
marked files, except for when a double prefix argument is passed.
A single prefix arg still provides for a limit to the log.

If a double prefix ARG is passed, prompt for a limit and produce
a log that covers all files in the present directory."
      (interactive "P")
      (let* ((lim (if arg
                      (read-number "Limit log to N entries: " 5)
                    20))
             (dir default-directory)
             (dotless directory-files-no-dot-files-regexp)
             (files (directory-files dir nil dotless t))
             (crm-separator " ")
             (set (cond
                   ((equal arg '(16))
                    files)
                   ((eq major-mode 'dired-mode)
                    (dired-get-marked-files t nil))
                   (t
                    (completing-read-multiple
                     "Select files in current dir: " files nil t))))
             (backend (vc-backend set)))
        (vc-print-log-internal backend set nil nil lim 'with-diff)))

    (defun prot/log-view-extract-commit ()
      "Kill commit from around point in `vc-print-log'."
      (interactive)
      (let ((commit (cadr (log-view-current-entry (point) t))))
        (kill-new (format "%s" commit))
        (message "Copied: %s" commit)))

    (defvar prot/vc-shell-output "*vc-shell-output*"
      "Name of buffer for VC-related shell output.")

    (defun prot/log-view-create-patch ()
      "Create patch for commit at point in `log-view'."
      (interactive)
      (let* ((commit (cadr (log-view-current-entry (point) t)))
             (vc-dir (or (vc-root-dir) default-directory))
             (dirs (list "~/" "~/Desktop/" vc-dir))
             (out-dir ;; (read-directory-name "Output directory: ")
              (completing-read "Output directory: " dirs))
             (buf (get-buffer-create prot/vc-shell-output)))
        (shell-command
         (format "git format-patch -1 %s -o %s" commit out-dir) buf)
        (message "Prepared patch for `%s' and sent it to %s"
                 (propertize commit 'face 'bold)
                 (propertize out-dir 'face 'success))))

    :bind (("C-x v SPC" . prot/vc-print-log)
           :map log-view-mode-map
           ("<tab>" . log-view-toggle-entry-display)
           ("<return>" . log-view-find-revision)
           ("c" . prot/log-view-create-patch)
           ("w" . prot/log-view-extract-commit)
           ("s" . vc-log-search)
           ("o" . vc-log-outgoing)
           ("f" . vc-log-incoming)
           ("F" . vc-update)
           ("P" . vc-push)))

  :bind (("C-x v b" . vc-retrieve-tag)  ; "branch" switch
         ("C-x v t" . vc-create-tag)
         ("C-x v f" . vc-log-incoming)  ; the actual git fetch
         ("C-x v F" . vc-update)        ; "F" because "P" is push
         ("C-x v d" . vc-diff)))

(use-package vc-dir
  :config
  (defun prot/vc-dir (&optional arg)
    "Run `vc-dir' for the current project or directory.
With optional ARG (\\[universal-argument]), use the present
working directory, else default to the root of the current
project, as defined by `vc-root-dir'."
    (interactive "P")
    (let ((dir (if arg default-directory (vc-root-dir))))
      (vc-dir dir)))
  :bind (("C-x v p" . prot/vc-dir)
         :map vc-dir-mode-map
         ("b" . vc-retrieve-tag)
         ("t" . vc-create-tag)
         ("o" . vc-log-outgoing)
         ("f" . vc-log-incoming) ; replaces `vc-dir-find-file' (use RET)
         ("F" . vc-update)       ; symmetric with P: `vc-push'
         ("d" . vc-diff)         ; align with D: `vc-root-diff'
         ("k" . vc-dir-clean-files)))

(use-package vc-git
  :config
  (setq vc-git-diff-switches '("--patch-with-stat" "--histogram"))
  (setq vc-git-print-log-follow t)
  (setq vc-git-revision-complete-only-branches nil) ; Emacs 28
  (setq vc-git-root-log-format
        '("%d%h %ad %an: %s"
          ;; The first shy group matches the characters drawn by --graph.
          ;; We use numbered groups because `log-view-message-re' wants the
          ;; revision number to be group 1.
          "^\\(?:[*/\\| ]+ \\)?\
\\(?2: ([^)]+)\\)?\\(?1:[0-9a-z]+\\) \
\\(?4:[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}\\) \
\\(?3:.*?\\):"
          ((1 'log-view-message)
           (2 'change-log-list nil lax)
           (3 'change-log-name)
           (4 'change-log-date)))))

(use-package vc-annotate
  :config
  (setq vc-annotate-display-mode 'scale) ; scale to oldest
  :bind (("C-x v a" . vc-annotate)       ; `vc-update-change-log' is not in git
         :map vc-annotate-mode-map
         ("<tab>" . vc-annotate-toggle-annotation-visibility)))
#+end_src

**** Commit log editing
:PROPERTIES:
:CUSTOM_ID: h:4df7a1f5-a144-4848-b3aa-8796d76d5fb9
:END:

The =log-edit= library defines a set of general commands that we can use
to, inter alia, commit changes to Git, using the surprisingly powerful
[[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][built-in Version Control (VC) framework]].

Overview of the following tweaks:

+ While editing a commit message, only prompt for confirmation if the
  list of files has changed since the beginning of the editing session.
+ Once the commit is done, remove its buffer.
+ Always add a newline.
+ Do not offer to manually write an =Author:= header.  Though this can be
  useful if someone sends a patch.

Also make sure to read the guide for [[https://chris.beams.io/posts/git-commit/][writing a Git commit message]].  I
always use =auto-fill-mode= to wrap lines to the value of =fill-column= (see
[[#h:c392fef1-17b7-4cc0-b0e2-2b3edd0eed3c][relevant configs]]).

#+begin_src emacs-lisp
(use-package log-edit
  :config
  (setq log-edit-confirm 'changed)
  (setq log-edit-keep-buffer nil)
  (setq log-edit-require-final-newline t)
  (setq log-edit-setup-add-author nil))
#+end_src

*** Interactive git front-end (Magit)
:PROPERTIES:
:CUSTOM_ID: h:76d1b392-e693-40dc-b320-d4c1047115ab
:END:

As noted in the [[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][section on the built-in Version Control framework]] I use
Magit for easy access to the /advanced features of Git/.  While I rely on
the built-in tools for all day-to-day operations.

Magit offers a modal interface where the full power of =git= is neatly
organised in sets of keys that are directly accessible without holding
down any modifiers.

While inside the =magit-status= buffer, hit =?= to produce a transient menu
with the possible vectors to action.  Do it again inside each of the
Magit buffers to view the keys that work for their context.

Consider viewing my [[https://protesilaos.com/codelog/2020-04-04-emacs-intro-magit/][Introduction to Magit]] (2020-04-04) for how to stage
diffs, commit changes, view logs, create branches, and so on.

**** Base Magit settings
:PROPERTIES:
:CUSTOM_ID: h:21ca155a-d0d7-4710-b34a-a0d7a901ac0d
:END:

Magit has great defaults.  I only found a few things that I would like
to customise, which I do in the following package declarations.

#+begin_src emacs-lisp
(use-package magit
  :straight t
  :bind ("C-c g" . magit-status))
#+end_src

**** Magit commits
:PROPERTIES:
:CUSTOM_ID: h:f851e0cc-099c-4309-8517-b2f20ab18ab4
:END:

The following package is configured in accordance with the guidelines
provided by this article on [[https://chris.beams.io/posts/git-commit/][writing a Git commit message]].  The gist is
to write commits that are clean and easy to read.  The =fill-column= is
set elsewhere in this document to 72 characters long.

#+begin_src emacs-lisp
(use-package git-commit
  :after magit
  :config
  (setq git-commit-summary-max-length 50)
  (setq git-commit-known-pseudo-headers
        '("Signed-off-by"
          "Acked-by"
          "Modified-by"
          "Cc"
          "Suggested-by"
          "Reported-by"
          "Tested-by"
          "Reviewed-by"))
  (setq git-commit-style-convention-checks
        '(non-empty-second-line
          overlong-summary-line)))
#+end_src

**** Magit diffs
:PROPERTIES:
:CUSTOM_ID: h:c7a465c1-f33a-42d8-9617-fff3e1460060
:END:

The settings below are for the diff screens that Magit produces.  I just
want to highlight changes within a line, not just the line itself.  I
enable it only for the focused hunk (there is an option for ='all=).

#+begin_src emacs-lisp
(use-package magit-diff
  :after magit
  :config
  (setq magit-diff-refine-hunk t))
#+end_src

**** Magit repo list
:PROPERTIES:
:CUSTOM_ID: h:35972439-0b28-4d33-8091-c6b5f1f02579
:END:

When maintaining a number of projects, it sometimes is necessary to
produce a full list of them with their corresponding Magit status.  That
way you can determine very quickly which repositories need to be
examined further.

#+begin_src emacs-lisp
(use-package magit-repos
  :after magit
  :commands magit-list-repositories
  :config
  (setq magit-repository-directories
        '(("~/Git/Projects" . 1))))
#+end_src

*** Smerge and Ediff
:PROPERTIES:
:CUSTOM_ID: h:fb9e0507-5ab1-4ebd-8870-8c32cfe742c1
:END:

*Read this section, because it matters more than the code below it.*

Sometimes we face a situation where we have conflicting versions of a
file and the version control backend cannot solve them on its own.  This
can happen fairly often when collaborating with other people or, more
generally, when we keep our work spread across multiple feature branches
with diverging histories.  Whenever such conflicts arise, Emacs will
automatically annotate the offending files with special markers that
show the conflicting differences.  Visiting those files will then
activate =smerge-mode=.  At which point we are in control.

Smerge revolves around the concept of dividing the conflicting part into
an "upper" (red) and a "lower" section (green), possibly with their
common ancestor or last point of convergence in the middle (yellow).

With this in mind we can operate on the marked differences by relying on
the functions that Smerge provides, all of which are accessed by default
through the common prefix of =C-c ^=.  Start by typing the prefix followed
by =C-h= to see all possible key chords.  These are the commands I have
used the most:

+ =C-c ^ u= (=smerge-keep-upper=)
+ =C-c ^ l= (=smerge-keep-lower=)
+ =C-c ^ b= (=smerge-keep-base=)
+ =C-c ^ a= (=smerge-keep-all=)
+ =C-c ^ n= (=smerge-next=)
+ =C-c ^ p= (=smerge-prev=)

Proceed to edit the file the way you want until no more conflicts exist.
You can also do things through manual editing, with standard commands
and motions, but that can be prone to errors (which lead to more
conflicts).  At any moment in this process, you can switch to =ediff=,
which offers a more powerful way of working with differences.  Type the
key chord =C-c ^ E= (=smerge-ediff=).

Ediff is a powerhouse that is likely to cover all your needs in this
area (including those you are not aware of).  For our purposes, what
matters is to understand the basic concepts.

The way this tool works is that it starts by producing a layout of the
two conflicting versions with access to a "control panel" for operating
on them.  By default, the panel is positioned on a new frame, but I find
that rather awkward---my config puts it inside an Emacs window instead.
While focusing the control panel, you can move between each diff range
with =n= and =p=.  The focused section will be coloured using red, green,
and yellow, while all other diffs will be presented in gray.

On each diff, you have three options: to use the version of buffer A
(red), of buffer B (green), or a combination of the two.  The keys for
each of those are =a=, =b=, and =+= respectively.  Your choice will be
reflected in buffer C (the yellow one).  Use these to resolve all
conflicts and then quit the session with =q=.

Concerning the combination of versions between A and B, Ediff has the
behaviour of also inserting as plain text the annotation markers that
Smerge relied on.  As of this writing (2020-04-10), I am not aware of an
automatic or convenient way to omit those prior to confirming our edits.
To that end, I tweak the wording of the markers to some unique string
(see package below) and then run =flush-lines= to remove them before
saving the resulting buffer (so right after the =q=).  For more on this,
check =prot/ediff-flush-combination-pattern=.

For =git= users, to actually /reference the common ancestor/ (the point
before the branching paths started) we must run this command once in our
command-line prompt (writes to your global =.gitconfig= file):

#+begin_src
git config --global merge.conflictStyle diff3
#+end_src

This is optional, but I find that I like it.  At any rate, the
configurations I have below are straightforward (learn more about this
powerful tool by hitting =?= inside of its control panel and by consulting
its comprehensive manual):

+ Do not keep all the buffers after exiting the Ediff session.
+ Keep buffers in an editable state.  Otherwise it is impossible to
  perform the changes we are interested in.
+ Show the common ancestor in another buffer.  This helps provide
  further context of how things took their form.
+ Show only the conflicting parts.  This is not a review of all diffs.
+ Prefer putting windows side-by-side, rather than one below the other.
+ Do not enter the ediff session in a new frame.  This also means that
  the control panel will be inside an Emacs window (at the bottom part)
  rather than in a tiny frame of its own.

There actually is nothing in terms of Smerge-related configurations.
The package is small and does one thing well.

Also watch my video of [[https://protesilaos.com/codelog/2020-04-10-emacs-smerge-ediff/][Smerge and Ediff for git conflict resolution]]
(2020-04-10).

#+begin_src emacs-lisp
(use-package smerge-mode)

(use-package ediff
  :config
  (setq ediff-keep-variants nil)
  (setq ediff-make-buffers-readonly-at-startup nil)
  (setq ediff-merge-revisions-with-ancestor t)
  (setq ediff-show-clashes-only t)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)

  ;; Tweak those for safer identification and removal
  (setq ediff-combination-pattern
        '("<<<<<<< prot-ediff-combine Variant A" A
          ">>>>>>> prot-ediff-combine Variant B" B
          "####### prot-ediff-combine Ancestor" Ancestor
          "======= prot-ediff-combine End"))

  ;; TODO automate process in a robust way, or at least offer a good key
  ;; binding.
  (defun prot/ediff-flush-combination-pattern ()
    "Remove my custom `ediff-combination-pattern' markers.

This is a quick-and-dirty way to get rid of the markers that are
left behind by `smerge-ediff' when combining the output of two
diffs.  While this could be automated via a hook, I am not yet
sure this is a good approach."
    (interactive)
    (flush-lines ".*prot-ediff.*" (point-min) (point-max) nil)))
#+end_src

** Command-line shells
:PROPERTIES:
:CUSTOM_ID: h:2c1966a1-bf33-4fe3-ac45-9f31158efd9b
:END:

It should come to no surprise that Emacs can operate as both a /terminal
emulator for command line shells/ and /toolkit for terminal emulators/.
The present section covers both cases.

**** Eshell (like M-x shell but in elisp)
:PROPERTIES:
:CUSTOM_ID: h:103a8795-c29c-474f-9ddf-ecafaa2f6775
:END:

/NOTE 2020-12-14: Pending major review/.

While I did read the =eshell= manual fairly early in my introduction to
Emacs (July 2019), I failed to appreciate its added value.  Sure, you
could run Elisp commands as well as those of the standard shells.  But
that did not seem like an obvious step forward.  More of a lateral
movement at best, for it was asking for a whole new way of thinking
about the shell that could potentially complicate things in other areas.

After gaining some experience with Emacs, I now (April 2020) have
developed a newfound appreciation of Eshell's flexibility.  The fact
that it can understand elisp means that you can develop entirely new
modes of interaction that involve the command line and extend into other
Emacs major modes.  For example, you can =cd= into a directory and then
=dired= to access the full power of Emacs' /superb/ file manager (also check
the [[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][section on Dired]]).

The core value of Eshell is that it behaves like an ordinary buffer.
This means that we can build our own functions for moving around and
operating on text.  =prot/eshell-put-last-output-to-buffer= puts that in
concrete terms.  The function will take the output of the last command
and put it in a new buffer.  You can then select that buffer, edit it as
you will and, say, =C-x C-w= to write it permanently to a file.

Here is another case where integration with standard Emacs commands
truly shines.  In Eshell, =cd= followed by the equals sign will produce a
numbered list of the directories you have accessed.  With =cd -NUM= you
can switch to the one you want.  So far so good, how about we also
switch to a dired buffer from there?  Do it with =cd -NUM && dired=.

Speaking of directories, =eshell-cd-on-directory= allows you to omit =cd=
and just type in the path to a directory.  Awesome!  And while on the
topic of Dired, you can use =dired-jump= to always switch to a =dired=
buffer of the present working directory.  To that I add my own little
utility (=prot/eshell-file-parent-dir=) for jumping to the directory of
the file at point: very useful in cases where you get files from
different sources, such as with =find= (though do also check the various
options for running =find= with =dired=, like =find-name-dired=).

Extensibility is seamless.  =prot/eshell-complete-history= offers a
completion interface to the input history.  No need for awkard back and
forth or for searching for a regexp without any immediate feedback.  In
a similar fashion =prot/eshell-complete-recent-dir= provides completion
for switching directly to a recent directory.  While the more general
=prot/eshell-find-subdirectory-recursive= lets you switch to a
subdirectory somewhere inside the path you are.

Instead of outlining the remaining features of Eshell, *I strongly
encourage you to read the manual*.  It is fairly short.  What I have here
is just an early sample of what can be achieved with a few tweaks.

Also check these valuable resources:

+ [[https://cestlaz.github.io/post/using-emacs-66-eshell-elisp][Mike Zamansky's video demo]] that also shows how to program an Eshell
  switcher.
+ [[https://www.youtube.com/watch?v=RhYNu6i_uY4][Howard Abrahams' video]] that covers the features of Eshell.
+ [[https://ambrevar.xyz/emacs-eshell/][Pierre Neidhardt's detailed blog post]] on the pros and cons of Eshell.

Finally, a few notes about contributions I have received:

+ [[https://gitlab.com/dije][Phil Hudson (@dije on Gitlab)]] explained how =concat= is superfluous when
  combined with =format= and demonstrated how to use a specifier (=%s=) to
  make a uniform string out of the output of some command combined with
  predefined text.

+ Phil also helped me with =prot/eshell-find-subdirectory-recursive= by
  highlighting some inefficient routines in the original design.  This
  inspired me to revisit the code and make it cleaner overall.  The gist
  is that only the present working directory needs to be abbreviated.

+ Another user who preferred to remain anonymous sent me
  =contrib/eshell-cat-with-syntax-highlight= which will apply syntax
  highlighting to the output of a =cat= command.  The code I got was using
  =define-advice=, so I tweaked it a bit to work with =advice-add= because I
  find that syntax easier to follow.  I also made minor tweaks to the
  docstring.

+ Same principle as above for =contrib/electrify-ls=.

+ Any errors are my own.

#+begin_src emacs-lisp
(use-package eshell
  :bind ("<s-return>" . eshell))

(use-package esh-mode
  :commands prot/eshell-minor-mode
  :config
  ;; used by other functions below
  (declare-function ffap-file-at-point "ffap.el")

  (defmacro prot/eshell-ffap (name doc &rest body)
    "Make commands for `eshell' find-file-at-point.
NAME is how the function is called.  DOC is the function's
documentation string.  BODY is the set of arguments passed to the
`if' statement to be evaluated when a file at point is present."
    `(defun ,name ()
       ,doc
       (interactive)
       (let ((file (ffap-file-at-point)))
         (if file
             ,@body
           (user-error "No file at point")))))

  (prot/eshell-ffap
   prot/eshell-insert-file-at-point
   "Insert (cat) contents of file at point."
   (progn
     (goto-char (point-max))
     (insert (concat "cat " file))
     (eshell-send-input)))

  (prot/eshell-ffap
   prot/eshell-kill-save-file-at-point
   "Add to kill-ring the absolute path of file at point."
   (progn
     (kill-new (concat (eshell/pwd) "/" file))
     (message "Copied full path of %s" file)))

  (prot/eshell-ffap
   prot/eshell-find-file-at-point
   "Run `find-file' for file at point (ordinary file or dir).
Recall that this will produce a `dired' buffer if the file is a
directory."
   (find-file file))

  (prot/eshell-ffap
   prot/eshell-file-parent-dir
   "Open `dired' with the parent directory of file at point."
   (dired (file-name-directory file)))

  (defun prot/eshell-put-last-output-to-buffer ()
    "Produce a buffer with output of last `eshell' command."
    (interactive)
    (let ((eshell-output (buffer-substring-no-properties
                          (eshell-beginning-of-output)
                          (eshell-end-of-output))))
      (with-current-buffer (get-buffer-create "*last-eshell-output*")
        (erase-buffer)
        (insert eshell-output)
        (switch-to-buffer-other-window (current-buffer)))))

  (defun prot/eshell-complete-redirect-to-buffer ()
    "Complete the syntax for appending to a buffer via `eshell'."
    (interactive)
    (insert
     (format " >>> #<%s>"
             (read-buffer-to-switch "Switch to buffer: "))))

  (defun prot/eshell-narrow-output-highlight-regexp ()
    (interactive)
    (let ((regexp (read-regexp "Regexp to highlight")))
      (narrow-to-region (eshell-beginning-of-output)
                        (eshell-end-of-output))
      (goto-char (point-min))
      (highlight-regexp regexp 'hi-yellow)))

  ;;;; NOTE by Prot 2020-06-16: the following two advice-add snippets
  ;;;; will need to be reviewed to make sure they do not produce
  ;;;; undesirable side effects.

  ;; syntax highlighting implementation modified from
  ;; https://emacs.stackexchange.com/questions/50385/use-emacs-syntax-coloring-when-not-in-emacs
  ;;
  ;; This command also makes it possible to, e.g., cat an encrypted and/or
  ;; compressed file.
  (defun contrib/eshell-cat-with-syntax-highlight (&rest args)
    "Like `eshell/cat' but with syntax highlighting.
To be used as `:override' advice to `eshell/cat'."
    (setq args (eshell-stringify-list (flatten-tree args)))
    (dolist (filename args)
      (let ((existing-buffer (get-file-buffer filename))
            (buffer (find-file-noselect filename)))
        (eshell-print
         (with-current-buffer buffer
           (if (fboundp 'font-lock-ensure)
               (font-lock-ensure)
             (with-no-warnings
               (font-lock-fontify-buffer)))
           (let ((contents (buffer-string)))
             (remove-text-properties 0 (length contents) '(read-only nil) contents)
             contents)))
        (unless existing-buffer
          (kill-buffer buffer)))))

  (advice-add 'eshell/cat :override #'contrib/eshell-cat-with-syntax-highlight)

  ;; Turn ls results into clickable links.  Especially useful when
  ;; combined with link-hint.  Modified from
  ;; https://www.emacswiki.org/emacs/EshellEnhancedLS
  (define-button-type 'eshell-ls
    'supertype 'button
    'help-echo "RET, mouse-2: visit this file"
    'follow-link t)

  (defun contrib/electrify-ls (name)
    "Buttonise `eshell' ls file names.
Visit them with RET or mouse click.  This function is meant to be
used as `:filter-return' advice to `eshell-ls-decorated-name'."
    (add-text-properties 0 (length name)
                         (list 'button t
                               'keymap button-map
                               'mouse-face 'highlight
                               'evaporate t
                               'action #'find-file
                               'button-data (expand-file-name name)
                               'category 'eshell-ls)
                         name)
    name)

  (advice-add 'eshell-ls-decorated-name :filter-return #'contrib/electrify-ls)
  :bind (:map eshell-mode-map
              ("M-k" . eshell-kill-input)
              ("C-c i" . prot/eshell-insert-file-at-point)
              ("C-c f" . prot/eshell-find-file-at-point)
              ("C-c C-f" . prot/eshell-find-file-at-point)
              ("C-c o" . prot/eshell-put-last-output-to-buffer)
              ("C-c w" . prot/eshell-kill-save-file-at-point)
              ("C-c >" . prot/eshell-complete-redirect-to-buffer)
              ("C-c C-j" . prot/eshell-file-parent-dir)
              ("C-c h" . prot/eshell-narrow-output-highlight-regexp)
              ("C-c =" . prot/eshell-complete-recent-dir)))

(use-package esh-module
  :config
  (setq eshell-modules-list             ; Needs review
        '(eshell-alias
          eshell-basic
          eshell-cmpl
          eshell-dirs
          eshell-glob
          eshell-hist
          eshell-ls
          eshell-pred
          eshell-prompt
          eshell-script
          eshell-term
          eshell-tramp
          eshell-unix)))

(use-package em-dirs
  :after esh-mode
  :config
  (setq eshell-cd-on-directory t))

(use-package em-tramp
  :after esh-mode
  :config
  (setq password-cache t)
  (setq password-cache-expiry 600))

(use-package em-hist
  :after esh-mode
  :config
  (setq eshell-hist-ignoredups t)
  (setq eshell-save-history-on-exit t)

  (defun prot/eshell-complete-history ()
    "Insert element from `eshell' history using completion."
    (interactive)
    (let ((hist (ring-elements eshell-history-ring)))
      (insert
       (completing-read "Input history: " hist nil t))))

  (defun prot/eshell-complete-recent-dir (&optional arg)
    "Switch to a recent `eshell' directory using completion.
With \\[universal-argument] also open the directory in a `dired'
buffer."
    (interactive "P")
    (let* ((dirs (ring-elements eshell-last-dir-ring))
           (dir (completing-read "Switch to recent dir: " dirs nil t)))
      (insert dir)
      (eshell-send-input)
      (when arg
        (dired dir))))

  ;; `cl-remove-if' is used right below
  (declare-function cl-remove-if "cl-seq")

  (defun prot/eshell-find-subdirectory-recursive ()
    "Recursive `eshell/cd' to subdirectory.
This command has the potential for infinite recursion: use it
wisely or prepare to use `eshell-interrupt-process'."
    (interactive)
    (let* ((dir (abbreviate-file-name (eshell/pwd)))
           (contents (directory-files-recursively dir ".*" t nil nil))
           (dirs (cl-remove-if-not (lambda (x)
                                     (or (file-directory-p x)
                                         (string-match-p "\\.git" x)))
                                   contents))
           (selection (completing-read
                       (format "Find sub-dir from %s (%s): "
                               (propertize dir 'face 'success)
                               (length dirs))
                       dirs nil t)))
      (insert selection)
      (eshell-send-input)))

  :bind (:map eshell-hist-mode-map
              ("M-s" . nil) ; I use this for lots of more useful commands
              ("M-r" . prot/eshell-complete-history) ; use this to find input history
              ("C-c d" . prot/eshell-find-subdirectory-recursive)))
#+end_src

**** Shell (M-x shell)
:PROPERTIES:
:CUSTOM_ID: h:98804f0d-f2dd-41a4-b8df-c1bd04ef7f7a
:END:

/NOTE 2020-12-14: Pending major review/.

This is a shell (Bash, in my case) that runs inside of Emacs.  Unlike
terminal emulators, this one can use standard Emacs keys and behaves
much like an ordinary buffer.  It also integrates nicely with the
built-in completion tools, which makes it particularly nice to work
with.

The one area where this Shell differs substantially from ordinary
buffers is with regard to the command prompt: you can re-run a command
on the scroll-back buffer by just hitting =RET= while point is on its line
(no need to go back to the end and cycle the command history with =M-p= or
=M-n=).

Another peculiarity relative to the standard commands in the terminal is
to search backward through your history with =M-r= (whereas in a terminal
emulator you use =C-r=).

Run =C-h m= inside of a shell buffer to learn about all the key bindings
and corresponding functions.

#+begin_src emacs-lisp
(use-package shell
  :commands shell-command
  :config
  (setq ansi-color-for-comint-mode t)
  (setq shell-command-prompt-show-cwd t) ; Emacs 27.1
  :bind (("<s-S-return>" . shell)))
#+end_src

** Calendar
:PROPERTIES:
:CUSTOM_ID: h:b4040bc0-7a2a-4f17-824d-42de621bd1b9
:END:

Some basic settings for =calendar.el=.  It is used by Org-mode facilities
that require date/time input (see following sections).

#+begin_src emacs-lisp
(use-package calendar
  :config
  (setq calendar-mark-diary-entries-flag t)
  (setq calendar-time-display-form
        '(24-hours ":" minutes
                   (when time-zone
                     (concat " (" time-zone ")"))))
  (setq calendar-week-start-day 1)      ; Monday
  (setq calendar-date-style 'iso)
  (setq calendar-christian-all-holidays-flag nil)
  (setq calendar-holidays
        (append holiday-local-holidays  ; TODO set local holidays
                holiday-solar-holidays))

  (use-package solar
    :config
    (setq calendar-latitude 35.17
          calendar-longitude 33.36))

  (use-package lunar
    :config
    (setq lunar-phase-names
          '("New Moon"
            "First Quarter Moon"
            "Full Moon"
            "Last Quarter Moon")))

  :hook (calendar-today-visible-hook . calendar-mark-today))
#+end_src

** Org-mode (personal information manager)
:PROPERTIES:
:CUSTOM_ID: h:4e8347de-415e-4804-b383-d61499e05ca1
:END:

In its purest form, Org is a markup language that is similar to
Markdown: symbols are used to denote the meaning of a construct in its
context, such as what may represent a headline element or a phrase that
calls for emphasis.

What lends Org its super powers though is everything else built around
it: a rich corpus of Elisp functions that automate, link, combine,
enhance, structure, or otherwise enrich the process of using this rather
straightforward system of plain text notation.

Couched in those terms, Org is at once a distribution of well integrated
libraries and a vibrant ecosystem that keeps producing new ideas and
workflows on how to organise one's life with plain text.

The present document is written in =org-mode= while its website version is
outputted by a tool (also part of Org) that exports Org notation to its
HTML equivalent.

Regarding the following code block, I strongly encourage you to make
liberal use of Emacs' documentation facilities to learn more about
functions, variables, symbols provided herein.  And do not forget to
read Org's manual.

What follows in an exposition about each of the subsesctions of this
package declaration:

+ Org links :: The =org-store-link= is one of the commands I use the most,
  as it allows me to, inter alia, connect the various sections of this
  document.  Use it to store a direct link to the heading you are
  currently under.  Or to produce a properly formatted link to supported
  buffers you are visiting (e.g. another file).

  There are several ways to insert such links.  With =C-c C-l= (which
  calls =org-insert-link=) you will be prompted to select a stored link
  from the link.  It will be inserted at point, using the right markup,
  but will first ask you for a description text.  Otherwise you can
  invoke =C-c C-l= with an active region, to create a link to that
  location with the selected text becoming the description.  Else just
  call =org-insert-last-stored-link= to skip the interactive process and
  insert the last link outright.

  In addition to these, =org-insert-link= can be used to create references
  on demand.  Say you have a URL on the kill-ring: =C-c C-l=, then =C-y=
  followed by =RET= to confirm your input.  Complete the process with a
  description and you are good to go.

+ Org capture :: The =org-capture= tool is a powerful way to quickly
  produce some kind of structured information that gets stored in the
  appropriate place.  The type of data and the way to store is
  determined by a system of templates which accepts a series of possible
  specifiers as well as the evaluated part of arbitrary elisp code.

  Each template is accessed via a key.  These are listed in a temporary
  buffer when you call =org-capture=.  Unique keys give direct access to
  their template, whereas templates that share a common initial key will
  produce a second selection list with the remaining options.  In the
  latter case, the initial key entry has no call to an actual function,
  but is just written as a heading.

  The visibility of a template is explicitly controlled by the alist
  =org-capture-templates-contexts=.  This allows us to tell Org the
  context in which we want certain options to appear in.  Otherwise they
  remain concealed from our view.  Equipped with this piece of
  functionality, we can freely write highly specialised templates that
  capture structured text when viewing some particular item, but are not
  needed for more general purposes.  I do this for certain actions that
  only come into effect when reading email inside of the relevant =gnus=
  buffers (also check my [[#h:5ad80664-3163-4d9d-be65-462637d77903][comprehensive configurations for email]] and the
  Gnus news/mail reader).

  Speaking of mail, you will notice some specifiers like =:fromname=.  This
  refers to the =From= field in emails and will capture the name part only.
  Other similar keywords are =:from= (name and email), =:fromaddress= (email
  only), =:subject=.

  Specifiers that start with the caret sign (=^=) represent prompts for
  further user input.  The pattern =^{TEXT}= is a prompt whose expression
  is =TEXT=.  To offer possible options, use =^{Initial|ONE|TWO|THREE}=,
  where the first entry is the text of the prompt and all the rest are
  the available choices (depending on your completion framework, you may
  need to add an empty option as well, with =||=, should you ever want to
  insert nothing).  In some templates I use the =^t= specifier, which is a
  built-in method to ask for a specific date.

  The text that goes into a template can be written as part of a string or
  inside a function that is then evaluated.  I generally prefer to use
  simple strings, though I might revise this approach going forward.  To
  insert a new line inside of a string, use =\n=.

  The =%?= specifier determines where the point shall end in once the
  template is parsed.  While =%i= will insert the contents of the active
  region, if any.

  As things currently stand, my capture templates always write to headings
  inside of files.  Note though that there are more possibilities, as
  described in the manual.

  A file can be specified by its absolute path or just a name.  In the
  latter case, its location is understood relative to =org-directory=.
  When using the =file+headline= pattern, non-existent files are created
  automatically once you call the relevant template.  Same for their
  respective headings.

  Finally, the =contrib/org-capture-no-delete-windows= and relevant =advice=
  address a problem I have when =org-capture= fails to conclude its actions
  when called from inside of a side window (for more on those, refer to
  the section on [[#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][Window rules and basic tweaks]]).  The code is taken
  directly from this [[https://stackoverflow.com/a/54251825][Stack Overflow thread]].

  Consider watching my [[https://protesilaos.com/codelog/2020-02-04-emacs-org-capture-intro/][primer on org-capture]] (2020-02-04) which shows all
  of the above in action.

+ Org agenda :: The =org-agenda= is not just a single interface.  It
  rather is your conduit to a set of utilities for reading timestamped
  tasks.  From there you can keep track of all the relevant entries you
  have inserted in the files declared as part of =org-agenda-files= list.

  Running =org-agenda= will present you with a list of possible options:
  the "dispatcher" as it called.  Here is a primer (there are many more
  functions documented in the manual):

  - From the dispatcher, the =a= is where you keep track of all the items
    that have a date assigned to them, be it =SCHEDULED= or =DEADLINE=.  To
    assign such a value to a heading use =C-c C-s= or =C-c C-d= respectively.
    Run those commands with a universal prefix (=C-u=) to remove the
    timestamp.  Hit =/= to filter this view to match particular tags.

  - In the dispatcher's menu, the =t= will list all your tasks, regardless
    of whether they have a date assigned to them.  You can then filter by
    keyword, regular expression, etc.  Check the top of the buffer for
    information on how to do that.

  - And the =n= in the dispatcher will offer you a combined view of the
    above.

+ Org export :: I do not have much to offer here, apart from the setup
  that handles consistent heading IDs and anchor tags (the latter
  concerns the HTML output).  Everything in that segment, minus some
  minor tweaks from my part, is copied from this detailed tutorial on
  [[https://writequit.org/articles/emacs-org-mode-generate-ids.html][Org header IDs]].  Basically, the problem is that exported HTML does not
  have reliable anchor tags for the various sections of the document.
  This fixes the issue (read the article for more).

Finally, note that I sometimes deliver simple presentations using Org.
Refer to [[#h:77d14350-978d-4820-ab7f-4641706c445a][Custom extensions for "focus mode" (prot-logos.el)]].

#+begin_src emacs-lisp
;; Pro tip: If you are reading the source code, use C-c '
;; (`org-edit-special') to put the code block in a dedicated buffer and
;; then activate `prot-outline-minor-mode-safe' to conveniently browse
;; this massive package declaration.
(use-package org
  :straight (:host nil :type git
             :repo "https://code.orgmode.org/bzg/org-mode") ; Get Org from its source
  ;; ;; Use this instead of the above if you want the built-in version.
  ;; :straight (:type built-in)
  :init
  (setq org-directory "~/Org")
  (setq org-imenu-depth 7)
  :config
;;;; general settings
  (setq org-adapt-indentation nil)      ; No, non, nein, όχι!
  (setq org-special-ctrl-a/e nil)
  (setq org-special-ctrl-k nil)
  (setq org-M-RET-may-split-line '((default . nil)))
  (setq org-hide-emphasis-markers t)
  (setq org-hide-macro-markers t)
  (setq org-hide-leading-stars nil)
  (setq org-structure-template-alist    ; CHANGED in Org 9.3, Emacs 27.1
        '(("s" . "src")
          ("E" . "src emacs-lisp")
          ("e" . "example")
          ("q" . "quote")
          ("v" . "verse")
          ("V" . "verbatim")
          ("c" . "center")
          ("C" . "comment")))
  (setq org-catch-invisible-edits 'show)
  (setq org-return-follows-link nil)
  (setq org-loop-over-headlines-in-active-region 'start-level)
  (setq org-modules '(ol-gnus ol-info ol-eww))

;;;; refile, todo
  (setq org-refile-targets
        '((org-agenda-files . (:maxlevel . 2))
          (nil . (:maxlevel . 2))))
  (setq org-refile-use-outline-path t)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-use-cache t)
  (setq org-reverse-note-order nil)
  (setq org-todo-keywords
        '((sequence "TODO(t)" "|" "DONE(D)" "CANCEL(C)")
          (sequence "MEET(m)" "|" "MET(M)")
          (sequence "STUDY(s)" "|" "STUDIED(S)")
          (sequence "WRITE(w)" "|" "WROTE(W)")))
  (setq org-todo-keyword-faces
        '(("MEET" . '(font-lock-preprocessor-face org-todo))
          ("STUDY" . '(font-lock-variable-name-face org-todo))
          ("WRITE" . '(font-lock-type-face org-todo))))
  (setq org-priority-faces
        '((?A . '(org-scheduled-today org-priority))
          (?B . org-priority)
          (?C . '(shadow org-priority))))
  (setq org-fontify-done-headline nil)
  (setq org-fontify-quote-and-verse-blocks t)
  (setq org-fontify-whole-heading-line nil)
  (setq org-fontify-whole-block-delimiter-line t)
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t)
  (setq org-track-ordered-property-with-tag t)
  (setq org-highest-priority ?A)
  (setq org-lowest-priority ?C)
  (setq org-default-priority ?A)

;;;; tags
  (setq org-tag-alist                   ; TODO review org tag list
        '((:startgroup)
          ("@work")
          ("@priv")
          (:endgroup)
          ("emacs")
          ("modus")
          ("politics")
          ("economics")
          ("philosophy")
          ("paper")
          ("book")
          ("essay")
          ("article")
          ("mail")
          ("website")))

;;;; log
  (setq org-log-done 'time)
  (setq org-log-note-clock-out nil)
  (setq org-log-redeadline nil)
  (setq org-log-reschedule nil)
  (setq org-read-date-prefer-future 'time)

;;;; links
  (setq org-link-keep-stored-after-insertion t)

;;;; capture
  (setq org-capture-templates
        `(("a" "Article to write" entry
           (file+headline "tasks.org" "Writing list")
           ,(concat "* WRITE %^{Title} %^g\n"
                    "SCHEDULED: %^t\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n:END:\n\n"
                    "%i%?"))
          ("b" "Basic task for future review" entry
           (file+headline "tasks.org" "Basic tasks that need to be reviewed")
           ,(concat "* %^{Title}\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":END:\n\n"
                    "%i%l"))
          ("t" "Task with a due date" entry
           (file+headline "tasks.org" "Task list with a date")
           ,(concat "* %^{Scope of task||TODO|STUDY|MEET} %^{Title} %^g\n"
                    "SCHEDULED: %^t\n"
                    ":PROPERTIES:\n:CAPTURED: %U\n:END:\n\n"
                    "%i%?"))
          ("r" "Reply to an email" entry
           (file+headline "tasks.org" "Mail correspondence")
           ,(concat "* TODO [#B] %:subject :mail:\n"
                    "SCHEDULED: %t\n:"
                    "PROPERTIES:\n:CONTEXT: %a\n:END:\n\n"
                    "%i%?"))))

  (setq org-capture-templates-contexts
        '(("r" ((in-mode . "gnus-article-mode")
                (in-mode . "gnus-summary-mode")))))

  ;; Source: https://stackoverflow.com/a/54251825
  (defun contrib/org-capture-no-delete-windows (oldfun args)
    (cl-letf (((symbol-function 'delete-other-windows) 'ignore))
      (apply oldfun args)))

  ;; Same source as above
  (advice-add 'org-capture-place-template
              :around 'contrib/org-capture-no-delete-windows)

;;;; agenda
;;;;; Basic agenda setup
  (setq org-default-notes-file "~/Org/notes.org")
  (setq org-agenda-files '("~/Org" "~/.emacs.d" "~/Documents"))
  (setq org-agenda-span 14)
  (setq org-agenda-start-on-weekday 1)  ; Monday
  (setq org-agenda-confirm-kill t)
  (setq org-agenda-show-all-dates t)
  (setq org-agenda-show-outline-path nil)
  (setq org-agenda-window-setup 'current-window)
  (setq org-agenda-skip-comment-trees t)
  (setq org-agenda-menu-show-matcher t)
  (setq org-agenda-menu-two-columns nil)
  (setq org-agenda-sticky nil)
  (setq org-agenda-custom-commands-contexts nil)
  (setq org-agenda-max-entries nil)
  (setq org-agenda-max-todos nil)
  (setq org-agenda-max-tags nil)
  (setq org-agenda-max-effort nil)

;;;;; General agenda view options
  (setq org-agenda-prefix-format
        '((agenda . " %i %-12:c%?-12t% s")
          (todo . " %i %-12:c")
          (tags . " %i %-12:c")
          (search . " %i %-12:c")))
  (setq org-agenda-sorting-strategy
        '(((agenda habit-down time-up priority-down category-keep)
           (todo priority-down category-keep)
           (tags priority-down category-keep)
           (search category-keep))))
  (setq org-agenda-breadcrumbs-separator "->")
  (setq org-agenda-todo-keyword-format "%-1s")
  (setq org-agenda-diary-sexp-prefix nil)
  (setq org-agenda-fontify-priorities 'cookies)
  (setq org-agenda-category-icon-alist nil)
  (setq org-agenda-remove-times-when-in-prefix nil)
  (setq org-agenda-remove-timeranges-from-blocks nil)
  (setq org-agenda-compact-blocks nil)
  (setq org-agenda-block-separator ?—)

  (defun prot/org-agenda-format-date-aligned (date)
    "Format a DATE string for display in the daily/weekly agenda.
This function makes sure that dates are aligned for easy reading.

Slightly tweaked version of `org-agenda-format-date-aligned' that
produces dates with a fixed length."
    (require 'cal-iso)
    (let* ((dayname (calendar-day-name date t))
           (day (cadr date))
           (day-of-week (calendar-day-of-week date))
           (month (car date))
           (monthname (calendar-month-name month t))
           (year (nth 2 date))
           (iso-week (org-days-to-iso-week
                      (calendar-absolute-from-gregorian date)))
           (weekyear (cond ((and (= month 1) (>= iso-week 52))
                            (1- year))
                           ((and (= month 12) (<= iso-week 1))
                            (1+ year))
                           (t year)))
           (weekstring (if (= day-of-week 1)
                           (format " (W%02d)" iso-week)
                         "")))
      (format "%s %2d %s %4d%s"
              dayname day monthname year weekstring)))

  (setq org-agenda-format-date #'prot/org-agenda-format-date-aligned)

;;;;; Agenda marks
  (setq org-agenda-bulk-mark-char "#")
  (setq org-agenda-persistent-marks nil)

;;;;; Agenda diary entries
  ;; NOTE: I don't use the diary, but here it is anyway
  (setq org-agenda-insert-diary-strategy 'date-tree)
  (setq org-agenda-insert-diary-extract-time nil)
  (setq org-agenda-include-diary t)

;;;;; Agenda follow mode
  (setq org-agenda-start-with-follow-mode nil)
  (setq org-agenda-follow-indirect t)

;;;;; Agenda multi-item tasks
  (setq org-agenda-dim-blocked-tasks t)
  (setq org-agenda-todo-list-sublevels t)

;;;;; Agenda filters and restricted views
  (setq org-agenda-persistent-filter nil)
  (setq org-agenda-restriction-lock-highlight-subtree t)

;;;;; Agenda items with deadline and scheduled timestamps
  (setq org-agenda-include-deadlines t)
  (setq org-deadline-warning-days 5)
  (setq org-agenda-skip-scheduled-if-done nil)
  (setq org-agenda-skip-scheduled-if-deadline-is-shown t)
  (setq org-agenda-skip-timestamp-if-deadline-is-shown t)
  (setq org-agenda-skip-deadline-if-done nil)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled 1)
  (setq org-agenda-skip-scheduled-delay-if-deadline nil)
  (setq org-agenda-skip-additional-timestamps-same-entry nil)
  (setq org-agenda-skip-timestamp-if-done nil)
  (setq org-agenda-search-headline-for-time t)
  (setq org-scheduled-past-days 365)
  (setq org-deadline-past-days 365)
  (setq org-agenda-move-date-from-past-immediately-to-today t)
  (setq org-agenda-show-future-repeats t)
  (setq org-agenda-prefer-last-repeat nil)
  (setq org-agenda-timerange-leaders
        '("" "(%d/%d): "))
  (setq org-agenda-scheduled-leaders
        '("Scheduled: " "Sched.%2dx: "))
  (setq org-agenda-inactive-leader "[")
  (setq org-agenda-deadline-leaders
        '("Deadline:  " "In %3d d.: " "%2d d. ago: "))
  ;; Time grid
  (setq org-agenda-time-leading-zero t)
  (setq org-agenda-timegrid-use-ampm nil)
  (setq org-agenda-use-time-grid t)
  (setq org-agenda-show-current-time-in-grid t)
  (setq org-agenda-current-time-string
        "Now -·-·-·-·-·-·-")
  (setq org-agenda-time-grid
        '((daily today require-timed)
          (0600 0700 0800 0900 1000 1100
                1200 1300 1400 1500 1600
                1700 1800 1900 2000 2100)
          " ....." "-----------------"))
  (setq org-agenda-default-appointment-duration nil)

;;;;; Agenda global to-do list
  (setq org-agenda-todo-ignore-with-date t)
  (setq org-agenda-todo-ignore-timestamp t)
  (setq org-agenda-todo-ignore-scheduled t)
  (setq org-agenda-todo-ignore-deadlines t)
  (setq org-agenda-todo-ignore-time-comparison-use-seconds t)
  (setq org-agenda-tags-todo-honor-ignore-options nil)

;;;;; Agenda tagged items
  (setq org-agenda-show-inherited-tags t)
  (setq org-agenda-use-tag-inheritance
        '(todo search agenda))
  (setq org-agenda-hide-tags-regexp nil)
  (setq org-agenda-remove-tags nil)
  (setq org-agenda-tags-column -120)

;;;;; Agenda entry
  ;; NOTE: I do not use this right now.  Leaving everything to its
  ;; default value.
  (setq org-agenda-start-with-entry-text-mode nil)
  (setq org-agenda-entry-text-maxlines 5)
  (setq org-agenda-entry-text-exclude-regexps nil)
  (setq org-agenda-entry-text-leaders "    > ")

;;;;; Agenda logging and clocking
  ;; NOTE: I do not use these yet, though I plan to.  Leaving everything
  ;; to its default value for the time being.
  (setq org-agenda-log-mode-items '(closed clock))
  (setq org-agenda-clock-consistency-checks
        '((:max-duration "10:00" :min-duration 0 :max-gap "0:05" :gap-ok-around
                         ("4:00")
                         :default-face ; This should definitely be reviewed
                         ((:background "DarkRed")
                          (:foreground "white"))
                         :overlap-face nil :gap-face nil :no-end-time-face nil
                         :long-face nil :short-face nil)))
  (setq org-agenda-log-mode-add-notes t)
  (setq org-agenda-start-with-log-mode nil)
  (setq org-agenda-start-with-clockreport-mode nil)
  (setq org-agenda-clockreport-parameter-plist '(:link t :maxlevel 2))
  (setq org-agenda-search-view-always-boolean nil)
  (setq org-agenda-search-view-force-full-words nil)
  (setq org-agenda-search-view-max-outline-level 0)
  (setq org-agenda-search-headline-for-time t)
  (setq org-agenda-use-time-grid t)
  (setq org-agenda-cmp-user-defined nil)
  (setq org-sort-agenda-notime-is-late t)
  (setq org-sort-agenda-noeffort-is-high t)

;;;;; Agenda column view
  ;; NOTE I do not use these, but may need them in the future.
  (setq org-agenda-view-columns-initially nil)
  (setq org-agenda-columns-show-summaries t)
  (setq org-agenda-columns-compute-summary-properties t)
  (setq org-agenda-columns-add-appointments-to-effort-sum nil)
  (setq org-agenda-auto-exclude-function nil)
  (setq org-agenda-bulk-custom-functions nil)

;;;; code blocks
  (setq org-confirm-babel-evaluate nil)
  (setq org-src-window-setup 'current-window)
  (setq org-edit-src-persistent-message nil)
  (setq org-src-fontify-natively t)
  (setq org-src-preserve-indentation t)
  (setq org-src-tab-acts-natively t)
  (setq org-edit-src-content-indentation 0)

;;;; export
  (setq org-export-with-toc t)
  (setq org-export-headline-levels 8)
  (setq org-export-dispatch-use-expert-ui nil)
  (setq org-html-htmlize-output-type nil)
  (setq org-html-head-include-default-style nil)
  (setq org-html-head-include-scripts nil)
  (use-package ox-texinfo)
  ;; FIXME: how to remove everything else?
  (setq org-export-backends '(html texinfo))

  (defun prot/ox-html ()
    (interactive)
    (org-html-export-as-html nil nil nil t nil))

  (defun prot/ox-texinfo ()
    (interactive)
    (org-texinfo-export-to-info))

;;;; IDs
  (setq org-id-link-to-org-use-id
        'create-if-interactive-and-no-custom-id)

  ;; Copied from this article (with minor tweaks from my side):
  ;; <https://writequit.org/articles/emacs-org-mode-generate-ids.html>.
  (defun contrib/org-id-get (&optional pom create prefix)
    "Get the CUSTOM_ID property of the entry at point-or-marker
POM. If POM is nil, refer to the entry at point. If the entry
does not have an CUSTOM_ID, the function returns nil. However,
when CREATE is non nil, create a CUSTOM_ID if none is present
already. PREFIX will be passed through to `org-id-new'. In any
case, the CUSTOM_ID of the entry is returned."
    (org-with-point-at pom
      (let ((id (org-entry-get nil "CUSTOM_ID")))
        (cond
         ((and id (stringp id) (string-match "\\S-" id))
          id)
         (create
          (setq id (org-id-new (concat prefix "h")))
          (org-entry-put pom "CUSTOM_ID" id)
          (org-id-add-location id (format "%s" (buffer-file-name (buffer-base-buffer))))
          id)))))

  (defun contrib/org-id-headlines ()
    "Add CUSTOM_ID properties to all headlines in the current
file which do not already have one."
    (interactive)
    (org-map-entries
     (lambda () (contrib/org-id-get (point) t))))

  :bind (("C-c a" . org-agenda)
         ("C-c c" . org-capture)
         ("C-c l" . org-store-link)
         :map org-mode-map
         ("C-'" . nil)
         ("C-," . nil)
         ("<C-return>" . nil)
         ("<C-S-return>" . nil)
         ("C-c S-l" . org-toggle-link-display)
         ("C-c C-S-l" . org-insert-last-stored-link)))
#+end_src

** Email settings
:PROPERTIES:
:CUSTOM_ID: h:5ad80664-3163-4d9d-be65-462637d77903
:END:

Configuring email can be quite the challenge, largely because we have
been used to the likes of Thunderbird, where you log in once and then
everything "just works".  The toolset for my current setup consists of
the following:

+ =mbsync= to synchronise my email server and my local mail directories.
  This is a new addition to my toolkit.  Gnus used to fetch mail
  directly, but a dedicated tool is better for performance and
  flexibility.  Also good for keeping local copies of messages and for
  using multiple mail clients.

+ Gnus (also pronounced as "News" or "Nooz", etc.), which is a powerful
  newsreader and email client that is built into Emacs.  It serves as my
  default interface for reading email and Usenet sources.

+ Mu4e as my secondary mail user agent, intended for archiving purposes
  and arbitrary searches.  I used to only have Gnus configured, but its
  search capabilities left something to be desired.

+ The built-in capabilities to compose and send email, which apply to
  both Gnus and mu4e.

*** Client-agnostic email settings (credentials, message composition, encryption)
:PROPERTIES:
:CUSTOM_ID: h:a82766be-daab-4925-b23a-1c5ffd47e599
:END:

Before configuring any mail user agent, we need to establish the
absolute essentials: who we are, where our credentials are stored, and
whether encryption is supported.  We must also define how message
composition should work.  This is what the following configurations are
about.

The =prot-common-auth-get-field= is a generic tool for finding the values
pertaining to our login credentials (see [[#h:c82dcbfa-97d0-4f7c-85af-768ce90f1372][prot-common.el]]).  You will see
this function used elsewhere in this document.  For example, to find the
username and password for host =hostname= we do:

#+begin_example emacs-lisp
(prot-common-auth-get-field "hostname" :user)   ; login name
(prot-common-auth-get-field "hostname" :secret) ; password
#+end_example

Then we set up the interface for composing emails:

+ The =mail-user-agent= and =message-mail-user-agent= concern the default
  email composition buffer, called with =C-x m= or any other facility that
  falls back to the =compose-mail= function.  The default is =message-mode=.
  When Gnus is running, it will insert relevant paraphernalia, the most
  important of which is the "Gcc" header.  The Gcc saves a copy of the
  outgoing message to a specified group.  In my case that is the "Sent"
  directory of my default account.

+ Function =prot/message-header-add-gcc= is directly related to the above.
  The inserted header points to my public email account, which is
  declared in =user-mail-address=.  This concerns only the creation of new
  emails.  While replying to a message, the appropriate information is
  filled in automatically, based on parameters I specify in the section
  about [[#h:dc8811af-dec8-4ca8-a62e-0b500928d10b][account settings and essential configurations]].

+ The value of =message-citation-line-format= is expanded into something
  like /"On 2020-02-19, 13:54 +0200, NAME <EMAIL> wrote:"/.  To learn
  about all the date-related specifiers, it is better for you to read
  the documentation with =C-h v format-time-string=.

+ As for the configurations of =mm-encode= and =mml-sec=, these are meant to
  come into effect when encrypting and signing an outgoing message with
  =C-c C-m C-e= (=mml-secure-message-sign-encrypt=).  The guided key
  selection will ask for confirmation on who to encrypt to.  It presents
  a list with the available keys.  Items are marked with =m= and then the
  mail can be sent with the standard commands (e.g. =C-c C-c=).  I select
  myself and whomever the other party is.  This is an extra step just to
  make sure that I have everything right with regard to the keys and the
  correspondent[s] when using encryption.  If this becomes a task I use
  regularly, I will need to streamline things.  For the time being, I
  want the added confirmation.

#+begin_src emacs-lisp
(use-package auth-source
  :init
  (setq auth-sources '("~/.authinfo.gpg"))
  (setq user-full-name "Protesilaos Stavrou")
  (setq user-mail-address "public@protesilaos.com")

  (defun prot-common-auth-get-field (host prop)
    "Find PROP in `auth-sources' for HOST entry."
    (let* ((source (auth-source-search :host host))
           (field (plist-get
                   (flatten-list source)
                   prop)))
      (if source
          field
        (user-error "No entry in auth sources")))))

(use-package mm-encode
  :config
  (setq mm-encrypt-option 'guided)
  (setq mm-sign-option 'guided))

(use-package mml-sec
  :config
  (setq mml-secure-openpgp-encrypt-to-self t)
  (setq mml-secure-openpgp-sign-with-sender t)
  (setq mml-secure-smime-encrypt-to-self t)
  (setq mml-secure-smime-sign-with-sender t))

(use-package message
  :config
  (setq mail-user-agent 'message-user-agent)
  (setq compose-mail-user-agent-warnings nil)
  (setq message-mail-user-agent nil)    ; default is `gnus'
  (setq mail-signature "Protesilaos Stavrou\nprotesilaos.com\n")
  (setq message-signature "Protesilaos Stavrou\nprotesilaos.com\n")
  (setq message-citation-line-format "On %Y-%m-%d, %R %z, %f wrote:\n")
  (setq message-citation-line-function
        'message-insert-formatted-citation-line)
  (setq message-confirm-send nil)
  (setq message-kill-buffer-on-exit t)
  (setq message-wide-reply-confirm-recipients t)
  (setq message-default-charset 'utf-8)
  (add-to-list 'mm-body-charset-encoding-alist '(utf-8 . base64))

  (defun prot/message-header-add-gcc ()
    "While `gnus' is running, add pre-populated Gcc header.

The Gcc header places a copy of the outgoing message to the
appropriate directory of the IMAP server, as per the contents of
~/.authinfo.gpg.

In the absence of a Gcc header, the outgoing message will not
appear in the appropriate maildir directory, though it will still
be sent.

Add this function to `message-header-setup-hook'."
    (if (gnus-alive-p)
        (progn
          (when (message-fetch-field "Gcc")
            (message-remove-header "Gcc"))
          (message-add-header "Gcc: nnmaildir+pub:Sent"))
      (message "Gnus is not running. No GCC field inserted.")))

  :hook ((message-header-setup-hook . prot/message-header-add-gcc)
         (message-setup-hook . message-sort-headers)))
#+end_src

Below is a sample with the contents of my =authinfo.gpg=.  This is read,
inter alia, by =gnus= and =smtpmail= to be able to both fetch and send
messages from the given account.  I strongly encourage you to *encrypt
this file* if you add your login credentials there.  Do it from inside
=dired= with =: e= while the point is over the file.  Emacs can decrypt all
encrypted files automatically.

#+begin_example
machine prv port 993 login MAIL password SECRET
machine inf port 993 login MAIL password SECRET
machine pub port 993 login MAIL password SECRET

machine mail.gandi.net port 465 login MAIL password SECRET
machine mail.gandi.net port 465 login MAIL password SECRET
machine mail.gandi.net port 465 login MAIL password SECRET
#+end_example

Refer to your email provider's documentation in order to determine the
port number and server address you need to use for sending and receiving
messages.  The =MAIL= is either your email address or some username for
logging into the account.

Note that the terms I use above for =prv=, =inf=, and =pub= are just arbitrary
names for the given =MAIL= and =SECRET= combination.  This allows us to
reference each name in the Gnus configurations, and share those in a
public document like this one, without worrying about leaking private
data.

*** Contents of `~/.mbsyncrc' (external tool)
:PROPERTIES:
:CUSTOM_ID: h:88a605b8-d5b5-486f-87c9-0c80b423ae36
:END:

I already noted in the introduction to [[#h:5ad80664-3163-4d9d-be65-462637d77903][Email settings]] that my emails are
synced locally using the =mbsync= executable.  This program is part of a
package that, depending on your operating system, is called "isync".
Read the [[https://wiki.archlinux.org/index.php/Isync][Arch Wiki entry on mbsync]].

My =~/.mbsyncrc= is furnished below.  Note that the =awk= call reads from
the =~/.authinfo.gpg= that I document at the end of the section on
[[#h:a82766be-daab-4925-b23a-1c5ffd47e599][Client-agnostic email settings]].

#+begin_example conf
IMAPAccount pub
Host mail.gandi.net
User EMAIL-ADDRESS-HERE
PassCmd "gpg2 -q --for-your-eyes-only -d ~/.authinfo.gpg | awk -F ' ' '/pub/ { print $NF; exit; }'"
SSLType IMAPS

IMAPStore pub-remote
Account pub

MaildirStore pub-local
Subfolders Verbatim
# The trailing "/" is important
Path ~/.mail/pub/
Inbox ~/.mail/pub/Inbox

Channel pub
Master :pub-remote:
Slave :pub-local:
# Include everything
Patterns *

Create Both
# Expunge Both
SyncState *

##########

IMAPAccount inf
Host mail.gandi.net
User EMAIL-ADDRESS-HERE
PassCmd "gpg2 -q --for-your-eyes-only -d ~/.authinfo.gpg | awk -F ' ' '/inf/ { print $NF; exit; }'"
SSLType IMAPS

IMAPStore inf-remote
Account inf

MaildirStore inf-local
Subfolders Verbatim
# The trailing "/" is important
Path ~/.mail/inf/
Inbox ~/.mail/inf/Inbox

Channel inf
Master :inf-remote:
Slave :inf-local:
# Include everything
Patterns *

Create Both
# Expunge Both
SyncState *

##########

IMAPAccount prv
Host mail.gandi.net
User EMAIL-ADDRESS-HERE
PassCmd "gpg2 -q --for-your-eyes-only -d ~/.authinfo.gpg | awk -F ' ' '/prv/ { print $NF; exit; }'"
SSLType IMAPS

IMAPStore prv-remote
Account prv

MaildirStore prv-local
Subfolders Verbatim
# The trailing "/" is important
Path ~/.mail/prv/
Inbox ~/.mail/prv/Inbox

Channel prv
Master :prv-remote:
Slave :prv-local:
# Include everything
Patterns *

Create Both
# Expunge Both
SyncState *
#+end_example

*** Gnus for reading email, mailing lists, and more
:PROPERTIES:
:CUSTOM_ID: h:14cf6fea-54eb-4faa-bb16-3739485c929a
:END:

The documentation describes Gnus as the /"coffee-brewing, all singing,
all dancing, kitchen sink newsreader"/.  I chuckled when I first read it,
thinking to myself that the developers have an interesting sense of
humour.  Then I decided to quickly go through the list of user-facing
customisation options: =M-x customize-apropos-groups RET gnus RET= …  Not
so funny after all!

Simply put, Gnus is massive.  This makes it both extremely powerful and
incredibly complicated for new users.  Do not let that scare you though:
start small and gradually tweak things as you go.  This is how you
approach Emacs itself.  Learn the basics and then figure out your needs
as you go.  This is what I always do.

Now some basic information on the abstractions that Gnus relies on:

1. The default Gnus buffer is called "Group".  It will present you with
   a list of all the news sources you have subscribed to.  By default,
   Gnus only displays messages that have not been read.  The same
   applies for groups.  The "Group" buffer will be empty the very first
   time you log in because you have not subscribed to anything yet.  Use
   =g= to fetch new messages from the sources.  If you only want to
   refresh the group at point, do it with =M-g=.
2. The "Server" buffer contains a list with all the sources you have
   specified for discovering news.  In my case, these are my email
   accounts and a Usenet server where mailing lists are hosted.  To
   access the "Server" buffer from inside the "Group" buffer, just hit
   the caret sign =^=.  To subscribe to an item, place the point over it
   and hit =u=.  Do that for your email's inbox and for whatever mailing
   lists you intend to follow.
3. The "Summary" buffer contains all the messages of a group.  Hitting
   the return key over a message will split the view in two, with the
   list above and the message below.  Use =n= or =p= to move to the next or
   previous unread message (or =N= and =P= to just the next/prev).  You
   access the "Summary" buffer both from the "Group" and the "Server" by
   entering a group.

It is essential to take things slowly (and first test whether your
messages are being sent and that you can receive them).  Each buffer has
some unique functions that are relevant to the current interface.  To
learn more about them, use =C-h m=.  Do it for all three of the above.
Also rely on =C-h k= to get information about what each key does in the
given context (or just start a key sequence and then hit =C-h= to display
possible combinations in a new Help buffer).

Now a couple more things about the "Group" buffer:

+ A group can be assigned a level of importance.  This is a grade whose
  highest score is 1 and the lowest is 6 (customisable though).  Each
  level has a different colour.  To assign a new value to the group at
  point, do it with =S l= and then give it a number.  Once you have graded
  your groups, you can perform various actions on a per-level basis.
  For example, to refresh all levels from 1 up to 3 but not higher, pass
  a numeric argument to the standard =g= command.  So =C-3 g= (this is the
  same as =C-u 3 g=).
+ Groups can be organised by topic.  Create a new one with =T n= and give
  it a name.  Move a group to a topic with =T m=.  To toggle the view of
  topics use =t= (I have a hook that does this automatically at startup).
  The level of indentation tells us whether a topic is a sub-set of
  another.  Use =TAB= or =C-u TAB= to adjust it accordingly.  As with
  levels, you can operate on a per-topic basis.  For example, to catch
  up on all the news of a given topic (mark all as read), you place the
  point over it, hit =c= and then confirm your choice.

As noted, Gnus will only show you a list of unread items.  To view all
your groups, hit =L=.  Use the lower case version =l= to view only the
unread ones.  To produce a Summary buffer with read items, hit =C-u RET=
over a group and specify the number of messages you want to list (the
other option is =C-u M-g= from inside the Summary).  Another useful trick
for the Summary buffer is the use of the caret sign (=^=) to show you the
previous message that the current item is a reply to.

Consider watching my [[https://protesilaos.com/codelog/2020-02-02-emacs-gnus-intro/][Introduction to Gnus]] (2020-02-02).

Notwithstanding the numerous customisation options and certain perhaps
idiosyncratic design choices, some prior experience with Emacs' various
interfaces will definitely come in handy: Gnus uses similar metaphors
for navigating and parsing information.  *It still is important to read
the manual though*.

Now here comes the nice part of leveraging the integration that Emacs
offers: in my [[#h:4e8347de-415e-4804-b383-d61499e05ca1][Org mode configurations]] I have a simple template to
capture the current buffer's link.  This means that we can quickly
convert any item into a task/note and always be able to go back to the
original message by following the link.  /Found an interesting suggestion
in some mailing list?/ Capture it.  /Need to act on an email later?/
Capture, capture, capture.  Same principle applies to the integration
with Dired as a means of attaching files to emails (see [[#h:0fabe523-725e-41eb-9e8b-061d74dc7bda][next section]]),
and to the EPA subsystem for GPG encryption.

The package declarations below are divided into several subsections to
make things easier to read and keep track of.  Remember to use =C-h v VAR=
to read documentation about each =VAR= or simply place the point over it
and then hit =C-h v= to pre-populate the results (=C-h f= is the equivalent
for functions, =C-h o= for other symbols).  Whenever you see some
formatting customisations concerning time units, it is better refer to
the documentation of the function =format-time-string= to understand the
meaning of the various date/time specifiers.

**** Gnus account settings and essential configurations
:PROPERTIES:
:CUSTOM_ID: h:dc8811af-dec8-4ca8-a62e-0b500928d10b
:END:

Here I only furnish the essentials for the basic Gnus functionality.
Subsequent sections expand on the particulars.

+ The =gnus-select-method= sets the default method for fetching news
  items. As I want to read mail from several accounts in addition to
  following Usenet sources, I choose to set it to nil.

+ The =gnus-secondary-select-methods= is where my accounts are specified.
  Each =nnmaildir= list points to a specific line in my =authinfo.gpg= file
  (whose format I described in the [[#h:a82766be-daab-4925-b23a-1c5ffd47e599][base email settings]]).  My emails all
  use the same server so this method allows me to specify the username
  (email) and password combination for each of them /without/ making this
  information public.

+ The =gnus-parameters= are designed to move my outgoing messages to the
  "Sent" folder of the account that replies to a given email and to use
  the right email address, depending on the context.  While the variable
  =gnus-gcc-mark-as-read= ensures that the outgoing messages are marked as
  read.  The =prot-common-auth-get-field= is defined in [[#h:c82dcbfa-97d0-4f7c-85af-768ce90f1372][prot-common.el]].
  It is used to get the relevant user name.

+ The "agent" is enabled here and configured in the [[#h:fccaadbb-ea22-4d1f-ae79-ef1f45f3befa][following section]].

+ Setting the =gnus-novice-user= to =nil= has the effect of reducing prompts
  for potentially destructive commands, such as deleting an email.  Too
  many confirmations end up being annoying, but you might opt to keep
  this to =t= if you are still new to Gnus.

+ The variables concerning the "dribble" file may be reviewed.  The idea
  is to store the state of Gnus in case Emacs crashes.  This has never
  happened and, therefore, I am not putting too much effort into solving
  a highly unlikely problem.

+ Consider reviewing =nnmail-expiry-wait= only after you have some
  experience with Gnus.  I set it to a fairly high value.

#+begin_src emacs-lisp
(use-package gnus
  :config
  ;; accounts
  (setq gnus-select-method '(nnnil ""))
  (setq gnus-secondary-select-methods
        '((nntp "news.gwene.org")
          (nnmaildir "prv" (directory "~/.mail/prv"))
          (nnmaildir "inf" (directory "~/.mail/inf"))
          (nnmaildir "pub" (directory "~/.mail/pub"))))

  (setq nnir-method-default-engines
        '((nnmaildir . notmuch)))

  (setq gnus-parameters
        '((".*"                         ; fallback option
           (posting-style
            (gcc "nnmaildir+inf:Sent")
            (From
             (format "%s <%s>" user-full-name
                     (prot-common-auth-get-field "inf" :user)))))
          ("prv"
           (posting-style
            (gcc "nnmaildir+prv:Sent")
            (From
             (format "%s <%s>" user-full-name
                     (prot-common-auth-get-field "prv" :user)))))
          ("pub"
           (posting-style               ; Uses default name+mail
            (gcc "nnmaildir+pub:Sent")))))

  (setq gnus-gcc-mark-as-read t)
  (setq gnus-agent t)
  (setq gnus-novice-user nil)
  ;; checking sources
  (setq gnus-check-new-newsgroups 'ask-server)
  (setq gnus-read-active-file 'some)
  ;; dribble
  (setq gnus-use-dribble-file t)
  (setq gnus-always-read-dribble-file t)
  :bind ("C-c m" . gnus))

(use-package nnmail
  :config
  (setq nnmail-expiry-wait 30))
#+end_src

**** Gnus agent
:PROPERTIES:
:CUSTOM_ID: h:fccaadbb-ea22-4d1f-ae79-ef1f45f3befa
:END:

The "agent" is a technical term described in the Gnus manual which
basically represents the bridge between our Gnus and the server to which
it connects to.  Gnus is said to be "plugged" when a connection is
established.  Else it is "unplugged".

Technicalities aside, we can use the agent to configure the handling of
messages.  For example, we can set an expiry date, after which the
message is deleted, or we can create a queue of outgoing messages when
Gnus is in an unplugged state.

#+begin_src emacs-lisp
(use-package gnus-agent
  :after gnus
  :config
  (setq gnus-agent-article-alist-save-format 1)  ; uncompressed
  (setq gnus-agent-cache t)
  (setq gnus-agent-confirmation-function 'y-or-n-p)
  (setq gnus-agent-consider-all-articles nil)
  (setq gnus-agent-directory "~/News/agent/")
  (setq gnus-agent-enable-expiration 'ENABLE)
  (setq gnus-agent-expire-all nil)
  (setq gnus-agent-expire-days 30)
  (setq gnus-agent-mark-unread-after-downloaded t)
  (setq gnus-agent-queue-mail t)        ; queue if unplugged
  (setq gnus-agent-synchronize-flags nil))
#+end_src

**** Gnus article (message view)
:PROPERTIES:
:CUSTOM_ID: h:81c48313-97a3-49bb-af2b-a273db31c331
:END:

In Gnus parlance, the "article" is the window that contains the content
of the summary's selected item.  This has its own major mode, which is
great for us: we can define behaviours and key bindings that only apply
when the article is in focus.

I have no particular interest in the HTML-related variables, because I
practically never have to read such messages.  As a general rule, email
that can only be read in HTML is likely spam or annoying enough to be
treated as such.

With regard to images, I prefer to inhibit any inline items.  If I need
to see it, I can always call =gnus-article-show-images=.

Note that =gnus-article-sort-functions= requires the most important
function to be declared last.

With regard to the key bindings, I have redefined some of the existing
ones to suit my workflow and better match my intuitions.  For example,
in the Article view, hitting =s= takes you to the Summary buffer.  I find
that to be a waste, since we can already move between buffers with
standard keys.  Instead, the =s= can be used to save the attachment at
point.  Similarly, I want =o= to behave just like in =dired=, where it opens
the attachment at point (MIME part) in another buffer.

Finally, here is a tip that I do not configure as I always prefer a
manual check: when you receive someone's public PGP key, you can mark it
and =epa-import-keys-region= (though I should probably write a function
for this task).

#+begin_src emacs-lisp
(use-package gnus-art
  :after gnus
  :demand
  :config
  (setq gnus-article-browse-delete-temp 'ask)
  (setq gnus-article-over-scroll nil)
  (setq gnus-article-show-cursor t)
  (setq gnus-article-sort-functions
        '((not gnus-article-sort-by-number)
          (not gnus-article-sort-by-date)))
  (setq gnus-article-truncate-lines nil)
  (setq gnus-html-frame-width 80)
  (setq gnus-html-image-automatic-caching t)
  (setq gnus-inhibit-images t)
  (setq gnus-max-image-proportion 0.7)
  (setq gnus-treat-display-smileys nil)
  (setq gnus-article-mode-line-format "%G %S %m")
  (setq gnus-visible-headers
        '("^From:" "^To:" "^Cc:" "^Subject:" "^Newsgroups:" "^Date:"
          "Followup-To:" "Reply-To:" "^Organization:" "^X-Newsreader:"
          "^X-Mailer:"))
  (setq gnus-sorted-header-list gnus-visible-headers)
  :hook (gnus-article-mode-hook . (lambda ()
                                    (setq-local fill-column 80)))
  :bind (:map gnus-article-mode-map
              ("i" . gnus-article-show-images)
              ("s" . gnus-mime-save-part)
              ("o" . gnus-mime-copy-part)))
#+end_src

**** Gnus asynchronous operations
:PROPERTIES:
:CUSTOM_ID: h:169083d7-881f-486a-be04-1ebbf2a7edd5
:END:

By default, Gnus performs all its actions in a synchronous fashion.
This means that Emacs is blocked until Gnus has finished.  By enabling
this library, we can use certain functions in a non-blocking way.  I do
this for [[#h:2d793cf8-83f5-4830-b73d-78385d9b96dd][sending email]].

#+begin_src emacs-lisp
(use-package gnus-async
  :after gnus
  :config
  (setq gnus-asynchronous t)
  (setq gnus-use-article-prefetch 15))
#+end_src

**** Gnus group (main interface)
:PROPERTIES:
:CUSTOM_ID: h:d198d238-66c8-42b6-81a3-c0819177c8c2
:END:

I already outlined the utility of the group buffer in the introductory
section on [[#h:14cf6fea-54eb-4faa-bb16-3739485c929a][Gnus for reading email, mailing lists, and more]].  In short,
it is the epicentre of Gnus, where all your subscribed groups are
presented and from where you can browse through your updates.

I use groups in tandem with topics, which allows me to quickly follow
updates on the theme I am interested in at the moment.  It also allows
me to perform per-topic actions, such as updating only the groups it
contains or "catching up" to them (marking them as read).

I choose to disable the default behaviour of always showing a group that
has "ticked" items (the equivalent of starred or marked as important).

Note that =gnus-group-sort-functions= requires the most important function
to be declared last.

#+begin_src emacs-lisp
(use-package gnus-group
  :after gnus
  :demand
  :config
  (setq gnus-level-subscribed 6)
  (setq gnus-level-unsubscribed 7)
  (setq gnus-level-zombie 8)
  (setq gnus-activate-level 2)
  (setq gnus-list-groups-with-ticked-articles nil)
  (setq gnus-group-sort-function
        '((gnus-group-sort-by-unread)
          (gnus-group-sort-by-alphabet)
          (gnus-group-sort-by-rank)))
  (setq gnus-group-line-format "%M%p%P%5y:%B%(%g%)\n")
  (setq gnus-group-mode-line-format "%%b")
  :hook ((gnus-group-mode-hook . hl-line-mode)
         (gnus-select-group-hook . gnus-group-set-timestamp))
  :bind (:map gnus-group-mode-map
              ("M-n" . gnus-topic-goto-next-topic)
              ("M-p" . gnus-topic-goto-previous-topic)))

(use-package gnus-topic
  :after (gnus gnus-group)
  :config
  (setq gnus-topic-display-empty-topics nil)
  :hook (gnus-group-mode-hook . gnus-topic-mode))
#+end_src

**** Gnus summary
:PROPERTIES:
:CUSTOM_ID: h:65c5eefc-a92e-41d3-a0ec-ce48dc61f1af
:END:

This section assumes you have already read my introductory remarks on
[[#h:14cf6fea-54eb-4faa-bb16-3739485c929a][Gnus for reading email, mailing lists, and more]].

Note that the various sort functions expect the primary filter method to
be declared last, in case more that one function is to be invoked.  The
sorting is set to reverse chronological order (newest first).

Threads should not be hidden, while messages whose root has been removed
should be grouped together in some meaningful way (which may not always
be fully accurate).  Furthermore, when moving up or down in the list of
messages using just =n= or =p=, I want to go to the next message, regardless
of whether it has been read or not.  I can otherwise rely on standard
Emacs motions.

The =gnus-user-date-format-alist= basically adapts the date to whether the
message was within the day or the one before, else falls back to a
default ISO-style value.  It is then called with =%&user-date;=.

Also notice the standard behaviour of the =%f= specifier that is used in
the =gnus-summary-line-format=.  It has a conditional behaviour, where it
will show the contents of the "From" header field, unless these match
some exception, defined in =gnus-ignored-from-addresses=.  When the
exception is met, the specifier will fetch the contents of the "To"
field instead, prepending to them =gnus-summary-to-prefix= and/or
=gnus-summary-newsgroup-prefix= (I have no use for the latter).  This is
useful when viewing a summary buffer with, say, all your sent messages.

#+begin_src emacs-lisp
(use-package gnus-sum
  :after (gnus gnus-group)
  :demand
  :config
  (setq gnus-auto-select-first nil)
  (setq gnus-summary-ignore-duplicates t)
  (setq gnus-suppress-duplicates t)
  (setq gnus-save-duplicate-list t)
  (setq gnus-summary-goto-unread nil)
  (setq gnus-summary-make-false-root 'adopt)
  (setq gnus-summary-thread-gathering-function
        'gnus-gather-threads-by-subject)
  (setq gnus-summary-gather-subject-limit 'fuzzy)
  (setq gnus-thread-sort-functions
        '((not gnus-thread-sort-by-date)
          (not gnus-thread-sort-by-number)))
  (setq gnus-subthread-sort-functions
        'gnus-thread-sort-by-date)
  (setq gnus-thread-hide-subtree nil)
  (setq gnus-thread-ignore-subject nil)
  (setq gnus-user-date-format-alist
        '(((gnus-seconds-today) . "Today at %R")
          ((+ (* 60 60 24) (gnus-seconds-today)) . "Yesterday, %R")
          (t . "%Y-%m-%d %R")))

  ;; When the %f specifier in `gnus-summary-line-format' matches my
  ;; name, this will use the contents of the "To:" field, prefixed by
  ;; the string I specify.  Useful when checking your "Sent" summary or
  ;; a mailing list you participate in.
  (setq gnus-ignored-from-addresses "Protesilaos Stavrou")
  (setq gnus-summary-to-prefix "To: ")

  (setq gnus-summary-line-format "%U%R %-18,18&user-date; %4L:%-25,25f %B%s\n")
  (setq gnus-summary-mode-line-format "[%U] %p")
  (setq gnus-sum-thread-tree-false-root "")
  (setq gnus-sum-thread-tree-indent " ")
  (setq gnus-sum-thread-tree-single-indent "")
  (setq gnus-sum-thread-tree-leaf-with-other "+-> ")
  (setq gnus-sum-thread-tree-root "")
  (setq gnus-sum-thread-tree-single-leaf "\\-> ")
  (setq gnus-sum-thread-tree-vertical "|")

  (defun prot/gnus-summary-save-parts-all ()
    "Save relevant message MIME parts to a desired directory.
EXPERIMENTAL"
    (interactive)
    (let ((dir "~/Downloads/mail-attachments"))
      (if major-mode 'gnus-summary-mode
        (progn
          (unless (file-directory-p dir)
            (make-directory dir))
          (gnus-summary-save-parts "text/.*" dir nil t))
        (user-error "Not in a `gnus' summary buffer"))))

  :hook (gnus-summary-mode-hook . hl-line-mode)
  :bind (:map gnus-summary-mode-map
              ("X x" . prot/gnus-summary-save-parts-all)
              ("<delete>" . gnus-summary-delete-article)
              ("n" . gnus-summary-next-article)
              ("p" . gnus-summary-prev-article)
              ("N" . gnus-summary-next-unread-article)
              ("P" . gnus-summary-prev-unread-article)
              ("M-n" . gnus-summary-next-thread)
              ("M-p" . gnus-summary-prev-thread)
              ("C-M-n" . gnus-summary-next-group)
              ("C-M-p" . gnus-summary-prev-group)
              ("C-M-^" . gnus-summary-refer-thread)))
#+end_src

**** Gnus server
:PROPERTIES:
:CUSTOM_ID: h:7760e881-fd54-43cc-ae5f-2728384d2107
:END:

The "server" is where your news sources are listed and from where you
can browse items you would like to subscribe to (e.g. your email
account's Inbox or some mailing list on Usenet).  Make sure to read
about these concepts in the introductory [[#h:14cf6fea-54eb-4faa-bb16-3739485c929a][section about Gnus]].

#+begin_src emacs-lisp
(use-package gnus-srvr
  :after gnus
  :hook ((gnus-browse-mode-hook gnus-server-mode-hook) . hl-line-mode))
#+end_src

**** Gnus window layout
:PROPERTIES:
:CUSTOM_ID: h:b1f4d418-6705-440b-a6f4-89fdd5feef3b
:END:

/NOTE 2020-06-15: I am putting this here for visibility, but I do not
care about intricate Gnus layouts./

The following is adapted from the example in the official manual.  To
read the chapter, evaluate =(info "(gnus) Window Layout")= (either do it
with =C-x C-e= after the closing parenthesis or place this expression in
the prompt of =M-:=).  I tried it for a while: it works, but I do not care
about looking at a sidebar of groups I am subscribed to.  To move
between groups while in the Summary view, I do =C-M-{n,p}= (see the
keybindings in [[#h:65c5eefc-a92e-41d3-a0ec-ce48dc61f1af][the Gnus summary section]]).  If I do not need to switch
summary views in a linear fashion, I just revisit the Group buffer and
proceed from there to find the group I am interested in.

#+begin_example emacs-lisp
(use-package gnus-win
  :config
  (gnus-add-configuration
   '(article
     (horizontal 1.0
                 (vertical 40 (group 1.0))
                 (vertical 1.0
                           (summary 0.16 point)
                           (article 1.0)))))

  (gnus-add-configuration
   '(summary
     (horizontal 1.0
                 (vertical 40 (group 1.0))
                 (vertical 1.0 (summary 1.0 point))))))
#+end_example

**** Gnus intersection with Dired
:PROPERTIES:
:CUSTOM_ID: h:0fabe523-725e-41eb-9e8b-061d74dc7bda
:END:

We can use the built-in directory editor (file manager) as a more
convenient way of performing certain tasks that relate to emails, such
as attaching all the marked items of the =dired= buffer to an email we are
currently composing or wish to initiate the composition of.

Run =C-h m= inside of a Dired buffer that has =gnus-dired-mode= enabled and
search for "gnus" to see all the relevant key bindings and the functions
they call.  I only ever use =C-c C-m C-a= (=C-m= is the same as =RET=).

By the way, make sure to check my [[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][comprehensive Dired configurations]].

#+begin_src emacs-lisp
(use-package gnus-dired
  :after (gnus dired)
  :hook (dired-mode-hook . gnus-dired-mode))
#+end_src

*** Mu4e (email client for the `mu' mail indexer)
:PROPERTIES:
:CUSTOM_ID: h:2a93d8bf-200a-4d23-9be3-276a907947e1
:END:

As outlined in the opening remarks to [[#h:5ad80664-3163-4d9d-be65-462637d77903][Email settings]], I use both Gnus
and Mu4e.  The former is my primary tool for handling email and mailing
lists.  While the latter is kept around for its superior search
capabilities, in those cases where I really need to have a carefully
considered filtered output of my messages.

Put differently, I use mu4e because Gnus' =nnir= backend does not work as
expected with my multi-email-account maildir setup: if anyone has a
maildir with multiple subdirectories that can be queried with =notmuch=
from inside of Gnus, then please contact me.

My particular setup aside, mu4e is a superb tool.  Its interface is
clean.  It comes with well-considered defaults.  The best part though,
is that it offers a front-end to the =mu= command line tool for email
indexing and searching.

Further notes:

+ The following code is a work-in-progress, though it already works the
  way I want.

+ Run =M-x man RET mu-query= to understand how to construct a search
  command.

+ The =prot-common-auth-get-field= is defined in [[#h:c82dcbfa-97d0-4f7c-85af-768ce90f1372][prot-common.el]].

#+begin_src emacs-lisp
(use-package mu4e
  ;; This is an exception because I install it from the Arch Linux
  ;; package archives (depends on non-Emacs code)
  :load-path "/usr/share/emacs/site-lisp/"
  :config
  ;; (setq mail-user-agent 'mu4e-user-agent)
  (setq mu4e-use-fancy-chars nil)
  (setq mu4e-headers-advance-after-mark t)
  (setq mu4e-headers-auto-update t)
  (setq mu4e-headers-date-format "%F")
  (setq mu4e-headers-time-format "%R")
  (setq mu4e-headers-long-date-format "%F, %R")

  (setq mu4e-headers-fields
        '((:human-date . 12)
          (:flags . 6)
          (:mailing-list . 10)
          (:from . 22)
          (:subject)))

  (setq mu4e-get-mail-command "true")
  (setq mu4e-hide-index-messages t)
  (setq mu4e-update-interval (* 60 5))
  (setq mu4e-completing-read-function 'completing-read)
  (setq mu4e-compose-signature "Protesilaos Stavrou\nprotesilaos.com\n")
  (setq mu4e-compose-signature-auto-include t)
  (setq mu4e-maildir "~/.mail")
  (setq mu4e-attachment-dir "~/Downloads")
  (setq mu4e-sent-messages-behavior 'sent)
  (setq mu4e-view-show-addresses t)
  (setq mu4e-context-policy 'pick-first)
  (setq mu4e-compose-context-policy 'ask)
  (setq mu4e-index-lazy-check t)
  (setq mu4e-change-filenames-when-moving t) ; better for `mbsync'?
  (setq mu4e-modeline-max-width 30)
  (setq mu4e-display-update-status-in-modeline t)
  (setq mu4e-view-show-images nil)
  (setq mu4e-decryption-policy 'ask)

  (setq mu4e-contexts
        `(,(make-mu4e-context
            :name "vrp" ; Is there no way to specify a key for switching?
            :enter-func (lambda () (mu4e-message "Entering PRV"))
            :leave-func (lambda () (mu4e-message "Leaving PRV"))
            :match-func (lambda (msg)
                          (when msg
                            (mu4e-message-contact-field-matches
                             msg :to (prot-common-auth-get-field "prv" :user))))
            :vars `((user-mail-address . ,(prot-common-auth-get-field "prv" :user))))
          ,(make-mu4e-context
            :name "inf"
            :match-func (lambda (msg)
                          (when msg
                            (mu4e-message-contact-field-matches
                             msg :to (prot-common-auth-get-field "inf" :user))))
            :vars `((user-mail-address . ,(prot-common-auth-get-field "inf" :user))))
          ,(make-mu4e-context
            :name "pub"
            :match-func (lambda (msg)
                          (when msg
                            (mu4e-message-contact-field-matches
                             msg :to (prot-common-auth-get-field "pub" :user))))
            :vars `((user-mail-address . ,(prot-common-auth-get-field "pub" :user))))))

  (setq mu4e-bookmarks
        '((:name "Unread messages" :query "g:unread AND NOT g:trashed" :key ?u)
          (:name "Today's messages" :query "d:today..now" :key ?t)
          (:name "Last 7 days" :query "d:7d..now" :key ?w)
          (:name "PRV Unread"
                 :query `,(format "to:%s %s"
                                  (prot-common-auth-get-field "prv" :user)
                                  "AND g:unread AND NOT g:trashed")
                 :key ?v)
          (:name "PRV Inbox"
                 :query `,(format "to:%s"
                                  (prot-common-auth-get-field "prv" :user))
                 :key ?V)
          (:name "INF Unread"
                 :query `,(format "to:%s %s"
                                  (prot-common-auth-get-field "inf" :user)
                                  "AND g:unread AND NOT g:trashed")
                 :key ?i)
          (:name "INF Inbox"
                 :query `,(format "to:%s"
                                  (prot-common-auth-get-field "inf" :user))
                 :key ?I)
          (:name "PUB Unread"
                 :query `,(format "to:%s %s"
                                  (prot-common-auth-get-field "pub" :user)
                                  "AND g:unread AND NOT g:trashed")
                 :key ?p)
          (:name "PUB Inbox"
                 :query `,(format "to:%s"
                                  (prot-common-auth-get-field "pub" :user))
                 :key ?P)))

  :bind (("C-c M" . mu4e)
         :map mu4e-headers-mode-map
         ("!" .  (lambda (&optional arg)
                   (interactive "P")
                   (if arg
                       (mu4e-headers-mark-for-unflag)
                     (mu4e-headers-mark-for-flag))))
         ("r" . mu4e-headers-mark-for-read)
         ("u" . mu4e-headers-mark-for-unread)
         ("M-u" . mu4e-headers-mark-for-unmark)
         ("C-M-u" . mu4e-mark-unmark-all)))
#+end_src

**** mu4e extension for org-capture
:PROPERTIES:
:CUSTOM_ID: h:ab106725-ae5d-4ce2-8160-d2f8c46cb563
:END:

With this little snippet, we allow =org-capture= convert any email into a
note, to-do item or whatever.  The killer feature is that we get a
direct link back to the original email.  This way, we can avoid the
problem of searching through a pile of messages until we find the one we
really need.  Nice!

#+begin_src emacs-lisp
(use-package org-mu4e                   ; no need for `:straight t'
  :after (org mu4e)
  :config
  (setq org-mu4e-link-query-in-headers-mode nil))
#+end_src

***** TODO Review need for org-mu4e
:PROPERTIES:
:CUSTOM_ID: h:1ef79c4a-f91c-4ab3-8104-9cf0c5ee3976
:END:
*** Sending email (SMTP)
:PROPERTIES:
:CUSTOM_ID: h:2d793cf8-83f5-4830-b73d-78385d9b96dd
:END:

These are the base settings for the SMTP functionality.  Passwords and
other critical information are stored in =~/.authinfo.gpg=, as
demonstrated in [[#h:a82766be-daab-4925-b23a-1c5ffd47e599][the base email settings]].  What follows is just a
mirroring of the contents of that file.

With regard to the asynchronous functionality, it is meant to improve
performance by carrying out the relevant tasks in a non-blocking way.

#+begin_src emacs-lisp
(use-package smtpmail
  :init
  (setq smtpmail-default-smtp-server "mail.gandi.net")
  :config
  (setq smtpmail-smtp-server "mail.gandi.net")
  (setq smtpmail-stream-type 'ssl)
  (setq smtpmail-smtp-service 465)
  (setq smtpmail-queue-mail nil))

(use-package smtpmail-async
  :after smtpmail
  :config
  (setq send-mail-function 'async-smtpmail-send-it)
  (setq message-send-mail-function 'async-smtpmail-send-it))
#+end_src

** Elfeed (RSS/Atom feed reader)
:PROPERTIES:
:CUSTOM_ID: h:0cd8ddab-55d1-40df-b3db-1234850792ba
:END:

/NOTE 2020-12-14: Pending major review/.

This is a standalone feed reader by Christopher Wellons that comes with
good defaults and is very well designed overall.  It treats the stream
of updates as a flat list that can be narrowed incrementally using an
efficient tagging system.

In terms of feed format specifications, i.e. Atom vs RSS, things should
just work without any kind of configuration from your side (a huge plus
compared to, say, Gnus' =nnrss= backend that only supports the latter).

Elfeed stores feed sources in a single list that associates a valid URL
to one or more tags.  These are then written to a database.  The Elisp
part users should care about looks like this:

#+begin_example
(setq elfeed-feeds
      '(("https://www.archlinux.org/feeds/news/" linux distro)
        ("https://planet.emacslife.com/atom.xml" emacs community)
        ("https://www.ecb.europa.eu/rss/press.html" economics eu)
        ("http://feed.pippa.io/public/shows/teamhuman" podcast culture)
        ("https://www.youtube.com/feeds/videos.xml?channel_id=UC0uTPqBCFIpZxlz_Lv1tk_g" personal video)
        ("https://protesilaos.com/politics.xml" personal)))
#+end_example

I keep the actual list in a GPG-encrypted file.  Emacs can decrypt and
read those transparently, making it a great way to safely store
sensitive data while still keeping everything perfectly functional.

A good tagging system for your feeds will offer a strong foundation for
catching up with the news.  I generally use 2-3 tags per feed, while I
make sure that conceptually similar items will share at least one tag.
My tags are not particularly sophisticated, though they are not random
either: for example, I have a particular "EU" entry for all
institutions, bodies, agencies, etc. and then I have other more general
ones, such as "politics" and "economics".

The user interface consists of two distinct types of buffers:

1. The =*elfeed-search*= buffer that holds the list with all the news
   items.
2. The individual item entries.

By default, hitting =s= (=elfeed-search-live-filter=) in the search buffer
will place the point inside the minibuffer, where you can then edit the
applicable filters.  The [[https://github.com/skeeto/elfeed][Elfeed README]] offers a detailed explanation of
how to apply such filters.  The ones I use the most:

+ Prepend a =+= to the name of a tag to only show items that include that
  tag.  With =-= show items that do not include it.
+ Type in a regular string with the equals sign in front of it, say
  "=Prot", to show feeds whose name contains it.

Other common cases are regular expressions and date ranges, though I
have found that I never use those.  Probably because the tagging system
is sufficiently powerful for my particular needs.

With regard to the package declaration below, I have lots of functions
that customise the behaviour of Elfeed to better match my expectations.
For example, I do not like the fact that the aforementioned default =s=
command (=elfeed-search-live-filter=) does not provide a completion UI.
So I implement an alternative that allows for multiple choices, as well
as arbitrary input.  In the case of the latter, you may need to "force
insert" the final command that locks in the filter with =C-j=
(=exit-minibuffer=), if Emacs complains that there is no matching input
(has not happened in my case).  I define that key binding in the section
about [[#h:c110e399-3f43-4555-8427-b1afe44c0779][Minibuffer configurations and extras (prot-minibuffer.el)]].

Another function of interest which you will not find herein, is the
integration with my =prot/buffers-major-mode=, which I bind to =M-s b=
(start from: [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][generic completion for projects and directory trees]]).  You
can use this in an Elfeed entry buffer to get a list of all entries you
have opened.  Calling that command with =C-u= (prefix argument) will put
the list in an =ibuffer= view.  From there you can, for instance, delete
them in bulk.

The MPV-related functions require the external =mpv= program.  They will
play a video in a new app window at a resolution that matches the
current setup's display width or, in the case of an enclosure
(presumably a podcast), play just the audio file without popping up a
new app window.  The process runs in a dedicated buffer, so it can be
terminated by killing the buffer.  In the future I might make this
cleaner, so that it understands input from, e.g., =playerctl=, though it
is not a priority as the current simplistic design is "good enough" for
my case.

The placement of the MPV buffer is controlled by =display-buffer-alist=
(see [[#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][Window rules and basic tweaks]]).

For a demonstration of what I have here, watch [[https://protesilaos.com/codelog/2020-06-09-emacs-elfeed-demo/][my Elfeed video]]
(2020-06-09).

As I also am a user of Bongo (see [[#h:758afe0d-bc7c-4afc-9c6b-b5e569901591][Bongo (music or media manager)]]), there
are a few functions here that are meant to make the Elfeed search buffer
a bongo-aware library, from where we can enqueue online multimedia
sources (videos, podcasts).

The key part here is to not interfere with the main Bongo playlist and
library, which are dedicated to my local music collection, but to
maintain a separate playlist which can be controlled independently.

The placement of the =*Bongo-Elfeed Queue*= buffer is controlled by the
=display-buffer-alist= (see [[#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][Window rules and basic tweaks]]).

I benefited in this particular workflow from an email exchange with
Madhavan Krishnan: we shared code and ideas that helped establish the
modalities of interaction between Elfeed and Bongo (this information is
made public with permission).

Demo: [[https://protesilaos.com/codelog/2020-09-11-emacs-elfeed-bongo/][Manage podcasts in Emacs with Elfeed and Bongo]] (2020-09-11).

Also see: [[#h:aa64c61e-49b5-41b0-b1fe-10bbe3be661f][Sample configuration for MPV (Elfeed+Bongo extension)]].

#+begin_src emacs-lisp
(use-package elfeed
  :straight t
  :config
  (setq elfeed-use-curl t)
  (setq elfeed-curl-max-connections 10)
  (setq elfeed-db-directory "~/.emacs.d/elfeed/")
  (setq elfeed-enclosure-default-dir "~/Downloads/")
  (setq elfeed-search-filter "@4-months-ago +unread")
  (setq elfeed-sort-order 'descending)
  (setq elfeed-search-clipboard-type 'CLIPBOARD)
  (setq elfeed-search-title-max-width 100)
  (setq elfeed-search-title-min-width 30)
  (setq elfeed-search-trailing-width 25)
  (setq elfeed-show-truncate-long-urls t)
  (setq elfeed-show-unique-buffers t)
  (setq elfeed-search-date-format '("%F %R" 16 :left))

;;; Elfeed general purpose commands

  (defun prot/elfeed-feeds ()
    "Load file containing the `elfeed-feeds' list.
Add this to `elfeed-search-mode-hook'."
    (let ((feeds "~/.emacs.d/feeds.el.gpg"))
      (if (file-exists-p feeds)
          (load-file feeds)
        (user-error "Missing feeds' file"))))

  (defun prot/elfeed-show-eww (&optional link)
    "Browse current `elfeed' entry link in `eww'.
Only show the readable part once the website loads.  This can
fail on poorly-designed websites."
    (interactive)
    (let* ((entry (if (eq major-mode 'elfeed-show-mode)
                      elfeed-show-entry
                    (elfeed-search-selected :ignore-region)))
           (link (or link (elfeed-entry-link entry))))
      (eww link)
      (add-hook 'eww-after-render-hook 'eww-readable nil t)))

  (defun prot/elfeed-search-other-window (&optional arg)
    "Browse `elfeed' entry in the other window.
With \\[universal-argument] browse the entry in `eww' using the
`prot/elfeed-show-eww' wrapper."
    (interactive "P")
    (let* ((entry (if (eq major-mode 'elfeed-show-mode)
                      elfeed-show-entry
                    (elfeed-search-selected :ignore-region)))
           (link (elfeed-entry-link entry))
           (win (selected-window)))
      (with-current-buffer (get-buffer "*elfeed-search*")
        (unless (one-window-p)              ; experimental
          (delete-other-windows win))
        (split-window win (/ (frame-height) 5) 'below)
        (other-window 1)
        (if arg
            (progn
              (when (eq major-mode 'elfeed-search-mode)
                (elfeed-search-untag-all-unread))
              (prot/elfeed-show-eww link))
          (elfeed-search-show-entry entry)))))

  (defun prot/elfeed-kill-buffer-close-window-dwim ()
    "Do-what-I-mean way to handle `elfeed' windows and buffers.

When in an entry buffer, kill the buffer and return to the Elfeed
Search view.  If the entry is in its own window, delete it as
well.

When in the search view, close all other windows.  Else just kill
the buffer."
    (interactive)
    (let ((win (selected-window)))
      (cond ((eq major-mode 'elfeed-show-mode)
             (elfeed-kill-buffer)
             (unless (one-window-p) (delete-window win))
             (switch-to-buffer "*elfeed-search*"))
            ((eq major-mode 'elfeed-search-mode)
             (if (one-window-p)
                 (elfeed-search-quit-window)
               (delete-other-windows win))))))

;;; Elfeed multimedia extras

  (defvar prot/elfeed-mpv-hook nil
    "Hook called before `prot/elfeed-mpv-dwim'.")

  (defun prot/elfeed-mpv-buffer ()
    "Prepare \"*elfeed-mpv-output*\" buffer.
For use by `prot/elfeed-mpv-dwim'.  To be called from
`prot/elfeed-mpv-hook'."
    (let ((buf (get-buffer "*elfeed-mpv-output*"))
          (inhibit-read-only t))
      (with-current-buffer buf
        (erase-buffer))))

  (defun prot/elfeed-mpv-dwim ()
    "Play entry link with external `mpv' program.
When there is an audio enclosure (podcast), play just the audio.
Else spawn a video player at a resolution that accounts for the
current monitor's width."
    (interactive)
    (let* ((entry (if (eq major-mode 'elfeed-show-mode)
                      elfeed-show-entry
                    (elfeed-search-selected :ignore-region)))
           (link (elfeed-entry-link entry))
           (enclosure (elt (car (elfeed-entry-enclosures entry)) 0)) ; fragile?
           (audio "--no-video")
           ;; Here the display width checks if I am on the laptop
           (height (if (<= (display-pixel-width ) 1366) 720 1080))
           (video                       ; this assumes mpv+youtube-dl
            (format "%s --ytdl-format=bestvideo[height\\<=?%s]+bestaudio/best"
                    "--hwdec=auto-safe" height))
           (buf (pop-to-buffer "*elfeed-mpv-output*")))
      (run-hooks 'prot/elfeed-mpv-hook)
      (if enclosure
          (progn
            (async-shell-command (format "mpv %s %s" audio enclosure) buf)
            (message
             (concat "Launching MPV for "
                     (propertize enclosure 'face 'success))))
        (async-shell-command (format "mpv %s %s" video link) buf)
        (message
         (concat "Launching MPV for "
                 (propertize link 'face 'success))))))

;;; Elfeed and Bongo integration

  (defvar prot/elfeed-bongo-playlist "*Bongo-Elfeed Queue*"
    "Name of the Elfeed+Bongo multimedia playlist.")

  (defun prot/elfeed-bongo-insert-item ()
    "Insert `elfeed' multimedia links in `bongo' playlist buffer.

The playlist buffer has a unique name so that it will never
interfere with the default `bongo-playlist-buffer'."
    (interactive)
    (with-eval-after-load 'bongo
      (let* ((entry (if (eq major-mode 'elfeed-show-mode)
                        elfeed-show-entry
                      (elfeed-search-selected :ignore-region)))
             (link (elfeed-entry-link entry))
             (enclosure (elt (car (elfeed-entry-enclosures entry)) 0))
             (url (or enclosure link))
             (title (elfeed-entry-title entry))
             (bongo-pl prot/elfeed-bongo-playlist)
             (buffer (get-buffer-create bongo-pl)))
        (unless (bongo-playlist-buffer)
          (bongo-playlist-buffer))
        (display-buffer buffer)
        (with-current-buffer buffer
 	      (when (not (bongo-playlist-buffer-p))
 	        (bongo-playlist-mode)
            (setq-local bongo-library-buffer (get-buffer "*elfeed-search*"))
            (setq-local bongo-enabled-backends '(mpv))
            (bongo-progressive-playback-mode))
 	      (goto-char (point-max))
          (bongo-insert-uri url title)
          (bongo-insert-comment-text (format "     ==> %s\n" url))
          (let ((inhibit-read-only t))
            (delete-duplicate-lines (point-min) (point-max)))
          (bongo-recenter))
        (message "Enqueued %s “%s” in %s"
                 (if enclosure "podcast" "video")
                 (propertize title 'face 'italic)
                 (propertize bongo-pl 'face 'bold)))))

  (defun prot/elfeed-bongo-switch-to-playlist ()
    (interactive)
    (let* ((bongo-pl prot/elfeed-bongo-playlist)
           (buffer (get-buffer bongo-pl)))
      (if buffer
          (switch-to-buffer buffer)
        (message "No `bongo' playlist is associated with `elfeed'."))))

;;; Elfeed search extensions

  (defun prot/elfeed-show-search-update (direction)
    "Update `elfeed-search-buffer' to match entry in DIRECTION.

This is useful when Elfeed is split in two windows, with the
search buffer on one side and an entry buffer on the other.  The
user is changing entries while in the latter, while the former
gets updated to put point on the current item.

EXPERIMENTAL."
    (interactive "s")
    (let* ((entry (if (eq major-mode 'elfeed-show-mode)
                      elfeed-show-entry
                    (elfeed-search-selected :ignore-region)))
           (title (elfeed-entry-title entry))
           (es "*elfeed-search*")
           (buf (get-buffer es))
           (win (get-buffer-window buf)))
      (funcall (intern (concat "elfeed-show-"
                               (substring `,direction 0 4))))
      (when (window-live-p win)
        (with-current-buffer buf
          (goto-char (point-min)) ; Elfeed way to find entry window?
          (search-forward (format "%s" title))
          (funcall (intern (concat `,direction "-line")))
          (set-window-point win (point-at-bol))
          (prot-pulse-pulse-line)))))

  (defun prot/elfeed-search-tag-filter ()
    "Filter `elfeed' by tags using completion.

Arbitrary input is also possible, but you may need to exit the
minibuffer with `exit-minibuffer' (I bind it to C-j in
`minibuffer-local-completion-map')."
    (interactive)
    (unwind-protect
        (elfeed-search-clear-filter)
      ;; NOTE for the `crm-separator' to work with just a space, you
      ;; need to make SPC self-insert in the minibuffer (the default is
      ;; to behave like tab-completion).
      (let* ((crm-separator " ")
             (elfeed-search-filter-active :live)
             (db-tags (elfeed-db-get-all-tags))
             (plus-tags (delete-dups
                         (mapcar (lambda (x)
                                   (concat "+" (format "%s" x)))
                                 db-tags)))
             (minus-tags (delete-dups
                          (mapcar (lambda (x)
                                    (concat "-" (format "%s" x)))
                                  db-tags)))
             (all-tags (append plus-tags minus-tags))
             (tags (completing-read-multiple
                    "Apply tag: "
                    all-tags nil t))
             (input (string-join `(,elfeed-search-filter ,@tags) " ")))
        (setq elfeed-search-filter input))
      (elfeed-search-update :force)))

  (defun prot/elfeed-show-archive ()
    "Create an archive copy of the current `elfeed' entry."
    (interactive)
    (let* ((entry (if (eq major-mode 'elfeed-show-mode)
                      elfeed-show-entry
                    (elfeed-search-selected :ignore-region)))
           ;; TODO how to cleanly add hyphens instead of spaces?
           (title (elfeed-entry-title entry))
           (elfeed-show-truncate-long-urls nil)
           (archives "~/Documents/feeds/")
           (file (format "%s%s.txt" archives title)))
      (unless (file-exists-p archives)
        (make-directory archives t))
      (when (derived-mode-p 'elfeed-show-mode)
        ;; Refresh to expand truncated URLs
        (elfeed-show-refresh)
        (write-file file t)
        (message "Saved buffer at %s" file))))

  (defface prot/elfeed-entry-critical
    '((t :inherit (font-lock-builtin-face elfeed-search-title-face)))
    "Face for Elfeed entries tagged 'critical'.")

  (defface prot/elfeed-entry-essential
    '((t :inherit (font-lock-keyword-face elfeed-search-title-face)))
    "Face for Elfeed entries tagged 'essential'.")

  (defface prot/elfeed-entry-important
    '((t :inherit (font-lock-string-face elfeed-search-title-face)))
    "Face for Elfeed entries tagged 'important'.")

  (defface prot/elfeed-entry-personal
    '((t :inherit (font-lock-warning-face elfeed-search-title-face)))
    "Face for Elfeed entries tagged 'personal'.")

  (setq elfeed-search-face-alist
        '((critical prot/elfeed-entry-critical)
          (essential prot/elfeed-entry-essential)
          (important prot/elfeed-entry-important)
          (personal prot/elfeed-entry-personal)
          (unread elfeed-search-unread-title-face)))

  (defvar prot/elfeed-search-tags
    '(critical essential important)
    "List of tags used by `prot/elfeed-toggle-tag'.")

  (defun prot/elfeed-toggle-tag (&optional tag)
    "Toggle tag on current item.

A list of tags is provided by `prot/elfeed-search-tags'.
Otherwise an optional TAG symbol will suffice."
    (interactive)
    (let* ((tags prot/elfeed-search-tags)
           (input (or tag (intern (completing-read "Set tag: " tags nil t)))))
      (elfeed-search-toggle-all input)))

;;; Hooks and key bindings

  :hook ((elfeed-search-mode-hook . prot/elfeed-feeds)
         (prot/elfeed-mpv-hook . prot/elfeed-mpv-buffer))
  :bind (("C-c e" . elfeed)
         :map elfeed-search-mode-map
         ("s" . prot/elfeed-search-tag-filter)
         ("w" . elfeed-search-yank)
         ("g" . elfeed-update)
         ("G" . elfeed-search-update--force)
         ("o" . prot/elfeed-search-other-window)
         ("v" . prot/elfeed-mpv-dwim)
         ("q" . prot/elfeed-kill-buffer-close-window-dwim)
         ("!" . (lambda ()
                  (interactive)
                  (prot/elfeed-toggle-tag 'important)))
         ("+" . prot/elfeed-toggle-tag)
         ("b" . prot/elfeed-bongo-insert-item)
         ("h" . prot/elfeed-bongo-switch-to-playlist) ; "hop" mnemonic
         :map elfeed-show-mode-map
         ("a" . prot/elfeed-show-archive)
         ("b" . prot/elfeed-bongo-insert-item)
         ("n" . (lambda ()
                  (interactive)
                  (prot/elfeed-show-search-update "next")))
         ("p" . (lambda ()
                  (interactive)
                  (prot/elfeed-show-search-update "previous")))
         ("e" . prot/elfeed-show-eww)
         ("q" . prot/elfeed-kill-buffer-close-window-dwim)
         ("v" . prot/elfeed-mpv-dwim)
         ("w" . elfeed-show-yank)))
#+end_src

*** Sample configuration for MPV (Elfeed+Bongo extension)
:PROPERTIES:
:CUSTOM_ID: h:aa64c61e-49b5-41b0-b1fe-10bbe3be661f
:END:

In the previous section I configure Elfeed to integrate with the Bongo
media manager.  The external =mpv= executable is used to play back audio
and video links.  Instead of passing command-line arguments to control
the settings of the player, I just add the following to my local
configuration files, specifically =~/.config/mpv/mpv.conf=:

#+begin_example conf
hwdec=auto-safe
ytdl-format="bestvideo[height<=?1080]+bestaudio/best"
#+end_example

** Bongo (music or media manager)
:PROPERTIES:
:CUSTOM_ID: h:758afe0d-bc7c-4afc-9c6b-b5e569901591
:END:

/NOTE 2020-12-14: Pending major review/.

Bongo is a buffer oriented media manager.  It provides an interface to
external media players, such as VLC or MPV.  Those are known as
"back-ends".  A "library" buffer contains the media collection, which
consists of music or video files, or even links to online streams.  A
"playlist" buffer holds the items that wait in the queue to be played by
the back-end program.

I use Bongo for my local Music collection.  My directories are, in
principle, organised following the pattern =Artist/Album/Tracks=.  Each
track is named in the style of =Artist - Album - Title=.  As part of this
collection comes from physical discs, I never bothered writing metadata
for all them and, consequently, I do not rely on it to play back my
files.  The directory structure and its concomitant naming conventions
are sufficient.  Besides, reading metadata requires more than just
looking at a plain text name: it is opaque.  As such, I never bothered
trying to make Bongo handle metadata the way, say, the Music Player
Daemon does (external program).

My approach to listening to music is straightforward: load up a
directory or directory tree, randomise the playback order, and let it
play in the background.  To ease this workflow, I make my =~/Music=
directory a valid Bongo library.  I can access it with =dired=, while
still benefiting from the Bongo-specific extras (see the macro
=prot/bongo-dired-library= and its derived functions).

Two main uses of the Dired+Bongo combination:

1. Mark some directories or files the way you always do with Dired, hit
   a key that will (i) enqueue those to the playlist buffer, (ii)
   perform the randomisation where appropriate, (iii) mark this inserted
   group by bespoke section delimiters for easier future retrieval, and
   (iv) start playing an item unless one is already active (see
   =prot/bongo-dired-insert-files=).

2. Add the absolute filesystem path of marked items (typically
   directories) to either an existing /playlist file/ or a new one that is
   created on demand (check =prot/bongo-dired-make-playlist-file=).  These
   files can be inserted in a Bongo /playlist buffer/ to start playing
   music right away, following the same conditional patterns of
   behaviour described in the previous point (see, in particular,
   =prot/bongo-playlist-insert-playlist-file=).

Let us press on with the logic of =prot/bongo-dired-insert-files=: it will
start playing immediately if the playlist buffer is empty, but will not
do so if the buffer already plays back some track.  It therefore is
trivial to keep adding items to the queue.  The "section delimiters"
(=prot/bongo-playlist-section=) it inserts, set up the playlist buffer in
a way that is easier to navigate (e.g. =prot/bongo-paylist-section-next=)
and to edit blocks in the queue.

These custom sections separate batches of inserted media.  They follow
my approach of picking an ad-hoc collection of related items that match
a certain theme.  I want to treat them as an indivisible unit for the
purposes of adding or removing sets from the playlist buffer.  With
point within a section, call =prot/bongo-playlist-kill-section= to remove
it from the playlist, then optionally follow it up with a new set you
wish to insert, using the aforementioned techniques.

Concerning the customisations below, these can be summarised thus:

+ Hide all icons that can be easily hidden.
+ No mode line indicators.  Same for the header line.
+ Add visual indicators for played tracks and the progress on the
  current one (by the way, [[#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6][my Modus themes]] are designed to enhance this
  experience).
+ Do not ask for confirmation upon inserting a directory tree.
+ The =bongo-join-inserted-tracks= defaults to adding inline headers when
  multiple items share name components.  I dislike that because
  sometimes I mix songs from various places and only some subsets are
  named appropriately to fully benefit from this.  Basically, the
  results do not look consistent.  Also, I have no use for foldable
  headings of this sort.

Watch [[https://protesilaos.com/codelog/2020-08-06-emacs-bongo-extras/][Bongo media manager and my extras]] (2020-08-06) for a demonstration
of the aforementioned.

Since then I have added an extra feature to automatically re-centre the
playlist buffer whenever a track changes.  This is useful when I am not
working on the computer (e.g. cooking) but choose to keep music playing
in the background with the playlist's window in focus: it saves me from
the trouble of having to manually find the name of the currently playing
track.  For more on the implementation front, refer to the
=prot/bongo-playlist-change-track-hook= and its accompaniments.

The =contrib/bongo-playlist-no-banner= advice, which hides the commentary
banner from the standard Bongo playlist buffer, is copied with a minor
rewording from the [[https://github.com/Koekelas/dotfiles/blob/master/emacs.org][Emacs configuration file of Nicolas De Jaeghere]].

The =define-bongo-backend mpv= you see in this section is meant to
facilitate the integration with Elfeed, where we want to maintain a
distinct playlist+library for tracking online multimedia sources (videos
and podcasts).  See [[#h:0cd8ddab-55d1-40df-b3db-1234850792ba][Elfeed (RSS/Atom feed reader)]] for the implementation
details.  Madhavan Krishnan helped me flesh out this project by sharing
code and ideas in a private exchange (shared with permission).

Watch: [[https://protesilaos.com/codelog/2020-09-11-emacs-elfeed-bongo/][Manage podcasts in Emacs with Elfeed and Bongo]] (2020-09-11).

#+begin_src emacs-lisp
(use-package bongo
  :straight t
  :config
  (setq bongo-default-directory "~/Music")
  (setq bongo-prefer-library-buffers nil)
  (setq bongo-insert-whole-directory-trees t)
  (setq bongo-logo nil)
  (setq bongo-display-track-icons nil)
  (setq bongo-display-track-lengths nil)
  (setq bongo-display-header-icons nil)
  (setq bongo-display-playback-mode-indicator t)
  (setq bongo-display-inline-playback-progress nil) ; t slows down the playlist buffer
  (setq bongo-join-inserted-tracks nil)
  (setq bongo-field-separator (propertize " · " 'face 'shadow))
  (setq bongo-mark-played-tracks t)
  (setq bongo-header-line-mode nil)
  (setq bongo-mode-line-indicator-mode nil)
  (setq bongo-enabled-backends '(vlc mpv))
  (setq bongo-vlc-program-name "cvlc")

;;; Bongo playlist buffer
;;;; Generic playlist extras
  ;; Hide the playlist's banner
  (define-advice bongo-default-playlist-buffer
      (:override () contrib/bongo-playlist-no-banner)
    (with-current-buffer (get-buffer-create bongo-default-playlist-buffer-name)
      (unless (derived-mode-p 'bongo-playlist-mode)
        (bongo-playlist-mode))
      (current-buffer)))

;;;; Bongo playlist sections
  (defvar prot/bongo-playlist-section-delimiter
    "\n******************************\n\n"
    "Delimiter for inserted groups in `bongo' playlist buffers.")

  (defconst prot/bongo-playlist-heading-delimiter "§"
    "Delimiter for custom headings in `bongo' playlist buffers.")

  (defun prot/bongo-playlist-heading (title &optional description)
    "Insert `bongo' comment with TITLE and DESCRIPTION.
Use this to add a custom heading for the enqueued media items."
    (bongo-insert-comment-text
     (format "%s %s%s\n" prot/bongo-playlist-heading-delimiter
             title (if description (concat " " description) ""))))

  (defun prot/bongo-playlist-section ()
    (bongo-insert-comment-text
     prot/bongo-playlist-section-delimiter))

  ;; NOTE: there probably is a better way to parametrise move-buf and
  ;; move-point so that one key checks for appropriate forward or
  ;; backward motions, but this is okay right now.
  (defmacro prot/bongo-playlist-motion (fn desc rx move-buf move-point)
    "Produce interactive commands to navigate custom bongo delimiters.

FN is the resulting interactive function's name.  DESC is its doc
string.  RX is the regular expression that matches the custom
bongo playlist delimiter (see `prot/bongo-playlist-delimiter' and
`prot/bongo-playlist-heading').

MOVE-BUF is a motion across an arbitrary number of lines.
Currently it assumes (though does test) either
`re-search-forward' or `re-search-backward'.  Likewise,
MOVE-POINT expects `point-at-eol' or `point-at-bol'.  These
motions should go in pairs, in the order they are presented here."
    `(defun ,fn ()
       ,desc
       (interactive)
       (let ((section ,rx))
         (when (save-excursion (funcall ,move-buf section nil t))
           (goto-char (funcall ,move-point))
           (funcall ,move-buf section nil t)))))

  (prot/bongo-playlist-motion
   prot/bongo-playlist-heading-next
   "Move to next `bongo' playlist custom heading."
   "^.*§.*$"
   're-search-forward
   'point-at-eol)

  (prot/bongo-playlist-motion
   prot/bongo-playlist-heading-previous
   "Move to previous `bongo' playlist custom heading."
   "^.*§.*$"
   're-search-backward
   'point-at-bol)

  (prot/bongo-playlist-motion
   prot/bongo-playlist-section-next
   "Move to next `bongo' playlist custom section delimiter."
   "^\\*+$"
   're-search-forward
   'point-at-eol)

  (prot/bongo-playlist-motion
   prot/bongo-playlist-section-previous
   "Move to previous `bongo' playlist custom section delimiter."
   "^\\*+$"
   're-search-backward
   'point-at-bol)

  (defun prot/bongo-playlist-mark-section ()
    "Mark `bongo' playlist section, delimited by custom markers.
The marker is `prot/bongo-playlist-delimiter'."
    (interactive)
    (let ((section "^\\*+$"))
      (search-forward-regexp section nil t)
      (push-mark nil t)
      (forward-line -1)
      ;; REVIEW any predicate to replace this `save-excursion'?
      (if (save-excursion (re-search-backward section nil t))
          (progn
            (search-backward-regexp section nil t)
            (forward-line 1))
        (goto-char (point-min)))
      (activate-mark)))

  (defun prot/bongo-playlist-kill-section ()
    "Kill `bongo' playlist-section at point.
This operates on a custom delimited section of the buffer.  See
`prot/bongo-playlist-kill-section'."
    (interactive)
    (prot/bongo-playlist-mark-section)
    (bongo-kill))

;;;; Bongo playlist imenu setup
  (defvar prot/bongo-playlist-setup-hook nil
    "Hook that runs after inserting items to the `bongo' playlist.
See, for example, `prot/bongo-playlist-insert-playlist-file' or
`prot/bongo-dired-insert-files'.")

  (defun prot/bongo-playlist-imenu-heading ()
    "Return the text of the custom `bongo' playlist heading."
    (interactive)
    (nth 1
         (split-string
          (buffer-substring-no-properties (point-at-bol) (point-at-eol))
          "§ ")))

  (defun prot/bongo-playlist-imenu-setup ()
    "`imenu' bindings for the `bongo' playlist buffer."
    (setq-local imenu-prev-index-position-function
                'prot/bongo-playlist-heading-previous)
    (setq-local imenu-extract-index-name-function
                'prot/bongo-playlist-imenu-heading))

  (add-hook 'prot/bongo-playlist-setup-hook #'prot/bongo-playlist-imenu-setup)

;;;; Bongo playlist custom commands
  (defun prot/bongo-playlist-play-random ()
    "Play random `bongo' track and determine further conditions."
    (interactive)
    (unless (bongo-playlist-buffer)
      (bongo-playlist-buffer))
    (when (or (bongo-playlist-buffer-p)
              (bongo-library-buffer-p))
      (unless (bongo-playing-p)
        (with-current-buffer (bongo-playlist-buffer)
          (bongo-play-random)
          (bongo-random-playback-mode)
          (bongo-recenter)))))

  (defun prot/bongo-playlist-random-toggle ()
    "Toggle `bongo-random-playback-mode' in playlist buffers."
    (interactive)
    (if (eq bongo-next-action 'bongo-play-random-or-stop)
        (bongo-progressive-playback-mode)
      (bongo-random-playback-mode)))

  (defun prot/bongo-playlist-reset ()
    "Stop playback and reset `bongo' playlist marks.
To reset the playlist is to undo the marks produced by non-nil
`bongo-mark-played-tracks'."
    (interactive)
    (when (bongo-playlist-buffer-p)
      (bongo-stop)
      (bongo-reset-playlist)))

  (defun prot/bongo-playlist-terminate ()
    "Stop playback and clear the entire `bongo' playlist buffer.
Contrary to the standard `bongo-erase-buffer', this also removes
the currently playing track."
    (interactive)
    (when (bongo-playlist-buffer-p)
      (bongo-stop)
      (bongo-erase-buffer)))

  (defun prot/bongo-playlist-insert-playlist-file ()
    "Insert contents of playlist file to a `bongo' playlist.
Upon insertion, playback starts immediately, in accordance with
`prot/bongo-play-random'.

The available options at the completion prompt are pre-configured
files that contain absolute filesystem paths of directories or
media items one per line.  Think of them as meta-directories that
mix manually selected media items (yes, I never liked 'smart'
playlists).

To insert multiple playlists complete the first, then type a
space, complete a second, etc.  This assumes that SPC can
self-insert in the minibuffer or you use C-q SPC.

Also see `prot/bongo-dired-make-playlist-file'."
    (interactive)
    (let* ((path "~/Music/playlists/")
           (dotless directory-files-no-dot-files-regexp)
           (playlists (mapcar
                       'abbreviate-file-name
                       (directory-files path nil dotless)))
           (crm-separator " ")          ; Space to separate entries
           (choice
            (if (not (bongo-playlist-buffer-p (current-buffer)))
                (user-error "Not in a `bongo' playlist buffer")
              (completing-read-multiple "Add playlist: " playlists nil t))))
      (mapcar (lambda (x)
                (save-excursion
                  (goto-char (point-max))
                  (prot/bongo-playlist-heading x "playlist file")
                  (bongo-insert-playlist-contents
                   (format "%s%s" path x))
                  (prot/bongo-playlist-section)))
              choice)
      (prot/bongo-playlist-play-random)
      (run-hooks 'prot/bongo-playlist-setup-hook)))

  (defvar prot/bongo-playlist-change-track-hook nil
    "Hook that runs after `bongo' switches to a new track.")

  (defun prot/bongo-playlist-run-hook-change-track (&rest _)
    "Run `prot/bongo-playlist-run-hook-change-track'.
This is meant to be loaded after the relevant `bongo' functions
that change tracks, such as `bongo-play-next-or-stop' and
`bongo-play-random-or-stop'."
    (run-hooks 'prot/bongo-playlist-change-track-hook))

  (dolist (fn '(bongo-play-next-or-stop bongo-play-random-or-stop))
    (advice-add fn :after #'prot/bongo-playlist-run-hook-change-track))

  (defun prot/bongo-playlist-recenter ()
    "Recenter `bongo' playlist buffer while in a live window.
Add to `prot/bongo-playlist-change-track-hook'."
    (with-current-buffer (bongo-playlist-buffer)
      (bongo-recenter)))

;;; Bongo + Dired (bongo library buffer)
  (defmacro prot/bongo-dired-library (name doc val)
    "Create `bongo' library function NAME with DOC and VAL."
    `(defun ,name ()
       ,doc
       (when (string-match-p "\\`~/Music/" default-directory)
         (bongo-dired-library-mode ,val))))

  (prot/bongo-dired-library
   prot/bongo-dired-library-enable
   "Set `bongo-dired-library-mode' when accessing ~/Music.

Add this to `dired-mode-hook'.  Upon activation, the directory
and all its sub-directories become a valid library buffer for
Bongo, from where we can, among others, add tracks to playlists.
The added benefit is that Dired will continue to behave as
normal, making this a superior alternative to a purpose-specific
library buffer.

Note, though, that this will interfere with `wdired-mode'.  See
`prot/bongo-dired-library-disable'."
   1)

  ;; NOTE `prot/bongo-dired-library-enable' does not get reactivated
  ;; upon exiting `wdired-mode'.
  ;;
  ;; TODO reactivate bongo dired library upon wdired exit
  (prot/bongo-dired-library
   prot/bongo-dired-library-disable
   "Disable `bongo-dired-library-mode' when accessing ~/Music.
This should be added `wdired-mode-hook'.  For more, refer to
`prot/bongo-dired-library-enable'."
   -1)

  (defun prot/bongo-dired-insert-files ()
    "Add files in a `dired' buffer to the `bongo' playlist."
    (let ((media (or (dired-get-marked-files) (dired-filename-at-point))))
      (with-current-buffer (bongo-playlist-buffer)
        (goto-char (point-max))
        (mapcar (lambda (x)
                  (if (file-directory-p x)
                      (progn
                        (prot/bongo-playlist-heading (file-name-base x))
                        (bongo-insert-directory-tree x))
                    (bongo-insert-file x)))
                media)
        (prot/bongo-playlist-section)
        (run-hooks 'prot/bongo-playlist-setup-hook))
      (with-current-buffer (bongo-library-buffer)
        (dired-next-line 1))))

  (defun prot/bongo-dired-insert ()
    "Add `dired' item at point or marks to `bongo' playlist.

The playlist is created, if necessary, while some other tweaks
are introduced.  See `prot/bongo-dired-insert-files' as well as
`prot/bongo-playlist-play-random'.

Meant to work while inside a `dired' buffer that doubles as a
library buffer (see `prot/bongo-dired-library')."
    (interactive)
    (when (bongo-library-buffer-p)
      (unless (bongo-playlist-buffer-p)
        (bongo-playlist-buffer))
      (prot/bongo-dired-insert-files)
      (prot/bongo-playlist-play-random)))

  (defun prot/bongo-dired-make-playlist-file ()
    "Add `dired' marked items to playlist file using completion.

These files are meant to reference filesystem paths.  They ease
the task of playing media from closely related directory trees,
without having to interfere with the user's directory
structure (e.g. a playlist file 'rock' can include the paths of
~/Music/Scorpions and ~/Music/Queen).

This works by appending the absolute filesystem path of each item
to the selected playlist file.  If no marks are available, the
item at point will be used instead.

Selecting a non-existent file at the prompt will create a new
entry whose name matches user input.  Depending on the completion
framework, such as with `icomplete-mode', this may require a
forced exit (e.g. \\[exit-minibuffer] to parse the input without
further questions).

Also see `prot/bongo-playlist-insert-playlist-file'."
    (interactive)
    (let* ((dotless directory-files-no-dot-files-regexp)
           (pldir "~/Music/playlists")
           (playlists (mapcar
                       'abbreviate-file-name
                       (directory-files pldir nil dotless)))
           (plname (completing-read "Select playlist: " playlists nil nil))
           (plfile (format "%s/%s" pldir plname))
           (media-paths
            (if (derived-mode-p 'dired-mode)
                ;; TODO more efficient way to do ensure newline ending?
                ;;
                ;; The issue is that we need to have a newline at the
                ;; end of the file, so that when we append again we
                ;; start on an empty line.
                (concat
                 (mapconcat #'identity
                            (dired-get-marked-files)
                            "\n")
                 "\n")
              (user-error "Not in a `dired' buffer"))))
      ;; The following `when' just checks for an empty string.  If we
      ;; wanted to make this more robust we should also check for names
      ;; that contain only spaces and/or invalid characters…  This is
      ;; good enough for me.
      (when (string-empty-p plname)
        (user-error "No playlist file has been specified"))
      (unless (file-directory-p pldir)
        (make-directory pldir))
      (unless (and (file-exists-p plfile)
                   (file-readable-p plfile)
                   (not (file-directory-p plfile)))
        (make-empty-file plfile))
      (append-to-file media-paths nil plfile)
      (with-current-buffer (find-file-noselect plfile)
        (delete-duplicate-lines (point-min) (point-max))
        (sort-lines nil (point-min) (point-max))
        (save-buffer)
        (kill-buffer))))

;;; Bongo + Elfeed integration

  ;; Here we define a slightly tweaked variant of the standard mpv
  ;; backend.  We will be using this to play back audio and video URLs.
  ;; The latter will spawn a new MPV player window.  Refer to my Elfeed
  ;; section for the implementation details.
  (define-bongo-backend mpv
    ;; :constructor 'bongo-start-mpv-player
    :program-name 'mpv
    :extra-program-arguments nil
    :matcher '((local-file "file:" "http:" "ftp:")
               "ogg" "flac" "mp3" "mka" "wav" "wma"
               "mpg" "mpeg" "vob" "avi" "ogm" "mp4" "mkv"
               "mov" "asf" "wmv" "rm" "rmvb" "ts")
    :matcher '(("mms:" "mmst:" "rtp:" "rtsp:" "udp:" "unsv:"
                "dvd:" "vcd:" "tv:" "dvb:" "mf:" "cdda:" "cddb:"
                "cue:" "sdp:" "mpst:" "tivo:") . t)
    :matcher '(("http:" "https:") . t))

;;; Hooks and key bindings

  :hook ((dired-mode-hook . prot/bongo-dired-library-enable)
         (wdired-mode-hook . prot/bongo-dired-library-disable)
         (prot/bongo-playlist-change-track-hook . prot/bongo-playlist-recenter))
  :bind (("C-c b" . bongo)
         ("<C-XF86AudioPlay>" . bongo-pause/resume)
         ("<C-XF86AudioNext>" . bongo-next)
         ("<C-XF86AudioPrev>" . bongo-previous)
         ("<M-XF86AudioPlay>" . bongo-show)
         ("<S-XF86AudioNext>" . bongo-seek-forward-10)
         ("<S-XF86AudioPrev>" . bongo-seek-backward-10)
         :map bongo-playlist-mode-map
         ("n" . bongo-next-object)
         ("p" . bongo-previous-object)
         ("C-c C-n" . prot/bongo-playlist-heading-next)
         ("C-c C-p" . prot/bongo-playlist-heading-previous)
         ("M-n" . prot/bongo-playlist-section-next)
         ("M-p" . prot/bongo-playlist-section-previous)
         ("M-h" . prot/bongo-playlist-mark-section)
         ("M-d" . prot/bongo-playlist-kill-section)
         ("g" . prot/bongo-playlist-reset)
         ("D" . prot/bongo-playlist-terminate)
         ("r" . prot/bongo-playlist-random-toggle)
         ("R" . bongo-rename-line)
         ("j" . bongo-dired-line)       ; Jump to dir of file at point
         ("J" . dired-jump)             ; Jump to library buffer
         ("i" . prot/bongo-playlist-insert-playlist-file)
         ("I" . bongo-insert-special)
         :map bongo-dired-library-mode-map
         ("<C-return>" . prot/bongo-dired-insert)
         ("C-c SPC" . prot/bongo-dired-insert)
         ("C-c +" . prot/bongo-dired-make-playlist-file)))
#+end_src

** Proced (process monitor, similar to `top')
:PROPERTIES:
:CUSTOM_ID: h:6b56ce11-c84c-4b6d-98c7-bc3eefbe9325
:END:

This is a built-in tool that allows you to monitor running processes
and act on them accordingly.  These are the basic settings I have
right now.  Would need to experiment with it a bit more.  It works
fine though.

#+begin_src emacs-lisp
(use-package proced
  :commands proced
  :config
  (setq proced-auto-update-flag t)
  (setq proced-auto-update-interval 1)
  (setq proced-descend t)
  (setq proced-filter 'user))
#+end_src

And with this nimble tool we get live narrowing of the list, based on
the terms of our search.

#+begin_src emacs-lisp
(use-package proced-narrow
  :straight t
  :after proced
  :diminish
  :bind (:map proced-mode-map
              ("/" . proced-narrow)))
#+end_src

** Pass interface (password-store)
:PROPERTIES:
:CUSTOM_ID: h:1d2bf0d0-4806-4e04-a320-7d6538ef2e78
:END:

The external =pass= program, aka "password-store", is a password manager
that uses GPG and standard UNIX tools to handle passwords.  Encrypted
files are stored in a plain directory structure.  Very simple, very
nice: now all data is available with a variety of interfaces, such as
standard CLI, a =dmenu= interface, a graphical front-end like =qtpass=, etc.

The package below provides an Emacs interface to some of the most common
actions, in the form of a list of candidates that can be narrowed down
(such as with =icomplete=).  I use it to quickly store a password to the
kill ring.

#+begin_src emacs-lisp
(use-package password-store
  :straight t
  :commands (password-store-copy
             password-store-edit
             password-store-insert)
  :config
  (setq password-store-time-before-clipboard-restore 30))
#+end_src

And this one adds a major mode for browsing the =pass= keychain.  Call
it with =M-x pass=.  There is a helpful section at the top with key
bindings and their functions.

#+begin_src emacs-lisp
(use-package pass
  :straight t
  :commands pass)
#+end_src

** Emacs Simple HTML Renderer (shr)
:PROPERTIES:
:CUSTOM_ID: h:524bc702-ff55-4ed9-9a38-26d30d64591d
:END:

*NOTE 2020-08-16:* This section is subject to major changes contingent on
the eventual review of =eww= (which is documented in the next section:
[[#h:4523c31a-d638-4ab2-bc2c-4bdeadc2c86b][Emacs Web Wowser (EWW)]]).

As far as I can tell, the following =shr-*= variables concern an HTML
parser that is used by a variety of tools, including Elfeed (defined
right above).  I guess we could scope them by using hooks, but I see no
need for different settings.

What these do:

+ Open links in a new /Emacs/ window, instead of the system's browser.
  This Emacs web browser is called =eww=.
+ Use monospaced fonts, since that is what I want to have everywhere
  in Emacs.
+ Do not preserve colours from websites, as they may be inaccessible
  (see [[#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6][my Modus theme]]).
+ Keep images to 70% of the window.  This number is arbitrary.  It
  just feels like a good upper limit (not a fan of decorative images
  inside of blog posts).
+ Line length at same number of characters as =fill-column= (defined in
  the section about [[#h:c392fef1-17b7-4cc0-b0e2-2b3edd0eed3c][Line length (column count)]] at 72).

#+begin_src emacs-lisp
(use-package shr
  :config
  (setq shr-use-fonts nil)
  (setq shr-use-colors nil)
  (setq shr-max-image-proportion 0.7)
  (setq shr-image-animate nil)
  (setq shr-width (current-fill-column)))
#+end_src

** Emacs Web Wowser (EWW)
:PROPERTIES:
:CUSTOM_ID: h:4523c31a-d638-4ab2-bc2c-4bdeadc2c86b
:END:

#+begin_src emacs-lisp
;; TODO prot-eww.el
(use-package eww
  :config
  (setq eww-restore-desktop nil)
  (setq eww-desktop-remove-duplicates t)
  (setq eww-header-line-format "%u")
  (setq eww-search-prefix "https://duckduckgo.com/html/?q=")
  (setq eww-download-directory "~/Downloads/")
  (setq eww-suggest-uris
        '(eww-links-at-point
          thing-at-point-url-at-point))
  (setq eww-bookmarks-directory "~/.emacs.d/eww-bookmarks/")
  (setq eww-history-limit 150)
  (setq eww-use-external-browser-for-content-type
        "\\`\\(video/\\|audio/\\|application/pdf\\)")
  (setq eww-browse-url-new-window-is-tab nil)
  (setq eww-form-checkbox-selected-symbol "[X]")
  (setq eww-form-checkbox-symbol "[ ]")

  (defun prot/eww-visit-history (&optional arg)
    "Revisit a URL from `eww-prompt-history' using completion.
With \\[universal-argument] produce a new buffer."
    (interactive "P")
    (let ((history eww-prompt-history)  ; eww-bookmarks
          (new (if arg t nil)))
      (eww
       (completing-read "Visit website from history: " history nil t)
       new)))

  ;; eww-view-source

  (defvar prot/eww-mode-global-map
    (let ((map (make-sparse-keymap)))
      (define-key map "s" 'eww-search-words)
      (define-key map "o" 'eww-open-in-new-buffer)
      (define-key map "f" 'eww-open-file)
      (define-key map "w" 'prot/eww-visit-history)
      map)
    "Key map to scope `eww' bindings for global usage.
The idea is to bind this to a prefix sequence, so that its
defined keys follow the pattern of <PREFIX> <KEY>.")
  :bind-keymap ("C-c w" . prot/eww-mode-global-map)
  :bind (:map eww-mode-map
              ("n" . next-line)
              ("p" . previous-line)
              ("f" . forward-char)
              ("b" . backward-char)
              ("a" . prot/eww-org-archive-current-url)
              ("B" . eww-back-url)
              ("N" . eww-next-url)
              ("P" . eww-previous-url)))

(use-package browse-url
  :after eww
  :config
  (setq browse-url-browser-function 'eww-browse-url))
#+end_src

* General interface and interactions
:PROPERTIES:
:CUSTOM_ID: h:b6bd2eea-8269-4029-b446-ee340c12ebc3
:END:

This section contains configurations for all aspects of the Emacs user
interface, as well lots of small or self-contained tweaks that cover a
wide range of built-in libraries.

** Go to actionable beginning or end of buffer (beginend.el)
:PROPERTIES:
:CUSTOM_ID: h:29ea650f-f6a9-4bb4-abca-9548b4e4c4eb
:END:

This package by Damien Cassou offers the means to move to the first or
last actionable point in a buffer rather than the absolute maximum or
minimum point.  It does so by wrapping =M-<= and =M->= around a "do what I
mean" behaviour where the initial command will take you to the
actionable part, while another call will go to the absolute position.
Nice and simple!

Check [[https://github.com/DamienCassou/beginend][the package upstream]] for information on the supported modes and on
how to contribute your own extensions (I provided support for =rg.el=,
which I [[#h:31622bf2-526b-4426-9fda-c0fc59ac8f4b][define elsewhere in this document]]).

Here the =dolist= combined with the =:diminish= keyword are meant to remove
all lighters that this package produces: one for every minor mode it
provides.  I got this from [[https://github.com/DamienCassou/beginend/issues/43][issue 43 on the beginend repo]].

#+begin_src emacs-lisp
(use-package beginend
  :straight t
  :demand
  :diminish beginend-global-mode
  :config
  (dolist (mode beginend-modes) (diminish (cdr mode)))
  (beginend-global-mode 1))
#+end_src

** Go to last change
:PROPERTIES:
:CUSTOM_ID: h:ac889a76-1092-449e-a184-9092093f3103
:END:

I could not find any built-in method of /reliably/ moving back to the
last change.  Using the mark ring is always an option, but does not fill
the exact same niche.

The =C-z= binding is [[#h:ae48fe61-a3c3-4132-8986-785f9bfbeafb][disabled elsewhere in this document]].  It minimises
the Emacs GUI by default.  A complete waste of an extremely valuable key
binding!

#+begin_src emacs-lisp
(use-package goto-last-change
  :straight t
  :bind ("C-z" . goto-last-change))
#+end_src

** Mode line
:PROPERTIES:
:CUSTOM_ID: h:39f57b0d-300a-4310-9ba8-8c388fa72e1d
:END:

The mode line is an integral part of the Emacs interface.  While there
are lots of third party packages that style it in a variety of ways, I
find the default to be particularly good /as a starting point/ (more about
that in the next section on [[#h:c07b9dfc-14a2-41a6-9310-53539dec8684][Moody.el]]).

In the code snippet right below I reshuffle some of the mode line
indicators.  Nothing too fancy.  The =mode-line-defining-kbd-macro= is
tweaked to use a more appropriate string for its indicator and to apply
colours that are designed specifically for the mode line (the default
uses the generic font-lock warning face).

Note that in [[#h:77d14350-978d-4820-ab7f-4641706c445a][Custom extensions for "focus mode" (prot-logos.el)]] I
provide a snippet that optionally toggles the visibility of the modeline
while entering a bespoke "focus mode" for writing/reading.

#+begin_src emacs-lisp
(use-package emacs
  :init
  (setq mode-line-percent-position '(-3 "%p"))
  (setq mode-line-position-column-line-format '(" %l,%c")) ; Emacs 28
  (setq mode-line-defining-kbd-macro
        (propertize " Macro" 'face 'mode-line-emphasis))
  (setq-default mode-line-format
                '("%e"
                  mode-line-front-space
                  mode-line-mule-info
                  mode-line-client
                  mode-line-modified
                  mode-line-remote
                  mode-line-frame-identification
                  mode-line-buffer-identification
                  "  "
                  mode-line-position
                  (vc-mode vc-mode)
                  "  "
                  mode-line-modes
                  " "
                  mode-line-misc-info
                  mode-line-end-spaces)))
#+end_src

In the following sub-sections I provide customisations for some tools
that place information on the mode line.  Again, nothing flamboyant.

*** Moody.el (simple mode line configuration utility)
:PROPERTIES:
:CUSTOM_ID: h:c07b9dfc-14a2-41a6-9310-53539dec8684
:END:

My complaint with the out-of-the-box experience with the mode line is
two-fold: (i) there is no easy way to tweak individual components other
than using inelegant workarounds and (ii) adjust the line's height.

What I need is an ever so slight adjustment to the height of the mode
line so that it is a bit taller than the typeface's innate line height,
plus an easy way to make the buffer identification more noticeable.
Thankfully, the lightweight =moody.el= by Jonas Bernoulli covers the exact
niche I want to occupy.

My tweaks here align Moody with my [[#h:e03b6415-a18f-4058-b9b0-5721d38c6c50][Font configurations (prot-fonts.el)]].
What I basically want is to make the mode line gracefully adapt to
changes in font size.  Furthermore, to make things work the way Moody
expects, I set the relevant option in [[#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6][my Modus themes]].

#+begin_src emacs-lisp
(use-package moody
  :straight t
  :after (prot-fonts             ; we need its hook
          prot-simple)           ; provides `prot-simple--number-even-p'
  :config
  (moody-replace-mode-line-buffer-identification)

  (defun prot/moody--height ()
    "Set Moody height to an even number.
Bind this to a hook that gets called after loading/changing the
mode line's typeface (or the default one if they are the same)."
    (let* ((font (face-font 'mode-line))
           (height (truncate (* 1.35 (aref (font-info font) 2))))
           (height-even (if (prot-common-number-even-p height) height (+ height 1))))
      (if font
          height-even
        20)))

  (defun prot/moody--mode-line-height ()
    "Set Moody height to the value of `prot/moody--height'."
    (setq moody-mode-line-height (funcall 'prot/moody--height)))
  :hook (prot-fonts-set-typeface-hook . prot/moody--mode-line-height))
#+end_src

*** Battery status
:PROPERTIES:
:CUSTOM_ID: h:3a759294-ab03-40cb-bb08-94275d76fc53
:END:

Emacs offers a built-in library for presenting information about the
status of the laptop's battery.  Using it allows me to eliminate my
reliance on the system panel and thus keep Emacs in full screen view
without any interruptions.

The default update interval is set to a single minute (in seconds),
which is generally fine though I find that a slightly higher value works
just as well.  As for the format, it is designed to show a
context-dependent, single character indicator about the current status,
as well as the battery's overall percentage.

Variable =battery-mode-line-limit= will hide the indicator if the value is
above the declared threshold.  95 basically means "full" for me.  I use
that instead of a 100 because sometimes the battery only ever fills up
to a lower threshold, meaning that the indicator remains present at all
times.

#+begin_src emacs-lisp
(use-package battery
  :config
  (setq battery-mode-line-format " [%b%p%%]")
  (setq battery-mode-line-limit 95)
  (setq battery-update-interval 180)
  (setq battery-load-low 20)
  (setq battery-load-critical 10)
  :hook (after-init-hook . display-battery-mode))
#+end_src

*** Display current time
:PROPERTIES:
:CUSTOM_ID: h:da14ac1d-a06f-4531-b6c3-0414e8c98102
:END:

I normally use Emacs in fullscreen view.  No system panels, no window
decorations, no icons and blinking indicators.  Nothing to distract me.
While I really like this environment, sometimes I need to take a look at
the time…  Thankfully Emacs offers a convenient, built-in way of
displaying such information in the mode line.

The =display-time-format= can be configured to show the current date and
time in all the various formats we would expect, using a string of
specifiers (find the docs with =C-h v format-time-string=).  Setting its
value to =nil= means that the information on display will be the combined
result of =display-time-24hr-format= and =display-time-day-and-date=.  I
prefer to just write a string directly, keeping those two inactive.

The =display-time-mode= can output more than just the current time.  It
also shows the load average and an email indicator.  I only need the
time and date.  The rest is noise.

Sometimes I need to check the current time on various timezones.  This
library's =world-clock= command gets the job done.

#+begin_src emacs-lisp
(use-package time
  :commands world-clock
  :config
  (setq display-time-format "%H:%M  %Y-%m-%d")
  ;;;; Covered by `display-time-format'
  ;; (setq display-time-24hr-format t)
  ;; (setq display-time-day-and-date t)
  (setq display-time-interval 60)
  (setq display-time-mail-directory nil)
  (setq display-time-default-load-average nil)

;;; World clock
  (setq zoneinfo-style-world-list
        '(("America/Los_Angeles" "Los Angeles")
          ("America/New_York" "New York")
          ("Europe/Brussels" "Brussels")
          ("Asia/Shanghai" "Shanghai")
          ("Asia/Tokyo" "Tokyo")))

  ;; All of the following variables are for Emacs 28
  (setq world-clock-list t)
  (setq world-clock-time-format "%R %z  %A %d %B")
  (setq world-clock-buffer-name "*world-clock*") ; Placement handled by
                                                 ; `display-buffer-alist'
  (setq world-clock-timer-enable t)
  (setq world-clock-timer-second 60)

  :hook (after-init-hook . display-time-mode))
#+end_src

*** Keycast mode
:PROPERTIES:
:CUSTOM_ID: h:e8e51a73-e583-4250-ac26-15627cd93932
:END:

Once enabled, this package uses the mode line to show the keys being
pressed and the command they call.  It is quite useful for screen
casting.

The placement of the indicator is controlled by =keycast-window-predicate=
which I set to the current window.  The =moody.el= library offers that
specific piece of functionality (though [[#h:c07b9dfc-14a2-41a6-9310-53539dec8684][I also configure Moody]] for its
primary purpose of styling the mode line).

The tweaks to the =keycast-substitute-alist= prevent the display of
self-inserting characters and some other commands that are not
particularly useful while screen casting.  Now the indicator will only
show commands, which looks cleaner.  I got the idea and original piece
of Elisp from the [[https://github.com/aadcg/dotfiles][dotfiles of André Alexandre Gomes]] and then added a few
tweaks of my own.

#+begin_src emacs-lisp
(use-package keycast
  :straight t
  :after moody
  :commands keycast-mode
  :config
  (setq keycast-window-predicate 'moody-window-active-p)
  (setq keycast-separator-width 1)
  (setq keycast-insert-after 'mode-line-buffer-identification)
  (setq keycast-remove-tail-elements nil)

  (dolist (input '(self-insert-command
                   org-self-insert-command))
    (add-to-list 'keycast-substitute-alist `(,input "." "Typing…")))

  ;;; TODO identify all events that should be excluded
  ;; mouse-set-point
  ;; mouse-set-region
  ;; mouse-drag-secondary
  ;; mouse-drag-line
  ;; mouse-drag-drag
  ;; mouse-start-end
  ;; mouse-drag-region nil
  ;; mouse-drag-track nil
  ;; mouse-drag-region-rectangle
  ;; mouse-drag-and-drop-region
  ;; mwheel-event-button
  ;; dframe-mouse-event-p
  ;; mouse-drag-events-are-point-events-p

  (dolist (event '(mouse-event-p
                   mouse-movement-p
                   mwheel-scroll))
    (add-to-list 'keycast-substitute-alist `(,event nil))))
#+end_src

** Window divider mode
:PROPERTIES:
:CUSTOM_ID: h:6fb900e3-49db-4bc3-8a9e-cd88e020f15b
:END:

This is a built-in mode that draws vertical window borders in a slightly
different way than the default, which I find more consistent.  Only
using it because of that, though it can also adjust the size of the
borders as well as their placement.

#+begin_src emacs-lisp
(use-package emacs
  :config
  (setq window-divider-default-right-width 1)
  (setq window-divider-default-bottom-width 1)
  (setq window-divider-default-places 'right-only)
  :hook (after-init-hook . window-divider-mode))
#+end_src

** Fringe mode
:PROPERTIES:
:CUSTOM_ID: h:26a4fac6-33e2-4f6c-8589-9463df8525c9
:END:

The fringes are areas to the right and left side of an Emacs frame.
They can be used to show status-related or contextual feedback such as
line truncation indicators, continuation lines, code linting markers,
etc.

The default fringe width (=nil=) is 8 pixels on either side, which I
approve of.  It is possible to set the value of the =fringe-mode= to
something like ='(10 . 5)= which applies the varied width to the left and
right side respectively.  Otherwise, we can use a single integer that
controls both sides.

The use of =setq-default= is necessary, otherwise these values become
buffer-local.

#+begin_src emacs-lisp
(use-package fringe
  :config
  (fringe-mode nil)
  (setq-default fringes-outside-margins nil)
  (setq-default indicate-buffer-boundaries nil)
  (setq-default indicate-empty-lines nil)
  (setq-default overflow-newline-into-fringe t))
#+end_src

*** Diff highlights in the fringe (diff-hl)
:PROPERTIES:
:CUSTOM_ID: h:5b71e71f-353f-4290-951b-3fc575c0fcba
:END:

The =diff-hl= package uses the left or right fringe to highlight changes
in the current buffer.  The indicators are colour-coded to denote
whether a change is an addition, removal, or change that includes a bit
of both.

The package offers some more features, such as the ability to move
between diff hunks while editing the buffer.  I still need to experiment
with those before customising them to my liking.

At any rate, this package is meant a general tool for version control
systems, rather than a git-specific one.  Much like the built-in VC (see
section on the [[*Generic version control (VC) framework][generic version control (VC) framework]]).

#+begin_src emacs-lisp
(use-package diff-hl
  :straight t
  :after vc
  :config
  (setq diff-hl-draw-borders nil)
  (setq diff-hl-side 'left)
  :hook (after-init-hook . global-diff-hl-mode))
#+end_src

** Highlight comment keywords (hl-todo)
:PROPERTIES:
:CUSTOM_ID: h:23d2928b-56a0-4a8e-a552-9af1acd45cb1
:END:

This tool by Jonas Bernoulli will apply highlighting to keywords that
are normally used in code comments.  Simple and effective!

#+begin_src emacs-lisp
(use-package hl-todo
  :straight t
  :hook (prog-mode-hook . hl-todo-mode))
#+end_src

** Optional visual indicators or layout elements
:PROPERTIES:
:CUSTOM_ID: h:e8d77f0b-0502-449b-bc69-18cf29b9edb0
:END:

This is a collection of modes or interfaces I seldom use or, rather, I
use under special circumstances.  They are useful, but there is not need
for them to be available at all times.

*** Current line highlight (hl-line-mode)
:PROPERTIES:
:CUSTOM_ID: h:7e65d6e5-ac8f-4100-b7dd-14e3fbc94040
:END:

This is a mode that I only activate via hooks for certain buffers
where the current line itself is more important that the actual column
(e.g. in Dired buffers).  Here I configure it so that the highlight
applies only to the current window.  There is also a "global" variant,
for when the equivalent mode is used (I have no plan to use that).

#+begin_src emacs-lisp
(use-package hl-line
  :config
  (setq hl-line-sticky-flag nil))
#+end_src

*** Toggles for line numbers and whitespace indicators
:PROPERTIES:
:CUSTOM_ID: h:cb76fcee-e304-4b86-a764-6c3c6775da51
:END:

+ Display line numbers (buffer-local) ::  I seldom use line numbers, but
  here it is.  This toggles the setting for the local buffer and also
  activates =hl-line-mode=.
+ Display invisible characters (whitespace) :: Viewing invisible
  characters (whitespace) can be very helpful under certain
  circumstances.  Generally though, I do not keep it active.

As for =delete-trailing-whitespace=, I prefer to call it manually because
sometimes it causes problems, such as with diffs.

#+begin_src emacs-lisp
(use-package display-line-numbers
  :config
  ;; Set absolute line numbers.  A value of "relative" is also useful.
  (setq display-line-numbers-type t)
  ;; Those two variables were introduced in Emacs 27.1
  (setq display-line-numbers-major-tick 0)
  (setq display-line-numbers-minor-tick 0)
  ;; Use absolute numbers in narrowed buffers
  (setq display-line-numbers-widen t)

  (define-minor-mode prot/display-line-numbers-mode
    "Toggle `display-line-numbers-mode' and `hl-line-mode'."
    :init-value nil
    :global nil
    (if prot/display-line-numbers-mode
        (progn
          (display-line-numbers-mode 1)
          (hl-line-mode 1)
          (setq-local truncate-lines t))
      (display-line-numbers-mode -1)
      (hl-line-mode -1)
      (setq-local truncate-lines nil)))
  :bind ("<f7>" . prot/display-line-numbers-mode))

(use-package whitespace
  :config
  (defun prot/toggle-invisibles ()
    "Toggles the display of indentation and space characters."
    (interactive)
    (if (bound-and-true-p whitespace-mode)
        (whitespace-mode -1)
      (whitespace-mode)))
  :bind (("<f6>" . prot/toggle-invisibles)
         ("C-c z" . delete-trailing-whitespace)))
#+end_src

*** Outline mode, outline minor mode, and extras (prot-outline.el)
:PROPERTIES:
:CUSTOM_ID: h:a8e737b8-7c90-4c68-8814-acf2f637ffa1
:END:

The =outline.el= library defines a major mode (=outline-mode=) that is
similar to =org-mode= in that it consists of headings which can be
expanded or contracted individually or as a group.  It is meant to work
on plain text files, or be leveraged by other packages, that need to
have some structure and the accompanying benefits of this mode.  In
practice, however, I never found a dedicated use for this major mode
that would justify it over the more featureful Org.

Where =outline.el= truly shines is in the minor mode it defines
(=outline-minor-mode=), which provides the familiar structured,
heading-folding facilities in other major modes, such as =emacs-lisp-mode=
(note: it may also work with other programming modes, though I am not a
programmer so I cannot really test it).  With some careful tweaks you
can continue to work on your code while also benefitting from a more
effective means of organising and reviewing what you have.

In practice, to make an outline for Elisp buffers, you need to start a
comment line /without leading spaces/ and make it at least three comment
delimiters long (=;;;=).  That is considered a heading level 1.  Every
extra delimiter will increase heading levels accordingly.  Markdown
headings should be recognised right away.

Now on to my custom library, =prot-outline.el= which builds on those
concepts:

+ Provide some new commands for working with outlines.  The main point
  of entry is, for me at least, =prot-outline-cycle-dwim=.

+ Define a new minor mode, =prot-outline-minor-mode=, which sets up a
  bespoke keymap as well as hooks that get fired when activating and
  disabling the mode.  Combine it with =prot-outline-minor-mode-safe= that
  checks whether the current buffer's major mode is not a member of a
  blocklist.  The idea is not to run this minor mode with major modes
  that already provide its functionality, namely, =org-mode=,
  =outline-mode=, =markdown-mode=.

+ Establish bindings with =imenu.el= (also read [[#h:77284937-ad9d-44cc-8a3e-80f6ed9e3def][my Imenu configurations]]).
  This is done via the aforementioned hooks and, in my experience,
  yields more accurate results than the defaults.  A quick reminder of
  why this matters: you can now navigate the outline using minibuffer
  completion, which is my favourite way to navigate a file I am familiar
  with.

Finally, an element of improved design: the =outline-minor-faces= package,
by Jonas Bernoulli, will apply colouration to the headings produced by
=outline-minor-mode=.  These inherit from =outline-mode= (they are
configured to look the same as the ones of Org in my Modus themes---see
[[#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6][relevant section]]).

Watch my [[https://protesilaos.com/codelog/2020-07-20-emacs-outline-imenu/][video demo of outline-minor-mode and imenu]] (2020-07-20), though
note that it was recorder long before I wrote =prot-outline.el=.

#+begin_src emacs-lisp
(use-package prot-outline
  :straight (:type built-in)
  :diminish outline-minor-mode
  ;; key replaces `menu-bar-open', which I never use
  :bind ("<f10>" . prot-outline-minor-mode-safe))

(use-package outline-minor-faces
  :straight t
  :after prot-outline
  :hook
  (prot-outline-minor-mode-enter-hook . outline-minor-faces-add-font-lock-keywords))
#+end_src

These are the contents of the =prot-outline.el= library (find the file in
[[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]] (as with all my Elisp code)):

#+include: straight/repos/prot-lisp/prot-outline.el src emacs-lisp :tangle no

** Registers
:PROPERTIES:
:CUSTOM_ID: h:6bdfe4d1-f97a-4d89-ab68-e87448a95fea
:END:

Registers are compartments that hold data of various sorts.  They offer
the means for advanced, highly efficient workflows, especially when
combined with keyboard macros.

Registers are called by a single character, which can be a letter
(case-sensitive), number, or symbol.  Each character can only contain a
single register at a time.

To define a register, you call the appropriate command (see table below)
and then specify the character you want to store that data at.

| Key chord | Command                                               |
|-----------+-------------------------------------------------------|
| C-x r n   | number-to-register                                    |
| C-x r s   | copy-to-register (think "save string")                |
| C-x r r   | copy-rectangle-to-register                            |
| C-x r SPC | point-to-register                                     |
| C-x r w   | window-configuration-to-register                      |
| C-x r f   | frameset-to-register (frames and their windows)       |
| C-x r +   | increment-register (better used with numbers)         |
| C-x r i   | insert-register (text, number, rectangle)             |
| C-x r j   | jump-to-register (to point or window/frameset config) |

Notes about some of the above:

+ Using =point-to-register= allows you to revisit a specific location in a
  buffer, but also reopen the file visited by that buffer in case the
  buffer is deleted.
+ Calling =number-to-register= without an argument will just store the
  number =0= to the register you specify.  Whereas =C-u 100 C-x r n= will
  store =100=.  In practice, you often want to use the latter method.
+ Use =increment-register= to increment a number by one.  Pass a numeric
  argument to increment by that amount instead.  For example, to
  increment by five do =C-u 5 C-x r += and then select the register you
  want to operate on.  This only affects the value stored in the
  register.  It does not also insert it in the buffer.
+ Number registers are particularly useful when you want to increment
  several numbers through a keyboard macro.  You can record the motions
  you need, run =increment-register= as noted above followed by the
  standard =insert-register=.  If, however, you just want to increment a
  single number through a keyboard macro, then just use the counter
  provided by that facility (refer to my video on [[https://protesilaos.com/codelog/2019-10-14-emacs-easier-kmacro-counter/][easier kmacro counter]]
  from 2019-10-14).
+ The registers that store text as a string or a rectangle rely on the
  active region to capture the data.  They are also great for keyboard
  macros where you cannot rely on yanking from the head of the kill ring
  (because, say, you are killing other things which push that value
  further down).  Note though that =increment-register= has a different
  behaviour when applied to them, where it will append to the register
  instead (with an option to override the previous value).
+ While on the topic of appending to registers, I define several
  functions that change how the accumulation of text is supposed to
  happen.  They introduce a space or line separator between the entries
  you {ap,pre}-pend to the register.
+ In my testing, I could never make =window-configuration-to-register=
  persist between sessions (see section on [[#h:68d57dd2-4df1-4b7a-8766-231216e6cd9c][Emacs server and desktop]]).
  Whereas all other registers retain their values.  So use this command
  to store window configurations that are otherwise transient in nature.
  For more permanent setups, rely on =frameset-to-register= which will
  produce a new frame (or more if you had) with all the windows in
  place.  Remember that you can always go back to your previous window
  configuration without using registers, such as with the built-in
  =winner-mode= (see section on [[#h:6b4f7792-6ccd-45d5-b262-01d200639072][window history and directional motions]]).
+ While on the topics of storing registers across sessions, I find that
  sometimes I will collect too many registers that I do not really need
  any more.  So =prot/clear-registers= just resets the list.

#+begin_src emacs-lisp
(use-package register
  :commands (prot/clear-registers
             prot/append-register-line-separator
             prot/append-register-space-separator
             prot/prepend-register-line-separator
             prot/prepend-register-space-separator)
  :config
  ;;;;;; Use this if you need it
  ;;;; Define f5 as an alias for C-x r
  ;; (global-set-key (kbd "<f5>") (lookup-key global-map (kbd "C-x r")))

  (defun prot/clear-registers ()
    "Remove all saved registers."
    (interactive)
    (setq register-alist nil))

  (defun prot/append-register-space-separator (start end)
    "Append region to register with space in between entries.

A prompt will ask for the register to operate on."
    (interactive "r")
    (let* ((prompt (register-read-with-preview
                    "Append to register with space separator: ")))
      (setq register-separator ?+)
      (set-register register-separator " ")
      (append-to-register prompt start end nil)))

  (defun prot/append-register-line-separator (start end)
    "Append region to register with an empty line in between entries.

A prompt will ask for the register to operate on."
    (interactive "r")
    (let* ((prompt (register-read-with-preview
                    "Append to register with line separator: ")))
      (setq register-separator ?+)
      (set-register register-separator "\n\n")
      (append-to-register prompt start end nil)))

  (defun prot/prepend-register-space-separator (start end)
    "Prepend region to register with space in between entries.

A prompt will ask for the register to operate on."
    (interactive "r")
    (let* ((prompt (register-read-with-preview
                    "Prepend to register with space separator: ")))
      (setq register-separator ?+)
      (set-register register-separator " ")
      (prepend-to-register prompt start end nil)))

  (defun prot/prepend-register-line-separator (start end)
    "Prepend region to register with an empty line in between entries.

A prompt will ask for the register to operate on."
    (interactive "r")
    (let* ((prompt (register-read-with-preview
                    "Prepend to register with line separator: ")))
      (setq register-separator ?+)
      (set-register register-separator "\n\n")
      (prepend-to-register prompt start end nil))))
#+end_src

** Cursor and mouse settings
:PROPERTIES:
:CUSTOM_ID: h:a75d07c3-22a8-4e0f-aa88-1e2e1579d820
:END:
*** Cursor appearance and tweaks
:PROPERTIES:
:CUSTOM_ID: h:cf9086c1-1b33-4127-a716-de94259e14a0
:END:

Nothing special here.  Just some tweaks for the cursor's appearance.  Do
=C-h f cursor-type= to learn everything about the availble options.

Note that in [[#h:c110e399-3f43-4555-8427-b1afe44c0779][Minibuffer configurations and extras (prot-minibuffer.el)]] I
also add a local variable for the minibuffer's cursor.

#+begin_src emacs-lisp
(use-package frame
  :config
  (setq-default cursor-type '(hbar . 3))
  (setq-default cursor-in-non-selected-windows 'hollow)
  (setq-default blink-cursor-blinks 50)
  (setq-default blink-cursor-interval 0.2)
  (setq-default blink-cursor-delay 0.2)
  (blink-cursor-mode 1))
#+end_src

*** prot-pulse.el (highlight cursor position)
:PROPERTIES:
:CUSTOM_ID: h:6bbc41d6-da7c-4301-84c6-c5887c29283f
:END:

=pulse.el= is a library that provides utilities for highlighting the
region or area around point.  It is meant to be used by other packages
as a means of offering visual feedback, as is the case with, for
example, =M-.= (=xref-find-definitions=).

While =prot-pulse.el= (complete code further below) is a thin wrapper that
provides some extensions that are useful to my workflow.  Specifically,
it declares a new face and provides a command that implements it:
=prot-pulse-pulse-line=.  This is useful to quickly highlight the line and
buffer I am on, but can also be utilised by other tools that move the
point an arbitrary distance.

#+begin_src emacs-lisp
(use-package prot-pulse
  :straight (:type built-in)
  :demand
  :config
  (setq prot-pulse-advice-commands t)
  (setq prot-pulse-pulse-command-list
        '(recenter-top-bottom
          reposition-window))
  (prot-pulse-advice-commands-mode 1)
  :bind ("<s-escape>" . prot-pulse-pulse-line))
#+end_src

This is the code for =prot-pulse.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]], in case
you wish to get the file):

#+include: straight/repos/prot-lisp/prot-pulse.el src emacs-lisp :tangle no

*** Mouse wheel behaviour
:PROPERTIES:
:CUSTOM_ID: h:02572210-eb26-4941-8f7c-666a0314877b
:END:

The value of =mouse-wheel-scroll-amount= means the following:

+ By default scroll by one line.
+ Hold down Shift to do so by five lines.
+ Hold down Meta to scroll half a screen.
+ Hold down Control to adjust the size of the text.  This was added in
  Emacs 27.

The other options in short:

+ Hide mouse pointer while typing.
+ Enable mouse scroll.
+ Faster wheel movement means faster scroll.
+ Scroll window under mouse pointer regardless of whether it is the
  current one or not.

Note that if we enable =mouse-drag-copy-region= we automatically place the
mouse selection to the kill ring.  This is the same behaviour as
terminal emulators that place the selection to the clipboard (or the
primary selection).  I choose not to use this here.

#+begin_src emacs-lisp
(use-package mouse
  :config
  ;; In Emacs 27+, use Control + mouse wheel to scale text.
  (setq mouse-wheel-scroll-amount
        '(1
          ((shift) . 5)
          ((meta) . 0.5)
          ((control) . text-scale)))
  (setq mouse-drag-copy-region nil)
  (setq make-pointer-invisible t)
  (setq mouse-wheel-progressive-speed t)
  (setq mouse-wheel-follow-mouse t)
  :hook (after-init-hook . mouse-wheel-mode))
#+end_src

*** Scrolling behaviour
:PROPERTIES:
:CUSTOM_ID: h:0c44b318-813a-4f4a-b596-75df4a86476b
:END:

By default, page scrolling should keep the point at the same visual
position, rather than force it to the top or bottom of the viewport.
This eliminates the friction of guessing where the point has warped to.

As for per-line scrolling, I dislike the default behaviour of visually
re-centring the point: it is too aggressive as a standard mode of
interaction.  With the following =setq-default=, the point will stay at
the top/bottom of the screen while moving in that direction (use =C-l= to
reposition it).

#+begin_src emacs-lisp
(use-package emacs
  :config
  (setq-default scroll-preserve-screen-position t)
  (setq-default scroll-conservatively 1) ; affects `scroll-step'
  (setq-default scroll-margin 0))
#+end_src

*** Delete selection
:PROPERTIES:
:CUSTOM_ID: h:d53b7b54-924a-443b-955a-3c5b222e3a90
:END:

This is a very helpful mode.  It kills the marked region when inserting
directly to it.  It also has checks to ensure that yanking over a
selected region will not insert itself when =mouse-drag-copy-region= is in
effect (see the section on the [[#h:02572210-eb26-4941-8f7c-666a0314877b][mouse wheel behaviour]]).

#+begin_src emacs-lisp
(use-package delsel
  :hook (after-init-hook . delete-selection-mode))
#+end_src

*Pro tip*: On Emacs 27.1 or higher you can create a rectangular region by
holding down Ctrl and Meta while dragging the mouse with the left click
pressed.

*** Tooltips (tooltip-mode)
:PROPERTIES:
:CUSTOM_ID: h:9f492949-70fb-4fba-a0ea-569d4a240be8
:END:

These settings control how tool tips are to be handled when hovering the
mouse over an actionable item:

+ I just want to make sure that the GTK theme is /not used/ for those: I
  prefer the generic display which follows my current theme's styles.
+ The delay is slightly reduced for the initial pop-up, while it has
  been increased for immediate pop-ups thereafter.

#+begin_src emacs-lisp
(use-package tooltip
  :config
  (setq tooltip-delay 0.5)
  (setq tooltip-short-delay 0.5)
  (setq x-gtk-use-system-tooltips nil)
  (setq tooltip-frame-parameters
        '((name . "tooltip")
          (internal-border-width . 6)
          (border-width . 0)
          (no-special-glyphs . t)))
  :hook (after-init-hook . tooltip-mode))
#+end_src

** Conveniences and minor extras
:PROPERTIES:
:CUSTOM_ID: h:271c9122-280b-424e-98f0-af9e4f09bbdb
:END:
*** Auto revert mode
:PROPERTIES:
:CUSTOM_ID: h:7a8422e6-86d1-40f3-add4-0a1c826e44a3
:END:

This mode ensures that the buffer is updated whenever the file changes.
A change can happen externally or by some other tool inside of Emacs
(e.g. kill a Magit diff).

#+begin_src emacs-lisp
(use-package autorevert
  :diminish
  :config
  (setq auto-revert-verbose t)
  :hook (after-init-hook . global-auto-revert-mode))
#+end_src

*** Preserve contents of system clipboard
:PROPERTIES:
:CUSTOM_ID: h:9eae0d2a-eef1-4b14-b883-39094be4de71
:END:

Say you copied a link from your web browser, then switched to Emacs to
paste it somewhere.  Before you do that, you notice something you want
to kill.  Doing that will place the last kill to the clipboard, thus
overriding the thing you copied earlier.  We can have a kill ring
solution to this with the following:

#+begin_src emacs-lisp
(use-package emacs
  :config
  (setq save-interprogram-paste-before-kill t))
#+end_src

Now the contents of the clipboard are stored in the kill ring and can
be retrieved from there (e.g. with =M-y=).

*** Generic feedback
:PROPERTIES:
:CUSTOM_ID: h:1f7c0bf3-8b0e-4baa-b1e0-7e89053d36cb
:END:

The common thread of these options is the feedback they provide us with
or simplify common tasks so that /their/ feedback does not cause friction:

+ Show the current buffer's name as the frame's title.  This only
  affects window managers that have window decorations.  If you do not
  know what that means, then you are most likely using an environment
  where frame titles are already visible.
+ Faster feedback for key chords (keys appear in the echo area).
+ Allow inputting Greek while preserving Emacs keys.  Toggle with =C-\=.
+ Ignore visual or audible bells.  Emacs has more appropriate ways of
  providing error/warning messages or hints that something is not
  producing the desired results (e.g. a failed =isearch= will return no
  results, while the failed match will be styled accordingly in the echo
  area).  By the way, use =C-h e= to bring up the log with the echo area's
  messages.
+ Answer with just the initials when dealing with "yes/no" questions.
+ Enable actions for narrowing the buffer, region {up,down}casing (all
  caps or no caps), =dired= single-buffer navigation (bound to =a=).
  Disable overwrite-mode.

#+begin_src emacs-lisp
(use-package emacs
  :config
  (setq frame-title-format '("%b"))
  (setq echo-keystrokes 0.25)
  (setq default-input-method "greek")
  (setq ring-bell-function 'ignore)

  (defalias 'yes-or-no-p 'y-or-n-p)
  (put 'narrow-to-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
  (put 'dired-find-alternate-file 'disabled nil)
  (put 'overwrite-mode 'disabled t))
#+end_src

*** Newline characters for file ending
:PROPERTIES:
:CUSTOM_ID: h:c0f0a2c1-1920-4bcf-8eb4-45f80cf1b874
:END:

For some major modes, such as =diff-mode=, a final newline is of paramount
importance.  Without it you cannot, for instance, apply a patch cleanly.
As such, the =mode-require-final-newline= will add a newline character
when visiting or saving a buffer of relevance.

#+begin_src emacs-lisp
(use-package emacs
  :config
  (setq mode-require-final-newline 'visit-save))
#+end_src

*** Altered zap and easier repeats
:PROPERTIES:
:CUSTOM_ID: h:5f6ffe61-f0cc-41ad-9d2f-46ad181c3a00
:END:

I seldom use the functionality related to this section, but when I do I
prefer it to work the way I expect.  =zap-up-to-char= will delete
everything from point up to the character you provide it with.  Think of
how you may want to delete a file name but keep its file type extension.

The repeat command is bound by default to =C-x z=.  I make it so that
subsequent repetitions require only hitting another =z=.  In practice
though, you should not bother with this.  Let keyboard macros handle
that task.

*Pro tip:* to make a keyboard macro out of your most recent commands,
use =C-x C-k l= which calls =kmacro-edit-lossage=.  The list is editable, so
remove anything that is not required and then save what is left.  The
result is stored as the latest keyboard macro (and you also have the
power to cycle through kmacros, store them in specific keys, etc.).

Moving on to the mark, practically every Emacs motion that operates on a
portion of text will set the mark automatically.  You can also do it
manually with =C-SPC= (hit it twice if you do not wish to activate the
region).  It is then possible to cycle through the marks in reverse
order by passing a prefix argument =C-u C-SPC=.  With the evaluation of
=set-mark-command-repeat-pop= as =t= we can continue cycling by repeated
presses of =C-SPC=.  Again though, this is not the type of functionality I
rely on: for more deliberate actions of this sort, consider Emacs'
notion of "registers".

#+begin_src emacs-lisp
(use-package emacs
  :config
  (setq repeat-on-final-keystroke t)
  (setq set-mark-command-repeat-pop t)
  :bind ("M-z" . zap-up-to-char))
#+end_src

*** Package lists
:PROPERTIES:
:CUSTOM_ID: h:0d36996d-c12d-42e6-a388-b67c548c4a4b
:END:

With this I just want to enable line highlighting when browsing the list
of packages.  I generally use =hl-line-mode= on all interfaces where the
current line is more important than the exact column of the point.

#+begin_src emacs-lisp
(use-package package
  :commands (list-packages
             package-refresh-contents
             package-list-packages)
  :config
  ;; All variables are for Emacs 28+
  (setq package-name-column-width 40)
  (setq package-version-column-width 14)
  (setq package-status-column-width 12)
  (setq package-archive-column-width 8)
  :hook (package-menu-mode-hook . hl-line-mode))
#+end_src

* Language settings for prose and code
:PROPERTIES:
:CUSTOM_ID: h:8fc1f9ca-f5ae-407a-b721-aab414ca657b
:END:

This section is all about configurations and/or packages that deal with
natural or programming language enhancements.

** Support for various major modes
:PROPERTIES:
:CUSTOM_ID: h:485bb253-208a-4a0a-99e3-ae1a205e3b7b
:END:

These provide syntax highlighting and additional features for
environments that are not already supported by Emacs.

*** Plain text (text-mode with prot-text.el)
:PROPERTIES:
:CUSTOM_ID: h:a04db751-9675-4f31-befc-0b48671c4b3b
:END:

My =prot-text.el= (copied verbatim further below), provides a set of
extensions for the built-in =text-mode.el=.  Currently there are only two
commands, though I plan to add more of them.

+ =prot-text-insert-heading= lets you add a heading delimiter to the line
  at point.  The length of the delimiter is equal to that of the line.
  By default, the delimiter consists of hyphens, but with a =C-u= prefix
  argument those are substituted for equals signs.

+ =prot-text-cite-region= reformats the active region to look like a
  quoted block.  It is meant to be simple and so does not test for
  indentation (remember, this is striclty about plain text, not
  structured program code).  When called with an optional =C-u= prefix
  argument, it prompts for a description, which it places at the top of
  the formatted text inside square brackets.  Instead of trying to
  visualise the effect for you, check this:

#+begin_example
This is some text
we would like to quote

+----
| This is some text
| we would like to quote
+----

+----[ Description added (called command with C-u) ]
| This is some text
| we would like to quote
+----
#+end_example

Here is the =use-package= declaration.  Remember that =text-mode= is a
dependency of =prot-text=, so no need to include it here.

#+begin_src emacs-lisp
(use-package prot-text
  :straight (:type built-in)
  :mode ("\\(README\\|CHANGELOG\\|COPYING\\|LICENSE\\)$")
  :bind (:map text-mode-map
              ("<M-return>" . prot-text-insert-heading)
              ("M-;" . prot-text-cite-region)
              :map org-mode-map
              ("M-;" . nil)))
#+end_src

Finally, those are the contents of the =prot-text.el= library (find the
file in [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]] (as with all my Elisp code)):

#+include: straight/repos/prot-lisp/prot-text.el src emacs-lisp :tangle no

*** Markdown (markdown-mode)
:PROPERTIES:
:CUSTOM_ID: h:7e0416c0-3acc-4748-9eca-4dd4da11d79b
:END:

I edit lots of Markdown files.  This makes things easier.

#+begin_src emacs-lisp
(use-package markdown-mode
  :straight t
  :config
  ;; Allows for fenced block focus with C-c ' (same as Org blocks).
  (use-package edit-indirect :straight t)
  (setq markdown-fontify-code-blocks-natively t)
  :mode ("\\.md$" . markdown-mode))
#+end_src

*** YAML (yaml-mode)
:PROPERTIES:
:CUSTOM_ID: h:c6a1aa30-4850-40b4-9764-302d98ba95fc
:END:

This adds support for YAML files.

#+begin_src emacs-lisp
(use-package yaml-mode
  :straight t
  :mode (("\\.yml$" . yaml-mode)
         ("\\.yaml$" . yaml-mode)))
#+end_src

*** CSS (css-mode)
:PROPERTIES:
:CUSTOM_ID: h:ec10bfe6-5340-481c-9de2-3e346868241b
:END:

This is the built-in mode for working with CSS and SCSS.  I just want it
to not apply previews to colour references.  If I ever need that, there
is =rainbow-mode= (see [[#h:9061c694-5f45-46b0-a878-6bcfb018e18d][relevant section]]).

#+begin_src emacs-lisp
(use-package css-mode
  :mode (("\\.css$" . css-mode)
         ("\\.scss$" . scss-mode))
  :config
  (setq css-fontify-colors nil))
#+end_src

*** Shell scripts (sh-mode)
:PROPERTIES:
:CUSTOM_ID: h:fee2b8ff-80d6-4669-904c-c8ee64c9719c
:END:

Another built-in mode that targets shell scripts.  I think it works well
out-of-the-box, even though it provides lots of configuration options to
further control its behaviour.

All I want here is to enable =sh-mode= in various files that are not
obvious shell scripts, like Arch Linux's package recipes.  As such, the
=:mode= list will be expanded over time.

#+begin_src emacs-lisp
(use-package sh-script
  :mode (("PKGBUILD" . sh-mode)))
#+end_src

** Line length (column count)
:PROPERTIES:
:CUSTOM_ID: h:c392fef1-17b7-4cc0-b0e2-2b3edd0eed3c
:END:

The column count is set to 72.  The standard line length is 80
characters, so having it at something less allows for such things as
quoting plain text, indenting, etc.  =git= commit messages also make good
use of this method.  The column count is used by =auto-fill-mode= and
similar tools (or when manually invoking text formatting with
=fill-paragraph= or equivalent---normally bound to =M-q=).

#+begin_src emacs-lisp
(use-package emacs
  :config
  (setq-default fill-column 72)
  :hook (after-init-hook . column-number-mode))
#+end_src

** Paragraphs and fill-mode
:PROPERTIES:
:CUSTOM_ID: h:1ae84fae-efc1-4bcc-9542-55b4ab8391a3
:END:

Let us first configure how paragraphs should be treated.  I find that a
double space is the best way to delimit sentences in source form.  There
is no worry that this will be shown on a website or rendered version of
a document, because processors know how to handle spacing.  We do this
to make things easier to tell apart, but also to render unambiguous
commands like =forward-sentence=.

#+begin_src emacs-lisp
(use-package emacs
  :config
  (setq sentence-end-double-space t)
  (setq colon-double-space nil)
  (setq use-hard-newlines nil)
  (setq sentence-end-without-period nil))
#+end_src

Now we need to make sure we run the minor mode that keeps paragraphs
within the column [[#h:c392fef1-17b7-4cc0-b0e2-2b3edd0eed3c][limit I prefer]]: you can always do it manually for the
current paragraph or the active region with =fill-paragraph=, bound by
default to =M-q=.

By targeting =text-mode= we also affect every major mode derived from it,
which means that we correctly do not get this utility in
programming-related modes (in principle, those come from =prog-mode=).
The adaptive mode improves the handling of things like bulleted and
numbered lists, where it recognises the text's prefix and tries to align
to it rather than the absolute beginning of the line.

Note that [[#h:ae48fe61-a3c3-4132-8986-785f9bfbeafb][Common custom functions (prot-simple.el)]] contains some
commands related to auto-fill.

#+begin_src emacs-lisp
(use-package emacs
  :diminish auto-fill-function
  :config
  (setq adaptive-fill-mode t)
  :hook (text-mode-hook . turn-on-auto-fill))
#+end_src

** Recognise subwords
:PROPERTIES:
:CUSTOM_ID: h:899cff89-a517-41d5-8c55-b91c6aba8c9d
:END:

It is better you do =C-h f subword-mode=.  Basically, this alters the
way Emacs understands word boundaries.  So, /camelCaseWords/ are
exposed as their constituents rather than one long word, meaning that
motions will behave accordingly.

#+begin_src emacs-lisp
(use-package subword
  :diminish
  :hook (prog-mode-hook . subword-mode))
#+end_src

** Comment lines, regions, boxes, etc.
:PROPERTIES:
:CUSTOM_ID: h:fa56241c-6840-4a39-8f59-18460d37fc69
:END:

Just some basic configurations for commenting structured text.  This is
mostly a placeholder for potentially more targeted and detailed settings
that would involve per-mode hooks.

The purpose of my reviewed key bindings is to make them more consistent.
Helps with mnemonics.  They also are more ergonomic.  To this end, I
have the following:

+ The standard commenting function is now bound to the simple =C-;=.
  This runs a "do what I meant" function I have defined, whose detailed
  documentation can be read below.
+ =C-:= (=C-S-;=) will kill the comment on the current line.  This is
  particularly helpful when the comment follows text you would like to
  keep.  The operation can be performed regardless of where the point is
  on the line.  *Some modes disable this behaviour* (e.g. trying it on
  source code inside of org-mode—for those cases, focus the block with
  =C-c '=).
+ The =M-;= will just append a comment to the line, rather than the
  default =comment-dwim=.

Note that =C-;= is occupied by some =flyspell= command that I have no
use for (disabled in the relevant package declaration).

Lastly, use =M-j= (alias =C-M-j=) when you want to continue an existing
comment on a new line with respect for the current indentation.  If you
are not inside of a comment, this will just create an indentation-aware
new line.

#+begin_src emacs-lisp
(use-package newcomment
  :config
  (setq comment-empty-lines t)
  (setq comment-fill-column nil)
  (setq comment-multi-line t)
  (setq comment-style 'multi-line)

  (defun prot/comment-dwim (&optional arg)
    "Alternative to `comment-dwim': offers a simple wrapper
around `comment-line' and `comment-dwim'.

If the region is active, then toggle the comment status of the
region or, if the major mode defines as much, of all the lines
implied by the region boundaries.

Else toggle the comment status of the line at point."
    (interactive "*P")
    (if (use-region-p)
        (comment-dwim arg)
      (save-excursion
        (comment-line arg))))

  :bind (("C-;" . prot/comment-dwim)
         ("C-:" . comment-kill)
         ("M-;" . comment-indent)
         ("C-x C-;" . comment-box)))
#+end_src

** Configure 'electric' behaviour
:PROPERTIES:
:CUSTOM_ID: h:ed95ef3e-75e6-4e53-b3bc-4aee540fe3d9
:END:

Emacs labels as "electric" any behaviour that involves contextual
auto-insertion of characters.  This is a summary of my settings:

+ Indent automatically.
+ If =electric-pair-mode= is enabled (which I might do manually), insert
  quotes and brackets in pairs.  Only do so if there is no alphabetic
  character after the cursor.
+ The cryptic numbers in the pairs set, correspond to curly single and
  double quotes and these =«»=.  The contents of this set are always
  inserted in pairs, regardless of major mode.
  + To get those numbers, evaluate =(string-to-char CHAR)= where CHAR is
    the one you are interested in.  For example, get the literal tab's
    character with =(string-to-char "\t")=.
+ While inputting a pair, inserting the closing character will just skip
  over the existing one, rather than add a new one.  So typing =(= will
  insert =()= and then typing =)= will just be the same as moving forward
  one character =C-f=.
+ Do not skip over whitespace when operating on pairs.  Combined with
  the above point, this means that a new character will be inserted,
  rather than be skipped over.  I find this better, because it prevents
  the point from jumping forward, plus it allows for more natural
  editing.
+ The whitespace characters are space (=\s=), tab (=\t=), and newline (=\n=).
+ The rest concern the conditions for transforming quotes into their
  curly equivalents.  I keep this disabled, because curly quotes are
  distinct characters.  It is difficult to search for them.  Just note
  that on GNU/Linux you can type them directly by hitting the "compose"
  key and then an angled bracket (=<= or =>=) followed by a quote mark.

#+begin_src emacs-lisp
(use-package electric
  :config
  (setq electric-pair-inhibit-predicate'electric-pair-conservative-inhibit)
  (setq electric-pair-preserve-balance t)
  (setq electric-pair-pairs
        '((8216 . 8217)
          (8220 . 8221)
          (171 . 187)))
  (setq electric-pair-skip-self 'electric-pair-default-skip-self)
  (setq electric-pair-skip-whitespace nil)
  (setq electric-pair-skip-whitespace-chars
        '(9
          10
          32))
  (setq electric-quote-context-sensitive t)
  (setq electric-quote-paragraph t)
  (setq electric-quote-string nil)
  (setq electric-quote-replace-double t)
  :hook (after-init-hook . (lambda ()
                             (electric-indent-mode 1)
                             (electric-pair-mode -1)
                             (electric-quote-mode -1))))
#+end_src

** Parentheses (show-paren-mode)
:PROPERTIES:
:CUSTOM_ID: h:3d374354-843f-4efa-aa38-1ba2c9ccc14c
:END:

Configure the mode that highlights matching delimiters or parentheses.
I consider this of utmost importance when working with languages such as
elisp.

Summary of what these do:

+ Activate the mode upon startup.
+ Show the matching delimiter/parenthesis if on screen, else show
  nothing.  It is possible to highlight the expression enclosed by the
  delimiters, by using either =mixed= or =expression=.  The latter always
  highlights the entire balanced expression, while the former will only
  do so if the matching delimiter is off screen.
+ =show-paren-when-point-in-periphery= lets you highlight parentheses even
  if the point is in their vicinity.  This means the beginning or end of
  the line, with space in between.  I used that for a long while and it
  server me well.  Now that I have a better understanding of Elisp, I
  disable it.
+ Do not highlight a match when the point is on the inside of the
  parenthesis.

#+begin_src emacs-lisp
(use-package paren
  :config
  (setq show-paren-style 'parenthesis)
  (setq show-paren-when-point-in-periphery nil)
  (setq show-paren-when-point-inside-paren nil)
  :hook (after-init-hook . show-paren-mode))
#+end_src

** Tabs, indentation, and the TAB key
:PROPERTIES:
:CUSTOM_ID: h:d51d37df-4e58-4e0b-85a1-019ceda342f6
:END:

I believe tabs, in the sense of inserting the tab character, are best
suited for indentation.  While spaces are superior at precisely aligning
text.  However, I understand that elisp uses its own approach, which I
do not want to interfere with.  Also, Emacs tends to perform alignments
by mixing tabs with spaces, which /can actually lead to misalignments/
depending on certain variables such as the size of the tab.  As such, I
am disabling tabs by default.

If there ever is a need to use different settings in other modes, we can
customise them via hooks.  This is not an issue I have encountered yet
and am therefore refraining from solving a problem that does not affect
me.

Note that =tab-always-indent= will first do indentation and then try to
complete whatever you have typed in.  I control how completion works for
that particular function in my [[#h:98876022-57cc-40de-936e-4ee42cefd69a][in-buffer completions]] section.

#+begin_src emacs-lisp
(use-package emacs
  :config
  (setq-default tab-always-indent 'complete)
  (setq-default tab-width 4)
  (setq-default indent-tabs-mode nil))
#+end_src

** Flyspell (spell check)
:PROPERTIES:
:CUSTOM_ID: h:3f1b2856-c6b7-418a-9d7d-464bd1ebe69c
:END:

I need spell checking mostly for English, though I also install
dictionaries for Greek, French, and Spanish.  These are external to
Emacs and are provided by the =aspell= library.

In previous versions of this section I had configurations that would
automate spell checking.  It worked but was rather slow.  Upon further
inspection, I realised that I seldom need to work in mixed language
circumstances.  Moreover, I now understand that I do not need to have
spell checking always on.  It can be activated manually, with the
=flyspell= functions defined in the =:commands= segment below or with my
=prot/flyspell-dwim= for the active region.

Also bear in mind that the key binding =C-;= that Flyspell uses by default
is disabled because I re-purpose that for a faster version of =C-x C-;=
(much more useful for my work—see the [[#h:fa56241c-6840-4a39-8f59-18460d37fc69][section on comments]]).

Note that my use-case for Flyspell is to mark a region and test for
errors in it.  If I need to review the entire buffer, especially if it
is about some long-form text, I use a =flymake= interface instead (refer
to the [[#h:aeb3e777-39fd-4b4f-8dc9-8b6aa7a595cc][section on flymake-aspell]]).

#+begin_src emacs-lisp
(use-package flyspell
  :config
  (setq flyspell-issue-message-flag nil)
  (setq flyspell-issue-welcome-flag nil)
  (setq ispell-program-name "aspell")
  (setq ispell-dictionary "en_GB")

  (defvar prot/ispell-dictionaries
    '(("English" . "en")
      ("Ελληνικά" . "el")
      ("Français" . "fr")
      ("Espanõl" . "es"))
    "Alist of dictionaries I may use.
It is used by `prot/ispell-dictionaries-complete'.")

  (defun prot/ispell-dictionaries-complete ()
    "Select an item from `prot/ispell-dictionaries'."
    (interactive)
    (let* ((dicts (mapcar #'car prot/ispell-dictionaries))
           (choice (completing-read "Select dictionary: " dicts nil t))
           (key (cdr (assoc `,choice prot/ispell-dictionaries))))
      (ispell-change-dictionary key)
      (message "Switched to %s" key)))

  (defun prot/flyspell-dwim ()
    "Spell check region or select dictionary.

Use `flyspell-region' on the active region, else invoke
`prot/ispell-dictionaries-complete'."
    (interactive)
    (let ((beg (region-beginning))
          (end (region-end)))
      (if (use-region-p)
          (flyspell-region beg end)
        (prot/ispell-dictionaries-complete))))

  :bind (("M-$" . prot/flyspell-dwim)
         ("C-M-$" . prot/ispell-dictionaries-complete)
         :map flyspell-mode-map
         ("C-;" . nil)))
#+end_src

** Code and text linters
:PROPERTIES:
:CUSTOM_ID: h:20448ad8-9371-4e00-b88b-6b93f4c654d9
:END:

*** Flymake
:PROPERTIES:
:CUSTOM_ID: h:b8bfcc05-c0d3-4093-b3fe-f06187d22c6a
:END:

This is a built-in linter interface.  It visualises in a buffer what you
would otherwise get on the command-line prompt (or compilation log),
while it also marks the line[s] where the note, warning, or error
occurs.  In short, it is quite a nice tool to have.

Several extensions to Flymake are already available, mostly targeted at
programmers.  For my case, there is no need for any of those, while
Flymake can lint Elisp without any further configuration.

#+begin_src emacs-lisp
(use-package flymake
  :after prot-project
  :commands flymake-mode
  :init
  (setq flymake-fringe-indicator-position 'left-fringe)
  (setq flymake-suppress-zero-counters t)
  (setq flymake-start-on-flymake-mode t)
  (setq flymake-no-changes-timeout nil)
  (setq flymake-start-on-save-buffer t)
  (setq flymake-proc-compilation-prevents-syntax-check t)
  (setq flymake-wrap-around nil)
  :bind (:map flymake-mode-map
              ("C-c ! s" . flymake-start)
              ("C-c ! d" . flymake-show-diagnostics-buffer)
              ("C-c ! n" . flymake-goto-next-error)
              ("C-c ! p" . flymake-goto-prev-error)))

(use-package flymake-diagnostic-at-point
  :straight t
  :after flymake
  :config
  (setq flymake-diagnostic-at-point-display-diagnostic-function
        'flymake-diagnostic-at-point-display-minibuffer))
#+end_src

**** Flymake + Proselint
:PROPERTIES:
:CUSTOM_ID: h:2a954862-c532-43e9-afdf-4bacd152295f
:END:

Manuel Uberti has published [[https://github.com/manuel-uberti/flymake-proselint][flymake-proselint on Github]] and MELPA.  It
offers a Flymake interface to the external =proselint= executable (see
[[#h:6dff70a8-7eba-4b5d-982c-f13d13ed3b3b][Proselint configuration]]).

This comes in handy when I need to review some long-form text for common
inconsistencies and stylistic irregularities.  Errors will be marked on
the fringe, while you can quickly get an overview with pointers to the
precise line number by invoking =flymake-show-diagnostics-buffer= (also
check my [[#h:b8bfcc05-c0d3-4093-b3fe-f06187d22c6a][configurations for Flymake]]).

To run the program, you just need to hook it to whatever major-mode you
use for prose.  The following =dolist= handles this nicely.  Then you need
to enable =flymake-mode= to start using it.  I prefer to do the final step
manually, as I normally do not run a linter while writing: it is too
distracting.

#+begin_src emacs-lisp
(use-package flymake-proselint
  :straight t
  :after flymake
  :init
  (dolist (mode '("markdown-mode" "org-mode" "text-mode"))
    (add-hook (intern (concat mode "-hook")) #'flymake-proselint-setup)))
#+end_src

***** Proselint configuration
:PROPERTIES:
:CUSTOM_ID: h:6dff70a8-7eba-4b5d-982c-f13d13ed3b3b
:END:

This is my configuration for the external =proselint= executable (check
[[https://github.com/amperser/proselint][that project's README]]).  The following should be made available at
=~/.config/proselint/config=.

See [[#h:2a954862-c532-43e9-afdf-4bacd152295f][Flymake + Proselint]] for how I use this tool to review my long-form
writing.

#+begin_example conf
{
    "max_errors": 200,
    "checks": {
        "airlinese.misc"                : false,
        "annotations.misc"              : true,
        "archaism.misc"                 : true,
        "cliches.hell"                  : true,
        "cliches.misc"                  : true,
        "consistency.spacing"           : true,
        "consistency.spelling"          : true,
        "corporate_speak.misc"          : false,
        "cursing.filth"                 : false,
        "cursing.nfl"                   : false,
        "cursing.nword"                 : false,
        "dates_times.am_pm"             : false,
        "dates_times.dates"             : false,
        "hedging.misc"                  : true,
        "hyperbole.misc"                : true,
        "jargon.misc"                   : true,
        "lexical_illusions.misc"        : true,
        "lgbtq.offensive_terms"         : true,
        "lgbtq.terms"                   : true,
        "links.broken"                  : false,
        "malapropisms.misc"             : true,
        "misc.apologizing"              : true,
        "misc.back_formations"          : true,
        "misc.bureaucratese"            : true,
        "misc.but"                      : true,
        "misc.capitalization"           : true,
        "misc.chatspeak"                : false,
        "misc.commercialese"            : true,
        "misc.composition"              : true,
        "misc.currency"                 : false,
        "misc.debased"                  : true,
        "misc.false_plurals"            : true,
        "misc.illogic"                  : true,
        "misc.inferior_superior"        : true,
        "misc.institution_name"	        : true,
        "misc.latin"                    : true,
        "misc.many_a"                   : false,
        "misc.metaconcepts"             : true,
        "misc.metadiscourse"            : true,
        "misc.narcissism"               : true,
        "misc.not_guilty"               : true,
        "misc.phrasal_adjectives"       : true,
        "misc.preferred_forms"          : true,
        "misc.pretension"               : true,
        "misc.professions"              : true,
        "misc.punctuation"              : true,
        "misc.scare_quotes"             : true,
        "misc.suddenly"                 : false,
        "misc.tense_present"            : true,
        "misc.waxed"                    : true,
        "misc.whence"                   : false,
        "mixed_metaphors.misc"          : true,
        "mondegreens.misc"              : true,
        "needless_variants.misc"        : true,
        "nonwords.misc"                 : true,
        "oxymorons.misc"                : true,
        "psychology.misc"               : true,
        "redundancy.misc"               : true,
        "redundancy.ras_syndrome"       : true,
        "skunked_terms.misc"            : true,
        "spelling.able_atable"          : true,
        "spelling.able_ible"            : true,
        "spelling.athletes"             : false,
        "spelling.em_im_en_in"          : true,
        "spelling.er_or"                : true,
        "spelling.in_un"                : true,
        "spelling.misc"                 : true,
        "security.credit_card"          : false,
        "security.password"             : false,
        "sexism.misc"                   : true,
        "terms.animal_adjectives"       : true,
        "terms.denizen_labels"          : true,
        "terms.eponymous_adjectives"    : true,
        "terms.venery"                  : true,
        "typography.diacritical_marks"  : false,
        "typography.exclamation"        : true,
        "typography.symbols"            : true,
        "uncomparables.misc"            : true,
        "weasel_words.misc"             : true,
        "weasel_words.very"             : false
    }
}
#+end_example

**** Flymake + Aspell
:PROPERTIES:
:CUSTOM_ID: h:aeb3e777-39fd-4b4f-8dc9-8b6aa7a595cc
:END:

I normally review a region's spelling with Flyspell, using my own
extensions for it (see [[#h:3f1b2856-c6b7-418a-9d7d-464bd1ebe69c][Flyspell (spell check)]]).  I do, however, prefer
to have an overview of all spelling warnings/errors as a final test
before publishing a long-form text (e.g. an article on my website).

This is where =flymake-aspell= by Leo Gaskin comes in handy.  It uses the
familiar Flymake interface (see [[#h:b8bfcc05-c0d3-4093-b3fe-f06187d22c6a][Flymake configuration]]) to highlight all
spelling issues.  Simple and effective!

Note that =flyspell= is not a dependency, but I still list it in the
=:after= directive because that is where the ispell dictionary is
specified (as it is what I normally use).  This would normally be a bad
practice, though I do not run into problems since flyspell is always
invoked before I ever have any need for =flymake-aspell=, so the
dependency is satisfied.

For a related package, consult my [[#h:2a954862-c532-43e9-afdf-4bacd152295f][configurations for flymake-proselint]].

#+begin_src emacs-lisp
(use-package flymake-aspell
  :after (flyspell flymake)
  :straight t
  :init
  (dolist (mode '("markdown-mode" "org-mode" "text-mode"))
    (add-hook (intern (concat mode "-hook")) #'flymake-aspell-setup)))
#+end_src

*** Elisp packaging requirements
:PROPERTIES:
:CUSTOM_ID: h:d03342da-3035-409f-a5e7-5df1e614d507
:END:

With this in place we can perform checks that pertain to Emacs lisp
packaging.  I use it for my themes but also for any elisp library I may
want to send patches to.

#+begin_src emacs-lisp
(use-package package-lint-flymake
  :straight t
  :after flymake
  :hook (flymake-diagnostic-functions . package-lint-flymake))
#+end_src

** Eldoc (elisp live documentation feedback)
:PROPERTIES:
:CUSTOM_ID: h:d0f76937-4f54-401c-aae8-ffadf8697357
:END:

When editing elisp, this mode will display useful information about the
construct at point in the echo area.  For functions it will display the
list of arguments they accept.  While it will show the the first
sentence of a variable's documentation string.

At first, I dismissed this package.  Upon closer inspection, it does
offer a lightweight complementary facility to that of the standard help
commands: =C-h f FUNCTION=, =C-h v VARIABLE=.

#+begin_src emacs-lisp
(use-package eldoc
  :diminish
  :config
  (global-eldoc-mode 1))
#+end_src

** Tools for manual pages (manpages)
:PROPERTIES:
:CUSTOM_ID: h:ce420306-c40c-4d9a-bc01-205c5e49a5d1
:END:

Emacs offers a couple of commands for reading manual pages: =man= and
=woman=.  The former relies on the standard Unix tools, while the latter
is an elisp implementation of the same idea.  As I only ever run a
GNU/Linux system, I am okay with just =man=.

Why bother?

+ All the goodies of consistency: fonts, themes, operating on text with
  your familiar Emacs functionality, handling buffers…
+ Each manpage provides direct links to other items it references.

What you can do inside such a buffer (with minor tweaks by me):

+ Hit =i= to go to the information node you want using completion (same
  principle as with the Info pages of =C-h i= and the like).
+ =g= will generate the buffer anew.  Do it to reformat the text manually,
  though this should also happen automatically when adjusting a window's
  size.
+ =n= and =p= move between section headings.
+ Hit =RET= while over a referenced manpage to produce a new buffer with
  its contents.
+ =s= takes you directly to the familiar "See Also" section.
+ Use =m= to search for another manpage using your completion framework.
  If you invoke this command while point is over a referenced manpage,
  it becomes the default choice (same concept as with common help
  commands, =C-h f=, =C-h v=, and with many others like =find-library=).

Need to filter out those =man= buffers?  Check [[#h:06290f9c-491c-45b2-b213-0248f890c83d][my Ibuffer entry]].

While there are customisation options for this tool, I find the defaults
to work as expected.  Note that the capitalisation of those symbols is
canonical.

#+begin_src emacs-lisp
(use-package man
  :bind (:map Man-mode-map
              ("i" . Man-goto-section)
              ("g" . Man-update-manpage)))
#+end_src

* History and state
:PROPERTIES:
:CUSTOM_ID: h:1d9437fe-1355-4c2f-8ea7-6668b4d0399b
:END:

This section contains configurations for packages that are dedicated to
the task of recording the state of various Emacs tools, such as the
history of the minibuffer or the list of recently visited files.

In practice, these are some of the most useful configurations one can
make, as lots of functions depend on them.  For example, a record of the
minibuffer's history of inputs allows the completion framework to guess
the most likely course of action.  Typing =M-x g= gives me =gnus= as the
first possible option, which is exactly what I want.

** Emacs server and desktop
:PROPERTIES:
:CUSTOM_ID: h:68d57dd2-4df1-4b7a-8766-231216e6cd9c
:END:

The following uses the first /running/ process of Emacs as the one others
may connect to.  This means that calling =emacsclient= (with or without
=--create-frame=), will share the same buffer list and data as the
original running process, aka "the server".  The server persists for as
long as there is an Emacs frame attached to it.

#+begin_src emacs-lisp
(use-package server
  :hook (after-init-hook . server-start))
#+end_src

With some exceptions aside, I only ever use Emacs in a single frame.
What I find more useful is the ability to save the state I was in: the
name the of buffers, the cursor's position in each of them, the recent
file list, the minibuffer history, my stored registers.

The state of the available buffers and the values of each register are
called the "desktop" (for the other items see the following sections on
[[#h:ab868c1a-7ca6-4f54-83d8-eab49447da82][recording various types of history]]).

Preserving the "desktop" saves me from any possible crash or when I need
to close Emacs and re-launch it later (my hardware is limited, so I do
not keep it running while I am away).

Overview of my settings:

+ Enable the mode that saves the "desktop", instructing it to load a
  small number of buffers at launch (=desktop-restore-eager=).  The
  remainder of the buffer list will be loaded lazily.
+ Now we must tell it where to store the files it generates and how
  often it should save.  Concerning the latter, the default is to
  store the state every time it changes.  I find that a bit too much,
  so I set a timeout of five minutes of idleness.
+ Note the =desktop-load-locked-desktop=.  By default, Emacs locks the
  desktop file while it runs.  The lock is removed upon exiting.  This
  is a safety mechanism.  There are two cases where the lock can create
  issues:
  + Emacs has crashed, meaning that it exited abruptly and was not able
    to unlock the desktop.  Upon re-launch Emacs will prompt you whether
    to load the locked file.  You normally want to answer affirmatively.
  + Emacs runs in daemon mode, where it does not ask questions upon
    loading.  In this case the lock is ignored.
  + Because I am only affected by the former, I choose to disable the
    prompt and just load the thing directly.  Otherwise, I would set it
    to =nil=.
+ Do not restore frame configurations.  If I need to store one of those,
  I use registers, specifically =C-x r f= (see [[#h:6bdfe4d1-f97a-4d89-ab68-e87448a95fea][section on Registers]]).
+ Ask what to do in case the session has a newer file that the one it
  initially started out with (e.g. when a new frame runs in parallel to
  the older one).

#+begin_src emacs-lisp
(use-package desktop
  :config
  (setq desktop-auto-save-timeout 300)
  (setq desktop-dirname "~/.emacs.d/")
  (setq desktop-base-file-name "desktop")
  (setq desktop-files-not-to-save nil)
  (setq desktop-globals-to-clear nil)
  (setq desktop-load-locked-desktop t)
  (setq desktop-missing-file-warning nil)
  (setq desktop-restore-eager 0)
  (setq desktop-restore-frames nil)
  (setq desktop-save 'ask-if-new)
  (desktop-save-mode 1))
#+end_src

And here we make sure that Emacs starts in the =*scratch*= buffer, no
matter what.

#+begin_src emacs-lisp
(use-package emacs
  :init
  (setq initial-buffer-choice t)
  (setq inhibit-startup-echo-area-message "prot") ; read the docstring
  (setq inhibit-startup-screen t)
  (setq inhibit-startup-buffer-menu t))
#+end_src

** Record various types of history
:PROPERTIES:
:CUSTOM_ID: h:ab868c1a-7ca6-4f54-83d8-eab49447da82
:END:
*** Minibuffer history (savehist-mode)
:PROPERTIES:
:CUSTOM_ID: h:2733674b-51f9-494e-b34d-e8842ac4ef96
:END:

Keeps a record of actions involving the minibuffer.  This is of
paramount importance to a fast and efficient workflow involving any
completion framework that leverages the built-in mechanisms.

Emacs will remember your input and choices and will surface the desired
results towards the top as the most likely candidates.  Make sure to
also read the [[#h:c110e399-3f43-4555-8427-b1afe44c0779][Minibuffer configurations and extras (prot-minibuffer.el)]].

#+begin_src emacs-lisp
(use-package savehist
  :config
  (setq savehist-file "~/.emacs.d/savehist")
  (setq history-length 1000)
  (setq history-delete-duplicates t)
  (setq savehist-save-minibuffer-history t)
  :hook (after-init-hook . savehist-mode))
#+end_src

*** Record cursor position
:PROPERTIES:
:CUSTOM_ID: h:ae1cad56-c12c-4bd5-a5cc-e85c0ad4b978
:END:

Just remember where the point is in any given file.  This can often be a
subtle reminder of what you were doing the last time you visited that
file, allowing you to pick up from there.

#+begin_src emacs-lisp
(use-package saveplace
  :config
  (setq save-place-file "~/.emacs.d/saveplace")
  (setq save-place-forget-unreadable-files t)
  (save-place-mode 1))
#+end_src

*** Backups
:PROPERTIES:
:CUSTOM_ID: h:3d2e3e65-b860-4ad7-87d2-24e4e9d0e296
:END:

And here are some settings pertaining to backups.  I rarely need those,
but I prefer to be safe in the knowledge that if something goes awry
there is something to fall back to.

#+begin_src emacs-lisp
(use-package emacs
  :config
  (setq backup-directory-alist
        '(("." . "~/.emacs.d/backup/")))
  (setq backup-by-copying t)
  (setq version-control t)
  (setq delete-old-versions t)
  (setq kept-new-versions 6)
  (setq kept-old-versions 2)
  (setq create-lockfiles nil))
#+end_src

* Frequently Asked Questions about this document
:PROPERTIES:
:CUSTOM_ID: h:4e73b827-cdf3-46a2-81c5-55b6e95701b7
:END:

There are some persistent questions that pop up in my email exchange, so
I thought I would cover them all in this section.

** How do you learn Emacs?
:PROPERTIES:
:CUSTOM_ID: h:83730fe8-d917-4d94-96f4-bbc5c900fe38
:END:

There is no one-size-fits-all approach to learning.  What one finds
satisfactory, another may consider insufficient.  In my opinion, the
best way to learn Emacs is to start small, be patient, and brace
yourself for a lot of reading and experimentation.

The best skill you can master, the one that will always help you in your
Emacs journey, is the built-in help system.  Learn to ask Emacs about
things you do not know about.  This section documents the essentials of
Emacs' /introspectable nature/.

Know that =C-h= is the universal key for help commands (broadly
understood).  It works both as a prefix and as a suffix.  Some common
help commands:

+ =C-h f= allows you to search for documentation about *functions*.
+ =C-h v= is the same for *variables*.
+ =C-h o= is a wrapper of the above two, so you are searching for
  functions *or* variables.  The proper name for any of these items is
  called a "symbol" (think of =name-of-thing= as symbolising a definition
  in the source code).
+ =C-h k= will prompt you for a *key* binding.  Once you type it in you will
  get help about what command corresponds to that key (if any).  Note
  that this depends on the major mode you are in.  For example =C-c C-c=
  does something different in Org and Eshell buffers.  Try =C-h k C-c C-c=
  to find about the different functions these will invoke in their
  respective major mode.
+ =C-h l= produces a log with your most recent key presses and the
  commands they call.  Emacs calls this the "lossage".  Ever mistyped
  something and got to the wrong place?  Use this as an opportunity to
  learn and, perhaps, a way to identify key sequences you would like to
  modify.  (*pro tip*: you can edit/convert your lossage into a keyboard
  macro with =C-x C-k l=---also watch [[https://protesilaos.com/codelog/2020-03-14-emacs-kmacro-edit/][Edit keyboard macros]] (2020-03-14)).

In the above scenaria we see how =C-h= is used as a prefix.  You are
starting a key sequence with it.  So here are some cases of using it as
a suffix:

+ For /every incomplete key sequence/ if you follow it up with =C-h= you
  will get a help buffer about all possible key combinations that
  complete that sequence.  For example, if you type =C-c C-h= inside of an
  Org buffer you will get all possible commands for Org mode and for all
  other minor modes you have active.
+ The =C-h= suffix can be appended to longer key sequences.  Indeed the
  length is irrelevant.  Suppose you want to learn more about some of
  the advanced features of registers.  =C-x r= is the common prefix for
  those commands, so you just do =C-x r C-h= and you get a buffer with
  more information.
+ And, as you may imagine, you can even append the =C-h= /suffix/ to the =C-h=
  /prefix/.  This is a fancy way of saying that =C-h C-h= will show you help
  about help commands themselves.  But because this is a special case,
  it comes with some extras.  Try it!

*All help buffers include links* to other parts of Emacs, from where you
can learn ever more information.  For example, the help for =C-c C-h=
includes links to the commands that correspond to each key chord.
Follow the link to get documentation about that symbol.

More generally, you will find that a symbol is linked to its source.
Look carefully at the top of the buffer that display symbol
documentation and you will find a link to the source code (library) from
where the function/variable (symbol) comes from.

Also know that the source code can be accessed at any time by means of
=M-x find-library=.

Help commands that ask you for a symbol to input can also be aware of
the context of the point (the cursor).  So if you are over the name of a
function and you type =C-h f=, that function will be the default match.
Hitting RET (Enter) will take you to its documentation.  /This is a great
way to study source code/, because it will guide you to other libraries
or other parts of the same library from where you can understand how
things are pieced together.  And it also works with the =find-library=
command.

Finally, you should practice =C-h m= as much as possible.  This is the
help command for getting information about the major mode you are in and
all the minor modes you have active.  It will show you some valuable
documentation as well as the main key bindings and their commands.  Try
it whenever you use something you have not mastered yet.  For example,
do it in a =dired= buffer to see the main operations you can perform
inside of it.

** What is the purpose of "prot/" and "contrib/"?
:PROPERTIES:
:CUSTOM_ID: h:0077f7e0-409f-4645-a040-018ee9b5b2f2
:END:

The =prot/= prefix in symbols works as a namespace that captures all my
additions.  These can be functions or variables.  Its utility or purpose
is two-fold:

1. It informs others that this symbol is not part of core Emacs or some
   other package.  Otherwise it can be difficult to understand why
   something you copied did not work.  Say, for example, I have a
   function that accepts an argument: =(prot/function prot/variable)=.  If
   none of these had the namespace you could be misled into thinking
   that your Emacs setup already includes those symbols (and then you
   will get an error message).
2. It makes it easier for me (and others) to quickly discover what
   additions I have made, for whatever reason that may.  For instance,
   =M-x prot/= will give me matches for all my interactive functions
   (depending on the completion framework, one can access those with
   just =M-x p/=).  This also means that I can do =M-x occur prot/= to
   produce an Occur buffer with all my symbols (pass a number argument
   for displaying N lines of context =C-u 5 M-s o=).  From there I can,
   say, browse them all easily or even edit them using all of Emacs'
   relevant powers (occur's results buffer is made editable with =e=, but
   you should be able to find that by using the information documented
   in [[*How do you learn
    Emacs?][How do you learn Emacs?]]).

The same principles apply for the =contrib/= namespace.  Whenever I copy
something from another user, I use that namespace to tell others that
this is not part of Emacs or any other package (and I always link to the
source).

Adding =contrib/= also has another longer-term benefit.  It tells my
future self that some bespoke configuration was needed to solve a
particular problem and, maybe, this has since been solved by a good
package or even a newer version of Emacs.  A case in point is the hook I
use for [[#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6][my themes]]: =contrib/after-load-theme-hook=.  As of 2020-05-03
there is no built-in way of accomplishing that bit of functionality (as
far as I know), but there may be one at some point and it might be an
improvement overall.

Again, =occur= or similar tools will filter these out when necessary.
Imagine having to do that without any namespaces…  You would need to
check each symbol one by one to determine its origin.

The convention of separating namespaces with a forward slash is not
particularly important, though the linter for Elisp packaging will
complain about it, if you ever go down that path.  It could be something
like =prot--= or =my-= or whatever.  What matters is to keep things
consistent and fairly easy to identify.

** Why not `:custom' and why do you use so many `setq'?
:PROPERTIES:
:CUSTOM_ID: h:ba373e0d-29d1-4224-b0f1-64b640ceeaae
:END:

I normally do not use the =:custom= keyword that =use-package= provides,
opting instead for =:config= or =:init=.  This is for a couple of
closely related reasons:

+ It makes each variable more difficult to copy elsewhere, say, when
  sharing it online or to an =emacs -Q= scratch buffer.  You either need
  to edit the balanced expression, or hope that users will know the
  syntax that the =:custom= keyword expects.
+ It is impossible to run =C-x C-e= (=eval-last-sexp=) on each balanced
  expression because it lacks the =setq= special form.  Again, this
  introduces an impediment to quick copy operations.

Now you may be wondering why I define each variable in its own balanced
expression.  To be clear, these are equivalent:

#+begin_example emacs-lisp
;; Style A
(setq var-1 'symbol)
(setq var-2 '(a b c))
(setq var-3 '((a . b) (c . d)))

;; Style B
(setq var-1 'symbol
      var-2 '(a b c)
      var-3 '((a . b) (c . d)))
#+end_example

You will notice that most of my configurations follow Style A.  The
reasons are the same as above: (i) copying, (ii) evaluating.

Style B used to give me more problems with copy-pasting, while it did
not solve any real issue (besides, I finalise style A using a keyboard
macro, so there is no real difference in typing).

I find that Style A consists of balanced expressions that are easier to
keep consistent.  This is especially true when you have a mixture of
values: boolean types, property lists, association lists…

Of course, experience is key to understanding that all these styles are
valid.

** Why do you explicitly set variables the same as default?
:PROPERTIES:
:CUSTOM_ID: h:3e4fefda-c069-4403-a2ad-6d77ee8c0914
:END:

You may have realised that many of my configurations will use a =setq=
that declares a value that is the same as its original in the source
code.  I do this for two reasons:

1. To raise awareness of its existence.  If someone does not like how
   the defaults work, they know where to look.
2. I guard against future versions that could be changing the defaults.

Obviously point 2 is not particularly strong for built-in libraries that
are already very stable, though I find that, on balance, nothing bad
comes out of it.

At any rate, one must always read the NEWS (=C-h n= for =view-emacs-news=)
whenever they upgrade to a new version of Emacs.  Though there is no
equivalent mechanism for individual packages…  So here we are.

** What is your distro and/or window manager?
:PROPERTIES:
:CUSTOM_ID: h:044977f2-a909-4804-bf89-576dd429d405
:END:

I have been on GNU/Linux since the summer of 2016.  For the most time I
have used Debian and Arch Linux, switching between the two.  As of
2020-05-03, I am back on Arch.  My criterion for picking a distro is
that it is community-driven and has a strong following that ensures its
longer-term continuity and overall stability.  This happens to be
consistent with my current focus on Emacs: I need things to work so that
I may not be bothered by too much admin work (and yes, Arch is
super-stable once you know what you are doing---and, well, Debian is
designed for that).

Given that I mostly live inside of Emacs, the desktop environment is no
longer important to me, provided it does not impede my usage of Emacs,
which practically means that it does /not bind any keys/ system-wide (with
the exception of some standard ones like those for accessing TTYs).

Prior to my Emacs days, I used to have a highly customised session
centred around BSPWM (the Binary Space Partitioning Window Manager),
while I also spent time with i3WM, DWM, Herbestluftwm.  The tiling
window manager paradigm offers little to no value now that practically
my entire computing experience happens inside of a single application.

My Emacs is [[https://git.savannah.gnu.org/cgit/emacs.git/tree/?h=emacs-27][built from source]], using the =master= branch.

** Did you know XYZ package is better than the defaults?
:PROPERTIES:
:CUSTOM_ID: h:a654fcb5-0163-4dc6-977a-8c50175118a1
:END:

As a rule of thumb, I choose external packages only after I give a fair
chance to the defaults.  The idea is to take things slowly and learn
along the way, while consulting the official manual and relevant
documentation (I strongly encourage you to master the information I
provide in [[#h:83730fe8-d917-4d94-96f4-bbc5c900fe38][How do you learn Emacs?]]).

Without exposure to the built-in tools it is impossible to make an
informed decision about what is actually missing and what could be
improved further.  Additionally, it is difficult to appreciate the
underlying rationale that led to a given element of design without
actually trying to put yourself in that mindset or workflow.

Put differently, keep an open mind about the alternatives before
deciding to reproduce the thing you had before, else you are assuming
your prior knowledge to be true in advance of any possible evidence to
the contrary (a sign of dogmatism).

The process of learning the internals of Emacs means that I write my own
Elisp functions when I feel that a standard tool could be tweaked on the
margin of its core utility in order to do what I want (see my answer to
[[#h:0077f7e0-409f-4645-a040-018ee9b5b2f2][What is the purpose of "prot/" and "contrib/"?]]).  External packages that
I do use are either a clear upgrade over the defaults or otherwise
extend the functionality of what is already available.

You will not find any superficialities herein: no rainbow-coloured mode
lines, no icons, no tool bars with bells and spinning wheels, nothing.
I respect the fact that they exist, but find that they do not contribute
to my productivity.

Though a former Vim user for ~3 years, I decided *not* to use =evil-mode= or
any kind of Vi emulation (remember the point about keeping an open
mind?).  I wanted to do things differently in order to ultimately set on
the best approach going forward.  I have eventually settled on a system
that builds on top of the "Emacs way" to key bindings, which I discuss
in my hour-long presentation about [[https://protesilaos.com/codelog/2019-12-20-vlog-switch-emacs/][Switching to Emacs]] (2019-12-20).  I
believe that a mnemonics-based set of keys is easier to get started
with.  It expands organically as you familiarise yourself with multitude
of Emacs' functionalities: there is an entire world of applications
outside the narrow confines of editing code.

** What is the meaning of the `s-KEY' bindings?
:PROPERTIES:
:CUSTOM_ID: h:fbba4dea-9cc8-4e73-bffa-02aab10a6703
:END:

Some sections of this document assign functions to key combinations that
involve the "Super" key (also known as the "Windows key" on some
commercial keyboards).  This is represented as a lower case =s=.

In most cases, those key bindings are alternative ways of invoking
/common commands/ that are by default bound to longer key chords.  The
original keys will continue to function as intended (for example, =C-x o=
is also =s-o=).  Otherwise they bind my own custom functions.

To find all my keybindings of this sort in the source code version of
this document from inside of Emacs, do =M-s o= (or =M-x occur=) followed by
the pattern ="[a-zA-Z<]?-?s-.+?"= (please contact me if you know how to
improve this).

Note that your choice of desktop environment (or window manager) might
render some of these useless.  The DE/WM will simply intercept the key
chord before it is ever sent to Emacs.  For example, GNOME has a *hidden*
key mapping to =s-p=, which does something with monitors (last time I
checked on GNOME 3.30).  Such bindings are scattered throughout the
config database that is normally accessed with =gsettings= on the command
line or the graphical =dconf-editor= (not pretty either way).

** What hardware do you use?
:PROPERTIES:
:CUSTOM_ID: h:e134a8b2-224e-4383-bf03-b080ab6659c7
:END:

I am using a Lenovo Thinkpad X220 that I got in 2018 for ~80 EUR.  This
is the first computer I ever bought: before that I had a Macbook that
was offered to me as part of an office job---but do not ask me about it
because at the time I only knew how to copy/paste using right click and
that sort of thing, while I only ever bothered with the hardware side of
things once I got better at using the computer (my switch to GNU/Linux
was about freedom and consumer sovereignty, i.e. politics, not tech-only
considerations).

The laptop is mostly deployed as part of a desktop setup, attached to an
external monitor, mouse, and keyboard.  The monitor is 1080p and I got
it free of charge from a clearance.  As for the mouse and keyboard, I
bought those from a toy store for 7 EUR combined.  The keyboard's layout
is US Qwerty.

For my videos I use the built-in camera and microphone (sorry if the
production quality is sub-standard!).  Since we are here: the recording
software is OBS Studio, while I do no video editing.
