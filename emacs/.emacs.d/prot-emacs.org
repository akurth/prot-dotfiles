#+TITLE: GNU Emacs package configuration file
#+AUTHOR: Protesilaos Stavrou
#+EMAIL: public@protesilaos.com
#+OPTIONS: toc:nil
#+STARTUP: content indent
#+MACRO: export-date (eval (format-time-string "%F %R %z" (current-time)))
#+MACRO: emacs-development-version (eval (substring (emacs-version) 0 17))

+ Created: 2019-08-15
+ Updated: *{{{export-date}}}*.
+ Emacs Version: {{{emacs-development-version}}}.
+ Git repository (part of my dotfiles for GNU/Linux):
  <https://gitlab.com/protesilaos/dotfiles>.
+ File history:
  <https://gitlab.com/protesilaos/dotfiles/-/commits/master/emacs/.emacs.d/prot-emacs.org>.
+ Just the =*.el= version of this file:
  <https://gitlab.com/protesilaos/dotfiles/-/commits/master/emacs/.emacs.d/prot-emacs.el>

#+TOC: headlines 8 insert TOC here, with eight headline levels

* Overview
:PROPERTIES:
:CUSTOM_ID: h:9ff13b78-42b8-49fe-9e23-0307c780de93
:END:
** Canonical links to this document
:PROPERTIES:
:CUSTOM_ID: h:0a9b72b3-aa4a-4c5c-a654-d4bc04b31bbd
:END:

+ HTML version :: <https://protesilaos.com/emacs/dotemacs>
+ Git repo :: <https://gitlab.com/protesilaos/dotfiles>

** What is this
:PROPERTIES:
:CUSTOM_ID: h:8cfd5674-4997-44c7-bb7a-1869d5d53538
:END:

The present document, referred to in the source code version as
=prot-emacs.org=, contains the bulk of my configurations for GNU Emacs.
It is designed using principles of "literate programming": a
combination of ordinary language and inline code blocks.  Emacs knows
how to parse this file properly so as to evaluate only the Elisp
("Emacs Lisp") included herein.  The rest is for humans to make sense
of my additions and their underlying rationale.

Literate programming allows us to be more expressive and deliberate.
Not only can we use typography to its maximum potential, but may also
employ techniques such as internal links between sections.  This makes
the final product much more useful for end users than, say, a terse
script.

Each section provides information about the code it contains.  In case
you feel something is missing, I maintain a [[#h:4e73b827-cdf3-46a2-81c5-55b6e95701b7][Frequently Asked Questions]]
section (when in doubt, or to offer feedback, suggestions, further
comments, etc., do [[https://protesilaos.com/contact][contact me]]).

In more practical terms, this document is written using =org-mode=.  It
contains all /package configurations/ for my Emacs setup.  To actually
work, it needs to be initialised from another file that only covers the
absolute essentials.

*** Main macros and other contents of my init.el (for Emacs 28)
:PROPERTIES:
:CUSTOM_ID: h:584c3604-55a1-49d0-9c31-abe46cb1f028
:END:

The =prot-emacs.org= is loaded from an other file, named =init.el= per the
Emacs conventions.  Mine includes some helper macros for package
configuration and is otherwise designed to initialise the package lists
and load the file with my configurations (i.e. the present document).

*Those macros are integral parts of my setup*, as they control the
configuration of all packages declared herein.  In particular:

+ =prot-emacs-builtin-package= is used for libraries that are either
  shipped with Emacs or are part of my dotfiles' directory.  The latter
  class consists of all those =prot-*.el= files, as well as a few others.
  What this macro does is to =require= the given feature and then evaluate
  all of its forms (variables, key bindings, hooks, etc.).

+ =prot-emacs-elpa-package= controls packages that I install from some
  Emacs Lisp Package Archive, like MELPA or GNU ELPA.  This macro will
  load the package if it is already installed and then evaluate all of
  its forms.  If the package is not installed, it will produce a warning
  telling the user that all the uninstalled-yet-declared packages can be
  downloaded in one go with the command =prot-emacs-install-ensured=
  (though read further below about auto-installing packages).

+ =prot-emacs-manual-package= handles the few packages that I install
  manually via their Git repository.  Each of those repos must be inside
  =(locate-user-emacs-file "contrib-lisp")= (typically available at
  =~/.emacs.d/contrib-lisp=).  The macro will load the package normally
  and configure it accordingly if it exists at the desired path, else it
  will log a warning about what file path it expects to read.  In
  concrete terms, if you want =package-A= you must first place all of its
  files at =~/.emacs.d/contrib-lisp/package-A=.

*I must stress that no package is automatically installed by default:* the
user is expected to do so on their own either by calling a command or by
providing their explicit consent to the auto-installation of packages
from Emacs Lisp Package Archives.  The idea is to avoid the malpractice
of installing software without asking the user to opt in to such a deal.
To actually instruct my declared packages to be installed automatically,
a user must create a new file called =basic-init.el=, place it in the same
directory as my =init.el= and =prot-emacs.org= and include in it this form:
=(setq prot-emacs-autoinstall-elpa t)=.

For more read: [[#h:0675f798-e2d9-4762-9df2-f47cd24cf00a][How to reproduce your dotemacs?]].

The =init.el= (reproduced further below) also sets some variables to their
desired values and provides a couple of functions that control the start
and end phases of my Emacs sessions.

+ =prot-emacs-build-config= is the final function from my part that runs
  before terminating the running Emacs process.  It regenerates my
  configurations and byte compiles the output.  This speeds things up
  the next time I launch Emacs, while it also ensures that I am always
  running the latest version of my setup.

+ =prot-emacs-load-config= will either load the output of the
  aforementioned function or, if that is not available, parse the
  literate program that holds my code (this Org file if you are viewing
  the source code or the document that produces the HTML of this web
  page).  Either way, it load my configurations.

#+include: init.el src emacs-lisp :tangle no

**** The "early init"
:PROPERTIES:
:CUSTOM_ID: h:874944d8-7ac0-4115-aa21-6ff4e005f6f6
:END:

Starting with Emacs 27.1, an =early-init.el= is required to control things
with greater precision.  My code is as follows:

#+include: early-init.el src emacs-lisp :tangle no

*** About the source code version of this document
:PROPERTIES:
:CUSTOM_ID: h:f738cdfc-a6ff-46cb-9962-31f754280af5
:END:

In the =org-mode= version of this document, I make sure that the
above-referenced code blocks are not declared as an =emacs-lisp= source
but rather as mere examples, so they are not accidentally parsed by the
actual setup.

Actual code blocks are wrapped between =#+begin_src= and =#+end_src= tags
(not visible in the website version of this page).  For Emacs 27.1,
such templates can be quickly inserted with =C-c C-,= (this works both
for empty blocks and active regions).  For more on the matter, refer
to [[#h:4e8347de-415e-4804-b383-d61499e05ca1][Org's section further below]].

As for the various settings included herein, you can learn /even more/
about them by using Emacs' built-in documentation facilities (also read
my note on [[#h:83730fe8-d917-4d94-96f4-bbc5c900fe38][How do you learn Emacs?]]).

Additionally, you will notice some metadata tags specific to =org-mode=
below each heading.  These are generated by the functions that are
defined in the package configurations for Org mode.  The idea is to keep
anchor tags consistent when generating a new HTML version of this
document.

This metadata also makes it possible to create immutable internal links,
whenever a reference is needed.  To create such links, you can use =C-c l=
to capture the unique ID of the current section and then =C-c C-l= to
create a link.

Consult the section on [[#h:4e8347de-415e-4804-b383-d61499e05ca1][Org-mode (personal information manager)]].

** COPYING
:PROPERTIES:
:CUSTOM_ID: h:1b9e6455-ba10-4683-88d4-738ecc41cdf6
:END:

Copyright (c) 2019-2021  Protesilaos Stavrou <info@protesilaos.com>

This file is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or (at
your option) any later version.

This file is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this file.  If not, see <http://www.gnu.org/licenses/>.

* Base settings
:PROPERTIES:
:CUSTOM_ID: h:4d42f3e3-e96f-4125-a819-0544a21d45f3
:END:

This section contains the relatively few configurations that are needed
prior to the setup of everything else.

** Common auxiliary functions (prot-common.el)
:PROPERTIES:
:CUSTOM_ID: h:c82dcbfa-97d0-4f7c-85af-768ce90f1372
:END:

There are a few utilities that I keep re-using in various parts of my
Emacs code base.  To keep things modular, I place them all in a
dedicated =prot-common.el= file, which can then be marked as a dependency
by other libraries of mine.  As such, all we do here is load the file.

#+begin_src emacs-lisp
;;; Common auxiliary functions (prot-common.el)
(prot-emacs-builtin-package 'prot-common)
#+end_src

And here is =prot-common.el= in its totality.  It is available as a file
in [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]] (same for all my Emacs libraries):

#+include: prot-lisp/prot-common.el src emacs-lisp :tangle no

** Common custom functions (prot-simple.el)
:PROPERTIES:
:CUSTOM_ID: h:ae48fe61-a3c3-4132-8986-785f9bfbeafb
:END:

=prot-simple.el= contains a wide range of commands that are broadly in
line with the built-in =simple.el= and =lisp.el= libraries.  While I could
offer an overview of each item in my library, I feel the code and
accompanying documentation strings are clear enough for you to peruse
the source directly (reproduced further below).

Still, here are some highlights for those who don't like studying the
source code:

+ =prot-simple-insert-pair= will surround either the symbol-at-point or
  the active region with a pair of delimiters.  It prompts for
  completion on which pair to use, while the most recently used entry
  becomes the default, so next time the user can just add it with =RET= at
  the minibuffer prompt.  With an optional prefix argument (=C-u=) it asks
  for how many times to insert the selected delimiters (e.g. you want to
  wrap two angled brackets around the region).

+ =prot-simple-scratch-buffer= produces a buffer with the major-mode of
  the current one.  With a prefix argument (=C-u=) it instead applies the
  major-mode which is stored in the user customisation option
  =prot-simple-scratch-buffer-default-mode=.  With a double prefix
  argument (=C-u C-u=) it prompts for completion on which major-mode to
  use.  If the region is active, its contents are copied to the newly
  created scratch buffer.  The idea is based on [[https://github.com/ieure/scratch-el][the scratch.el package]]
  by Ian Eure.

+ =prot-simple-copy-line-or-region= copies the current line or the region,
  if that is active.  With a prefix argument (=C-u=) it creates a
  duplicate of it right below.

All of the other commands are optimisations for common motions or little
quality-of-life improvements for oft-required operations (such as
transposition of objects or marking of balanced expressions).

Given that this is a foundational piece of my Emacs setup, it is the
appropriate place to re-bind or free up some common key combinations for
use elsewhere.

#+begin_src emacs-lisp
;;; Common custom functions (prot-simple.el)
(prot-emacs-builtin-package 'prot-simple
  (setq prot-simple-insert-pair-alist
        '(("' Single quote"        . (39 39))     ; ' '
          ("\" Double quotes"      . (34 34))     ; " "
          ("` Elisp quote"         . (96 39))     ; ` '
          ("‘ Single apostrophe"   . (8216 8217)) ; ‘ ’
          ("“ Double apostrophes"  . (8220 8221)) ; “ ”
          ("( Parentheses"         . (40 41))     ; ( )
          ("{ Curly brackets"      . (123 125))   ; { }
          ("[ Square brackets"     . (91 93))     ; [ ]
          ("< Angled brackets"     . (60 62))     ; < >
          ("« Εισαγωγικά Gr quote" . (171 187))   ; « »
          ("= Equals signs"        . (61 61))     ; = =
          ("~ Tilde"               . (126 126))   ; ~ ~
          ("* Asterisks"           . (42 42))     ; * *
          ("/ Forward Slash"       . (47 47))     ; / /
          ("_ underscores"         . (95 95))))   ; _ _
  (setq prot-simple-date-specifier "%F")
  (setq prot-simple-time-specifier "%R %z")
  (setq delete-pair-blink-delay 0.15) ; Emacs28 -- see `prot-simple-delete-pair-dwim'
  (setq prot-simple-scratch-buffer-default-mode 'markdown-mode)
  (setq help-window-select t)

  ;; ;; DEPRECATED 2021-10-15: set `help-window-select' to non-nil.
  ;; (setq prot-simple-focusable-help-commands
  ;;       '( describe-symbol
  ;;          describe-function
  ;;          describe-mode
  ;;          describe-variable
  ;;          describe-key
  ;;          describe-char
  ;;          what-cursor-position
  ;;          describe-package
  ;;          view-lossage))
  ;; (prot-simple-focus-help-buffers 1)

  (prot-simple-rename-help-buffers 1)

  ;; General commands
  (let ((map global-map))
    (define-key map (kbd "<insert>") nil)
    (define-key map (kbd "C-z") nil)
    (define-key map (kbd "C-x C-z") nil)
    (define-key map (kbd "C-h h") nil)
    (define-key map (kbd "M-`") nil)
    (define-key map (kbd "C-h .") #'prot-simple-describe-symbol) ; overrides `display-local-help'
    (define-key map (kbd "C-h K") #'describe-keymap) ; overrides `Info-goto-emacs-key-command-node'
    (define-key map (kbd "C-h c") #'describe-char) ; overrides `describe-key-briefly'
    (define-key map (kbd "C-c s") #'prot-simple-scratch-buffer)
    ;; Commands for lines
    (define-key map (kbd "C-S-w") #'prot-simple-copy-line-or-region)
    (define-key map (kbd "C-S-y") #'prot-simple-yank-replace-line-or-region)
    (define-key map (kbd "M-SPC") #'cycle-spacing)
    (define-key map (kbd "M-o") #'delete-blank-lines)   ; alias for C-x C-o
    (define-key map (kbd "M-k") #'prot-simple-kill-line-backward)
    (define-key map (kbd "C-S-n") #'prot-simple-multi-line-next)
    (define-key map (kbd "C-S-p") #'prot-simple-multi-line-prev)
    (define-key map (kbd "<C-return>") #'prot-simple-new-line-below)
    (define-key map (kbd "<C-S-return>") #'prot-simple-new-line-above)
    ;; Commands for text insertion or manipulation
    (define-key map (kbd "C-=") #'prot-simple-insert-date)
    (define-key map (kbd "C-<") #'prot-simple-escape-url)
    (define-key map (kbd "C-'") #'prot-simple-insert-pair)
    (define-key map (kbd "M-'") #'prot-simple-insert-pair)
    (define-key map (kbd "M-\\") #'prot-simple-delete-pair-dwim)
    (define-key map (kbd "C-M-;") #'prot-simple-cite-region)
    (define-key map (kbd "C-M-^") #'prot-simple-insert-undercaret)
    (define-key map (kbd "<C-M-backspace>") #'backward-kill-sexp)
    (define-key map (kbd "M-c") #'capitalize-dwim)
    (define-key map (kbd "M-l") #'downcase-dwim)        ; "lower" case
    (define-key map (kbd "M-u") #'upcase-dwim)
    ;; Commands for object transposition
    (define-key map (kbd "C-t") #'prot-simple-transpose-chars)
    (define-key map (kbd "C-x C-t") #'prot-simple-transpose-lines)
    (define-key map (kbd "C-S-t") #'prot-simple-transpose-paragraphs)
    (define-key map (kbd "C-x M-t") #'prot-simple-transpose-sentences)
    (define-key map (kbd "C-M-t") #'prot-simple-transpose-sexps)
    (define-key map (kbd "M-t") #'prot-simple-transpose-words)
    ;; Commands for marking objects
    (define-key map (kbd "M-@") #'prot-simple-mark-word)       ; replaces `mark-word'
    (define-key map (kbd "C-M-SPC") #'prot-simple-mark-construct-dwim)
    (define-key map (kbd "C-M-d") #'prot-simple-downward-list)
    ;; Commands for paragraphs
    (define-key map (kbd "M-Q") #'prot-simple-unfill-region-or-paragraph)
    ;; Commands for windows
    (define-key map (kbd "C-x n n") #'prot-simple-narrow-dwim) ; replaces `narrow-to-region'
    (define-key map (kbd "C-x M") #'prot-simple-monocle)
    ;; Commands for buffers
    (define-key map (kbd "M-=") #'count-words)
    (define-key map (kbd "<C-f2>") #'prot-simple-rename-file-and-buffer)
    (define-key map (kbd "C-x K") #'prot-simple-kill-buffer-current)))
#+end_src

These are the contents of the =prot-simple.el= library (find the file in
[[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]] (as with all my Elisp code)):

#+include: prot-lisp/prot-simple.el src emacs-lisp :tangle no

*** prot-pulse.el (highlight cursor position)
:PROPERTIES:
:CUSTOM_ID: h:6bbc41d6-da7c-4301-84c6-c5887c29283f
:END:

=pulse.el= is a library that provides utilities for highlighting the
region or area around point.  It is meant to be used by other packages
as a means of offering visual feedback, as is the case with, for
example, =M-.= (=xref-find-definitions=).

While =prot-pulse.el= (complete code further below) is a thin wrapper that
provides some extensions that are useful to my workflow.  Specifically,
it declares a new face and defines a command that implements it:
=prot-pulse-pulse-line=.  This is useful to quickly highlight the line and
buffer I am on, but can also be utilised by other tools that move the
point an arbitrary distance.

#+begin_src emacs-lisp
;;; prot-pulse.el (highlight cursor position)
(prot-emacs-builtin-package 'prot-pulse
  (setq prot-pulse-pulse-command-list
        '(recenter-top-bottom
          move-to-window-line-top-bottom
          reposition-window
          bookmark-jump
          other-window
          scroll-up-command
          scroll-down-command
          org-next-visible-heading
          org-previous-visible-heading
          org-forward-heading-same-level
          org-backward-heading-same-level
          org-tree-slide-move-next-tree
          org-tree-slide-move-previous-tree))
  (prot-pulse-advice-commands-mode 1)
  (define-key global-map (kbd "C-x l") #'prot-pulse-pulse-line)) ; override `count-lines-page'
#+end_src

This is the code for =prot-pulse.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]], in case
you wish to get the file):

#+include: prot-lisp/prot-pulse.el src emacs-lisp :tangle no

** Make Custom UI code disposable
:PROPERTIES:
:CUSTOM_ID: h:b24ce3fc-a12c-4d21-93d7-c1e7bd36a65d
:END:

When you install a package or use the various customisation interfaces
to tweak things to your liking, Emacs will append a piece of Elisp to
your init file.  In my experience, this is a common source of
inconsistencies, arising from a conflict between the user's code and
what is stored in that =custom-*= snippet.

To avoid conflicts, I instruct Emacs to put all "custom" code in a
temporary file (the =/tmp= path on Linux).  Custom does its work as
expected, but its state does not persist to mess up with my carefully
designed (and version-controlled) configuration.

This feels kinda hacky though it gets the job done.

Together with Justin Schell we had experimented with using the
=null-device= instead of a temporary file.  However, that created problems
under certain conditions, as Emacs would issue warnings about it and
prompt on how to proceed.

#+begin_src emacs-lisp
;;; Make Custom UI code disposable
(prot-emacs-builtin-package 'cus-edit
  ;; Disable the damn thing
  (setq custom-file (make-temp-file "emacs-custom-")))
#+end_src

** Propagation of shell environment variables (exec-path-from-shell.el)
:PROPERTIES:
:CUSTOM_ID: h:abe40d9f-e454-442a-9b9a-77e3b6c0b5db
:END:

Since 2021-09-21 I have been experimenting with Sway, a tiling window
manager for the Wayland display protocol.  One of the major changes to
how the older Xorg display server would handle the initialisation of the
environment is that Wayland does not have a login shell.  Instead,
programs are initialised by the session manager, which in my case is
controlled by systemd (check my dotfiles' git repo for the
technicalities).

To cut the long story short, Emacs needs to be made aware of the
environment variables that are available to my Bash shell but which
Wayland has obscured from this contexts.  Thankfully, Steve Purcell's
=exec-path-from-shell= handles the task splendidly.  In the user option
=exec-path-from-shell-variables= we specify the environment variables we
want to inform Emacs about.  Then we just invoke the function
=exec-path-from-shell-initialize= and are good to go.  Now we can get back
to using Emacs the way we did on Xorg.

Note that Steve's package is not specifically about Wayland.  Its
documentation makes references to other operating systems.

#+begin_src emacs-lisp
(prot-emacs-elpa-package 'exec-path-from-shell
  (setq exec-path-from-shell-variables
        '("PATH" "MANPATH" "SSH_AUTH_SOCK"))
  (exec-path-from-shell-initialize))
#+end_src

** Modus themes (my highly accessible themes)
:PROPERTIES:
:CUSTOM_ID: h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6
:END:

This is a project I started as soon as I switched to Emacs in July 2019.
About a year later the themes became part of upstream Emacs, available
for Emacs version 28 (as of version 0.12.0 of the themes).  I have
benefited a lot from community contributions, of which I am most
thankful of, as discussed in [[https://protesilaos.com/codelog/2020-08-27-emacs-modus-themes-core/][My Modus themes are now shipped with Emacs]]
(2020-08-27).

The Modus themes are designed for accessible readability.  They conform
with the highest standard for colour contrast between foreground and
background values.  This stands for a minimum contrast ratio of 7:1,
also known as the WCAG AAA standard (the highest of its kind).

The themes are "Modus Operandi" (light) and "Modus Vivendi" (dark).  The
source code is available [[https://gitlab.com/protesilaos/modus-themes][on their GitLab page]] while you can read the
HTML version of [[https://protesilaos.com/emacs/modus-themes][their manual on my website]].  If you have the package
installed or are using Emacs >=28, you can read the manual from the
built-in Info reader.  Evaluate: =(info "(modus-themes) Top")=.

The manual covers everything from the basics to more advanced,
"do-it-yourself" cases.

The list of supported packages is comprehensive and a lot of work goes
into getting the details right.  Plus, there are *lots of customisation
options* to tweak the looks of the themes (note though that the values I
set for those variables in the following code block are not indicative
of my preferences, as I always try different combinations to test things
across a range of scenaria).

Lastly, if you are curious about the underlying methodology, read my
essay [[https://protesilaos.com/codelog/2020-03-17-design-modus-themes-emacs/][on the design of the Modus themes]] (2020-03-17).  And here are some
more resources from my website for those who are really into the minutia
and wish to get a glimpse of how much work goes into this project:

+ [[https://protesilaos.com/codelog/2020-05-10-modus-operandi-palette-review/][Modus Operandi theme subtle palette review]] (2020-05-10)
+ [[https://protesilaos.com/codelog/2020-06-13-modus-vivendi-palette-review/][Modus Vivendi theme subtle palette review]] (2020-06-13)
+ [[https://protesilaos.com/codelog/2020-07-04-modus-themes-faint-colours/][Modus themes: new "faint syntax" option]] (2020-07-04)
+ [[https://protesilaos.com/codelog/2020-07-08-modus-themes-nuanced-colours/][Modus themes: major review of "nuanced" colours]] (2020-07-08)
+ [[https://protesilaos.com/codelog/2020-08-09-modus-themes-paren-match/][Modus themes: review "paren-match" colours]] (2020-08-09)
+ [[https://protesilaos.com/codelog/2020-08-28-notes-emacs-theme-devs/][Notes for aspiring Emacs theme developers]] (2020-08-28)
+ [[https://protesilaos.com/codelog/2020-09-14-modus-themes-review-blues/][Modus themes: report on the review of the main blue colours]] (2020-09-14)
+ [[https://protesilaos.com/codelog/2020-12-27-modus-themes-review-rainbow-delimiters/][Modus themes: review rainbow-delimiters faces]] (2020-12-27)
+ [[https://protesilaos.com/codelog/2021-01-11-modus-themes-review-select-faint-colours/][Modus themes: review of select "faint" colours]] (2021-01-11)
+ [[https://protesilaos.com/codelog/2021-02-25-modus-themes-diffs-deuteranopia/][The Modus themes now cover deuteranopia in diffs]] (2021-02-25)
+ [[https://protesilaos.com/codelog/2021-05-19-modus-themes-status-update/][Status update on the Modus themes for Emacs]] (2021-05-19)
+ [[https://protesilaos.com/codelog/2021-06-02-modus-themes-org-agenda/][Introducing the variable modus-themes-org-agenda]] (2021-06-02)
+ [[https://protesilaos.com/codelog/2022-01-02-review-modus-themes-org-habit-colours/][Modus themes: review of the org-habit graph colours]] (2022-01-02)
+ [[https://protesilaos.com/codelog/2022-01-03-modus-themes-port-faq/][Re: VSCode or Vim ports of the Emacs modus-themes?]] (2022-01-03)

And if you do enjoy reading such entries, then you may also wish to
check the [[https://protesilaos.com/emacs/modus-themes-changelog/][Change Log of the Modus themes]].

#+begin_src emacs-lisp
;;; Modus themes (my highly accessible themes)
(prot-emacs-builtin-package 'modus-themes
  ;; Add all your customizations prior to loading the themes
  ;;
  ;; NOTE: these are not my preferences!  I am always testing various
  ;; configurations.  Though I still like what I have here.
  (setq modus-themes-italic-constructs nil
        modus-themes-bold-constructs nil
        modus-themes-mixed-fonts nil
        modus-themes-subtle-line-numbers t
        modus-themes-intense-markup t
        modus-themes-deuteranopia nil
        modus-themes-tabs-accented nil
        modus-themes-variable-pitch-ui nil
        modus-themes-inhibit-reload t ; only applies to `customize-set-variable' and related

        modus-themes-fringes nil ; {nil,'subtle,'intense}

        ;; Options for `modus-themes-lang-checkers' are either nil (the
        ;; default), or a list of properties that may include any of those
        ;; symbols: `straight-underline', `text-also', `background',
        ;; `intense' OR `faint'.
        modus-themes-lang-checkers nil

        ;; Options for `modus-themes-mode-line' are either nil, or a list
        ;; that can combine any of `3d' OR `moody', `borderless',
        ;; `accented', and a natural number for extra padding
        modus-themes-mode-line '(borderless 4)

        ;; Options for `modus-themes-syntax' are either nil (the default),
        ;; or a list of properties that may include any of those symbols:
        ;; `faint', `yellow-comments', `green-strings', `alt-syntax'
        modus-themes-syntax nil

        ;; Options for `modus-themes-hl-line' are either nil (the default),
        ;; or a list of properties that may include any of those symbols:
        ;; `accented', `underline', `intense'
        modus-themes-hl-line nil

        ;; Options for `modus-themes-paren-match' are either nil (the
        ;; default), or a list of properties that may include any of those
        ;; symbols: `bold', `intense', `underline'
        modus-themes-paren-match '(intense underline bold)

        ;; Options for `modus-themes-links' are either nil (the default),
        ;; or a list of properties that may include any of those symbols:
        ;; `neutral-underline' OR `no-underline', `faint' OR `no-color',
        ;; `bold', `italic', `background'
        modus-themes-links nil

        ;; Options for `modus-themes-prompts' are either nil (the
        ;; default), or a list of properties that may include any of those
        ;; symbols: `background', `bold', `gray', `intense', `italic'
        modus-themes-prompts nil

        modus-themes-completions nil ; {nil,'moderate,'opinionated}

        modus-themes-mail-citations nil ; {nil,'faint,'monochrome}

        ;; Options for `modus-themes-region' are either nil (the default),
        ;; or a list of properties that may include any of those symbols:
        ;; `no-extend', `bg-only', `accented'
        modus-themes-region '(no-extend)

        ;; Options for `modus-themes-diffs': nil, 'desaturated, 'bg-only
        modus-themes-diffs nil

        modus-themes-org-blocks nil ; {nil,'gray-background,'tinted-background}

        modus-themes-org-agenda ; this is an alist: read the manual or its doc string
        '((header-block . (variable-pitch regular 1.4))
          (header-date . (bold-today grayscale underline-today 1.2))
          (event . (accented varied))
          (scheduled . uniform)
          (habit . nil))

        modus-themes-headings nil ; this is an alist: read the manual or its doc string

        ;; ;; For example:
        ;; modus-themes-headings
        ;; '((1 . (variable-pitch light 1.8))
        ;;   (2 . (variable-pitch regular 1.6))
        ;;   (3 . (variable-pitch regular 1.3))
        ;;   (4 . (monochrome 1.2))
        ;;   (5 . (1.1))
        ;;   (t . (rainbow 1.05)))
        )

  ;; Load the theme files before enabling a theme (else you get an error).
  (modus-themes-load-themes)

  ;; Custom faces (for demo purposes---check the themes' manual for more
  ;; advanced uses).
  (defun prot/modus-themes-custom-faces ()
    (modus-themes-with-colors
      (custom-set-faces
       `(fill-column-indicator ((,class :background ,bg-inactive
                                        :foreground ,bg-inactive))))))

  (add-hook 'modus-themes-after-load-theme-hook #'prot/modus-themes-custom-faces)

  ;; Enable the theme at startup.  This is done after loading the files.
  ;; You only need `modus-themes-load-operandi' for the light theme or
  ;; `modus-themes-load-vivendi' for the dark one.  What I have here is
  ;; a simple test to load a light/dark theme based on some general time
  ;; ranges (just accounting for the hour and without checking for the
  ;; actual sunrise/sunset times).  Plus we have `modus-themes-toggle'
  ;; to switch themes at will.
  (let ((time (string-to-number (format-time-string "%H"))))
    (if (and (> time 5) (< time 18))
        (modus-themes-load-operandi)
      (modus-themes-load-vivendi)))

  ;; Also check my package configurations for `prot-fonts' because I use
  ;; the `modus-themes-after-load-theme-hook' for some typeface-related
  ;; tweaks (as those are made at the "face" level).
  (define-key global-map (kbd "<f5>") #'modus-themes-toggle))
#+end_src

** LIN Is Noticeable (lin.el)
:PROPERTIES:
:CUSTOM_ID: h:601027a1-7288-4dcd-bb78-435965df27ba
:END:

This is another package of mine.  LIN locally remaps the =hl-line= face to
a style that is optimal for major modes where line selection is the
primary mode of interaction.

The idea is that =hl-line= cannot work equally well for contexts with
competing priorities: (i) line selection, or (ii) simple line highlight.
In the former case, the current line needs to be made prominent because
it carries a specific meaning of some significance in the given context.
Whereas in the latter case, the primary mode of interaction does not
revolve around the line highlight itself: it may be because the focus is
on editing text or reading through the buffer's contents, so the current
line highlight is more of a gentle reminder of the point's location on
the vertical axis.

=lin-mode= only shows its effect when =hl-line-mode= is active or, more
specifically, when the =hl-line= face is used in the buffer.  =lin-mode=
DOES NOT activate =hl-line-mode= and does not do anything other than the
aforementioned face remapping.

I just enable LIN in contexts where I know it is useful (check the doc
string o =lin-add-to-many-modes= for the details).  For example:

+ [[#h:0cd8ddab-55d1-40df-b3db-1234850792ba][Elfeed feed reader, prot-elfeed.el and prot-elfeed-bongo.el]].
+ [[#h:a196812e-1644-4536-84ba-687366867def][Notmuch (mail indexer and mail user agent (MUA))]].

#+begin_src emacs-lisp
(prot-emacs-builtin-package 'lin
  (setq lin-foreground-override nil)
  (setq lin-foreign-hooks lin--default-foreign-hooks)
  (lin-add-to-many-modes))
#+end_src

** Typeface configurations
:PROPERTIES:
:CUSTOM_ID: h:7a4dd5b8-724d-4f7c-b5ee-01d8ac98bda9
:END:
*** Font configurations (prot-fonts.el)
:PROPERTIES:
:CUSTOM_ID: h:e03b6415-a18f-4058-b9b0-5721d38c6c50
:END:

Any font I choose must conform with the following:

+ support Latin and Greek character sets;
+ be readable at small sizes and look okay at large sizes;
+ offer both roman and italic variants, preferably with corresponding
  bold weights;
+ not be too thin or at least have multiple weights from which to choose
  from;
+ not have too short of an x-height, which makes combinations of text
  and numbers or delimiters somewhat unbalanced;
+ not have a name that directly advertises some brand (e.g. "Helvetica"
  is fine as a name, even though a certain corporation tried to be
  identified with it; but "CORPORATION Sans" is not);
+ not be flamboyant by seeking to call too much attention to its
  details or by exaggerating some glyph shapes;
+ be equally readable against light and dark backdrops (for instance,
  bitmap fonts are not legible on a white background---too bad because I
  really like Terminus);
+ use the =*.ttf= spec which yields the best results on GNU/Linux.

While there are many good free/libre options available, only a handful
of them cover my fairly demanding needs.  Some look good at large point
sizes.  Others lack Greek characters.  Some do not have italics...
Getting it right is very difficult.

The only font I could use over the years was Hack, which builds on the
skeleton of DejaVu Sans Mono.  Though there are issues with the default
version of Hack which I do not like, such as the default shape of the
zero and one numbers, the small shape of the backtick character...
Little things which keep annoying me.  My [[https://gitlab.com/protesilaos/hack-font-mod][custom build of Hack]] uses some
alternative glyphs from a variety of sources that alleviate most of
those problems (though it obviously cannot alter the overall character
of the typeface).

Moving on to my configurations, =prot-fonts.el= covers my elaborate
typeface requirements.  At its heart is =prot-fonts-typeface-sets-alist=.
It contains associations of property lists (an alist of plists), each of
which pertains to a give display type.  For example, when I am doing a
video presentation, I require font configurations that differ from what
I normally use.  So I have a =large= key in the alist to accommodate that
particular need.  Those associations provide granular control over font
attributes, as they specify both mono and proportionately spaced font
families, each with their corresponding weights and heights.

The command =prot-fonts-set-fonts= prompts with completion for a display
type.  It gives options like =small=, =regular=, =large=, which are drawn from
the =prot-fonts-typeface-sets-alist= (more on completion in the section
[[#h:98d3abcc-f34e-4029-aabc-740f0b6421f8][Completion framework and extras]]).  When called from Lisp it expects a
=DISPLAY= argument, which is a symbol that matches the car of a cons cell
in the aforementioned alist.

=prot-fonts-fonts-per-monitor= is not useful with my current hardware, as
I had designed it when I had a laptop (see [[#h:e134a8b2-224e-4383-bf03-b080ab6659c7][What hardware do you use?]]).
Still, the idea is interesting and I keep it around in case someone has
a need for it.  It sets the appropriate font family and size depending
on whether the maximum width of the monitor is below a certain threshold
defined in =prot-fonts-max-small-resolution-width=.  So it will use the
two first presets defined in the aforementioned alist, with the
assumption that the first is the smallest, laptop-specific one.

As noted above, =prot-fonts-typeface-sets-alist= associates a list of
typefaces with desired weights, including for their bold variation.
This is useful when the active theme (e.g. [[#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6][my Modus themes]]) is designed
in a way that parameterises or abstracts the exact value of a bold
weight, by calling =:inherit bold= instead of specifying =:weight bold=.
The former applies the attributes of the =bold= face, whereas the latter
sets the weight at a constant value.  When the theme is designed that
way, we can configure the =:weight= of the =bold= face to, e.g., =extrabold=
and have that propagate across all the faces that the theme defines.

Now a few general notes about setting fonts in Emacs.

While there are many ways to define a baseline or fallback font family,
I find that the most consistent one in terms of overall configuration is
to do it at the "face" level (read the docstring of =set-face-attribute=).
Faces are understood as the domain of themes, though themes are just
Elisp programs so there is no real distinction here and it is perfectly
fine to have one program define some properties of a face while another
specifies a few others.  The key is to make those complementary.  Put
concretely, =prot-fonts.el= sets properties such as =:family=, while my
themes handle things like colours.

To appreciate this point, consider that in Emacs parlance a "face"
signifies a construct that bundles up together several display
attributes, such as a foreground and a background colour, as well as all
typography-related values.  Multiple assignments are stacked, unless one
new attribute explicitly overrules an existing one.

There are three faces that are of immediate interest to =prot-fonts.el=:
the =default=, =variable-pitch=, and =fixed-pitch=.  The first is the Emacs
frame's main typeface, the second specifies a proportionately spaced
font, and the third does the same for a monospaced family.  There are
various scenaria where text on display needs to be rendered in
=variable-pitch=, while others must remain in =fixed-pitch=.  For example,
let =org-mode= inline code be presented in its monospaced font while using
a variable width typeface for the main text, or just use =variable-pitch=
for User Interface elements such as the mode line to economise on
spacing, and so on.  Again, my Modus themes cover that niche
out-of-the-box (and offer relevant customisation options).  We call this
a "mixed font" setup: the easiest way to get to it is to enable
=variable-pitch-mode= (read: [[#h:77d14350-978d-4820-ab7f-4641706c445a][Extensions for "focus mode" (prot-logos.el)]]).

Relevant publications of mine that are not part of this document:

+ [[https://protesilaos.com/codelog/2020-08-28-notes-emacs-theme-devs/][Notes for aspiring Emacs theme developers]] (2020-08-28).
+ [[https://protesilaos.com/codelog/2020-09-05-emacs-note-mixed-font-heights/][Emacs: note on mixed font heights]] (2020-09-05).
+ [[https://protesilaos.com/emacs/modus-themes/#h:defcf4fc-8fa8-4c29-b12e-7119582cc929][Modus themes' manual on font configurations]].

#+begin_src emacs-lisp
;;; Font configurations (prot-fonts.el)
(prot-emacs-builtin-package 'prot-fonts
  ;; This is defined in Emacs C code: it belongs to font settings.
  (setq x-underline-at-descent-line t)

  ;; And this is for Emacs28.
  (setq-default text-scale-remap-header-line t)

  ;; Make sure to read the `prot-fonts-typeface-sets-alist' doc string,
  ;; as it explains what those property lists should contain.
  ;;
  ;; The version of "Hack" that I custom is a custom build on mine:
  ;; <https://gitlab.com/protesilaos/hack-font-mod>.  Same principle for
  ;; Iosevka: <https://gitlab.com/protesilaos/iosevka-comfy>.
  (setq prot-fonts-typeface-sets-alist
        '((small . ( :fixed-pitch-family "Hack"
                     :fixed-pitch-regular-weight regular
                     :fixed-pitch-heavy-weight bold
                     :fixed-pitch-height 75
                     :fixed-pitch-line-spacing 1
                     :variable-pitch-family "FiraGO"
                     :variable-pitch-height 1.05
                     :variable-pitch-regular-weight normal))

          (regular . ( :fixed-pitch-family "Hack"
                       :fixed-pitch-regular-weight regular
                       :fixed-pitch-heavy-weight bold
                       :fixed-pitch-height 90
                       :fixed-pitch-line-spacing nil
                       :variable-pitch-family "FiraGO"
                       :variable-pitch-height 1.05
                       :variable-pitch-regular-weight normal))

          (large . ( :fixed-pitch-family "Hack"
                     :fixed-pitch-regular-weight normal
                     :fixed-pitch-heavy-weight bold
                     :fixed-pitch-height 130
                     :fixed-pitch-line-spacing nil
                     :variable-pitch-family "FiraGO"
                     :variable-pitch-height 1.05
                     :variable-pitch-regular-weight normal))

          (large-alt . ( :fixed-pitch-family "Iosevka Comfy"
                         :fixed-pitch-regular-weight book
                         :fixed-pitch-heavy-weight extrabold
                         :fixed-pitch-height 135
                         :fixed-pitch-line-spacing nil
                         :variable-pitch-family "Noto Sans"
                         :variable-pitch-height 1.0
                         :variable-pitch-regular-weight normal))))

  ;; TODO 2021-08-27: I no longer have a laptop.  Those configurations
  ;; are not relevant, but I keep them around as the idea is still good.

  ;; The value of `prot-fonts-laptop-desktop-keys-list' becomes '(small
  ;; regular) based on the car of the first two cons cells found in
  ;; `prot-fonts-typeface-sets-alist'.  The assumption is that those
  ;; contain sets from smaller to larger display types.
  (setq prot-fonts-laptop-desktop-keys-list
        (prot-fonts-laptop-desktop-keys))

  ;; This is the breakpoint, in pixels, for determining whether we are
  ;; on the small or large screen layout.  The number here is my
  ;; laptop's screen width, while it expands beyond that when I connect
  ;; it to an external monitor (how I normally set it up on my desk).
  (setq prot-fonts-max-small-resolution-width 1366)

  ;; And this just sets the right font depending on whether my laptop is
  ;; connected to an external monitor or not.
  (prot-fonts-fonts-per-monitor)

  ;; See theme section for this hook and also read the doc string of
  ;; `prot-fonts-restore-last'.
  (add-hook 'modus-themes-after-load-theme-hook #'prot-fonts-restore-last)

  (define-key global-map (kbd "C-c f") #'prot-fonts-set-fonts))
#+end_src

This is the source code of =prot-fonts.el= (you can always find the file
if you directly clone [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]).

#+include: prot-lisp/prot-fonts.el src emacs-lisp :tangle no

*** Simple font suitability test
:PROPERTIES:
:CUSTOM_ID: h:9035a1ed-e988-4731-89a5-0d9e302c3dea
:END:

Here is a test I have come up with to make an initial assessment of the
overall quality of a monospaced font that is meant to work well in a
programming context: /can you discern each character at a quick glance?/
If yes, your choice of typeface is good /prima facie/, otherwise search
for something else.

Note that this test is not perfect, since many typefaces fall short in
less obvious ways, such as the space between the characters.  Also note
that the website version of this document may not accurately represent
the typeface I am using.

#+begin_example
()[]{}<>«»‹›
6bB8&
0ODdoaoOQGC
I1tilIJL|
!¡ij
5$§SsS5
17ZzZ2
9gqpG6
hnmMN
uvvwWuuwvy
x×X
.,·°%
¡!¿?
:;
`''"‘’“”
—-~≈=≠+*_
…⋯
...

Sample character set
Check for monospacing and Greek glyphs

ABCDEFGHIJKLMNOPQRSTUVWXYZ
abcdefghijklmnopqrstuvwxyz
0123456789
~!@#$%^&*+
`'"‘’“”.,;:…
()[]{}—-_=|<>/\
ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩ
αβγδεζηθικλμνξοπρστυφχψω

// NOTE that I got this from Hack's website:
// https://source-foundry.github.io/Hack/font-specimen.html
//  The four boxing wizards jump
#include <stdio.h> // <= quickly.
int main(int argc, char **argv) {
  long il1[]={1-2/3.4,5+6==7/8};
  int OxFaced=0xBAD||"[{(CQUINE";
  unsigned O0,l1,Z2,S5,G6,B8__XY;
  printf("@$Hamburgefo%c`",'\n');
  return ~7&8^9?0:l1|!"j->k+=*w";
}
#+end_example

** Repeatable key chords (repeat-mode)
:PROPERTIES:
:CUSTOM_ID: h:33d9a35a-54ed-4f9d-8f30-5c99c1a45ad0
:END:

Emacs28 comes with a built-in utility for repeating selected commands in
a more convenient fashion.  Once =repeat-mode= is enabled, a key binding
or chord that invokes a command successfully can be repeated by typing
in its tail or whatever the developer specifies.  So =other-window= may be
used like this: =C-x o=, =o=, =o= to switch three windows, instead of =C-x o=,
=C-x o=, =C-x o=.

This is achieved by furnishing transient keymaps that get activated
right after the command they belong to and only once the command in
question has been added to the =repeat-map=.  Here is a sample from
=window.el=:

#+begin_example emacs-lisp
(defvar resize-window-repeat-map
  (let ((map (make-sparse-keymap)))
    ;; Standard keys:
    (define-key map "^" 'enlarge-window)
    (define-key map "}" 'enlarge-window-horizontally)
    (define-key map "{" 'shrink-window-horizontally) ; prot note: those three are C-x KEY
    ;; Additional keys:
    (define-key map "v" 'shrink-window) ; prot note: this is not bound by default
    map)
  "Keymap to repeat window resizing commands.  Used in `repeat-mode'.")
(put 'enlarge-window 'repeat-map 'resize-window-repeat-map)
(put 'enlarge-window-horizontally 'repeat-map 'resize-window-repeat-map)
(put 'shrink-window-horizontally 'repeat-map 'resize-window-repeat-map)
(put 'shrink-window 'repeat-map 'resize-window-repeat-map)
#+end_example

Once the keymap exists and its commands are in the =repeat-map=, such as
with the above example, we do not have to recreate the entire setup if
all we need is to change key bindings: we just have to rebind the
commands to where it makes sense for us.  I actually do this for
=resize-window-repeat-map= ([[#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][Window rules and basic tweaks (window.el)]]).

At any rate, all we need here is to activate =repeat-mode= and then
implement the repetition mechanism wherever we want.

The =repeat= command is bound by default to =C-x z=, with =s-z= serving as my
alias for it (read [[#h:fbba4dea-9cc8-4e73-bffa-02aab10a6703][What is the meaning of the `s-KEY' bindings?]]).  With
the two variables I set in the following configurations, I make it so
that subsequent repetitions require only hitting another =z=.  Depending
on what you do, a =repeat= can save you from multiple key presses.  For
more demanding tasks you are better off with keyboard macros.

*Pro tip:* to make a keyboard macro out of your most recent commands, use
=C-x C-k l= which calls =kmacro-edit-lossage=.  The list is editable, so
remove any line that is not required and then save what is left.  The
result is stored as the latest keyboard macro (and you also have the
power to cycle through kmacros, store them in specific keys, etc.).

Moving on to the mark, which is affected by =set-mark-command-repeat-pop=,
practically every Emacs motion that operates on a portion of text will
set the mark automatically.  You can also do it manually with =C-SPC= (hit
it twice if you do not wish to activate the region).  It is then
possible to cycle through the marks in reverse order by passing a prefix
argument =C-u C-SPC=.  With =set-mark-command-repeat-pop= we can continue
cycling by repeated presses of =C-SPC=.  Again though, this is not the
type of functionality I rely on: for more deliberate actions of this
sort, consider Emacs' registers or bookmarks.

#+begin_src emacs-lisp
;;; Repeatable key chords (repeat-mode)
(prot-emacs-builtin-package 'repeat
  (setq repeat-on-final-keystroke t)
  (setq set-mark-command-repeat-pop t)

  (repeat-mode 1))
#+end_src

** Handle performance for very long lines (so-long.el)
:PROPERTIES:
:CUSTOM_ID: h:1d0e8ab3-d779-41d4-b478-d735dc3ad7ae
:END:

When you visit a file with very long lines, such as a minified
javascript on a web page's source, Emacs will have trouble fontifying
everything properly and performance will suffer as a result.  We can
prevent Emacs from even attempting to deal with such longs lines by
enabling the built-in =global-so-long-mode= (for Emacs versions >= 27).
It allows the active major mode to gracefully adapt to buffers with very
long lines.  What "very long" means is, of course, configurable: invoke
=M-x find-library= and search for =so-long= to find several customisation
options (declared with =defcustom=).  Personally, I find that the defaults
require no further intervention from my part.

#+begin_src emacs-lisp
;;; Handle performance for very long lines (so-long.el)
(prot-emacs-builtin-package 'so-long
  (global-so-long-mode 1))
#+end_src

* Selection candidates and search methods
:PROPERTIES:
:CUSTOM_ID: h:5c060e2e-231d-4896-a5d2-b3fb4134764e
:END:
** Completion framework and extras
:PROPERTIES:
:CUSTOM_ID: h:98d3abcc-f34e-4029-aabc-740f0b6421f8
:END:

Unlike the desktop metaphor, the optimal way to use Emacs is through
searching and narrowing selection candidates.  Spend less time worrying
about where things are on the screen and more on how fast you can bring
them into focus.  This is, of course, a matter of realigning priorities,
as we still wish to control every aspect of the interface, as we do
elsewhere in this document.

To get a sense of my current completion framework, watch my presentation
on [[https://protesilaos.com/codelog/2021-01-06-emacs-default-completion/][Default Emacs completion and extras]] (2021-01-06).  There have been
some changes since then, but the core idea stands.

*** Orderless completion style (and prot-orderless.el)
:PROPERTIES:
:CUSTOM_ID: h:7b1374dd-6b1f-4548-8fbf-1034230c80e0
:END:

The, dare I say, /sublime/ [[https://github.com/oantolin/orderless][“orderless” package]] is developed by Omar
Antolín Camarena.  It provides the =orderless= completion style for
efficient, out-of-order grouped pattern matching.  The components can be
determined using several styles, such as regexp, flex, prefix,
initialism (check its README because there are lots of variations).
Delimiters are literal spaces by default, but can be configured to match
other characters, with hyphens and slashes being likely choices.  As
such, Orderless can supersede---and for most part improve upon---the
completion styles that come built into Emacs, adding to them the
powerful out-of-order capability.

All we do here is set up Orderless.  The =orderless= completion style is
appended to the minibuffer's customisation option for =completion-styles=.
That is defined in [[#h:c110e399-3f43-4555-8427-b1afe44c0779][Minibuffer configurations and extras]].

My =prot-orderless.el= contains the few minor tweaks I introduce (full
code further below).

1. It defines three style dispatchers. Those are single characters that
   acquire a special meaning while at the end of a given input:

   - With the equals sign appended to a sequence of characters, we call
     =prot-orderless-literal-dispatcher= which instructs orderless to match
     that sequence as a literal string.

   - A comma at the end of a string of characters treats that group as
     an initialism, per =prot-orderless-initialism-dispatcher=.

   - While a tilde (=prot-orderless-flex-dispatcher=) makes it makes it a
     flex match.

2. =prot-orderless-with-styles= is a function that changes the default
   pattern-matching styles on a per-command basis.  The idea is to use a
   certain style for most completion sessions, but prioritise an
   alternative when needed.  I use this with some Consult commands
   ([[#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb][Enhanced minibuffer commands (consult.el and prot-consult.el)]]).  The
   =prot-orderless-default-styles= and =prot-orderless-alternative-styles=
   variables are designed for this particular task.

#+begin_src emacs-lisp
;;; Orderless completion style (and prot-orderless.el)
(prot-emacs-builtin-package 'prot-orderless
  (setq prot-orderless-default-styles
        '(orderless-prefixes
          orderless-strict-leading-initialism
          orderless-regexp))
  (setq prot-orderless-alternative-styles
        '(orderless-literal
          orderless-prefixes
          orderless-strict-leading-initialism
          orderless-regexp)))

(prot-emacs-elpa-package 'orderless
  (setq orderless-component-separator " +")
  (setq orderless-matching-styles prot-orderless-default-styles)
  (setq orderless-style-dispatchers
        '(prot-orderless-literal-dispatcher
          prot-orderless-initialism-dispatcher
          prot-orderless-flex-dispatcher))
  ;; SPC should never complete: use it for `orderless' groups.
  (let ((map minibuffer-local-completion-map))
    (define-key map (kbd "SPC") nil)
    (define-key map (kbd "?") nil)))
#+end_src

These are the contents of the =prot-orderless.el= library (get the file
from [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]] (as with all my Elisp code)):

#+include: prot-lisp/prot-orderless.el src emacs-lisp :tangle no

*** Completion annotations (marginalia)
:PROPERTIES:
:CUSTOM_ID: h:09d657c7-eb4d-4fe3-987a-4a2cf419bb40
:END:

This is a utility jointly developed by Daniel Mendler and Omar Antolín
Camarena that provides annotations to completion candidates.  It is
meant to be framework-agnostic, so it works with Selectrum, Icomplete
vertical, Embark's completions buffer, as well as the default
completions' buffer (as of 2021-04-02, the latter is my choice for
visualising the standard minibuffer completion candidates---refer to
[[#h:c110e399-3f43-4555-8427-b1afe44c0779][Minibuffer configurations and my extras (mct.el)]]).

#+begin_src emacs-lisp
;;; Completion annotations (marginalia)
(prot-emacs-elpa-package 'marginalia
  (setq marginalia-max-relative-age 0)  ; time is absolute here!
  (marginalia-mode 1))
#+end_src

*** Minibuffer configurations and my extras (mct.el)
:PROPERTIES:
:CUSTOM_ID: h:c110e399-3f43-4555-8427-b1afe44c0779
:END:

NOTE 2021-12-29: There are experiments to make MCT perform completion in
region (the job that Corfu handles).  The feature is not fully fleshed
out and there will be changes over the coming days and weeks.

UPDATE 2021-10-23: Watch my video demonstration of the package I wrote
[[https://protesilaos.com/codelog/2021-10-22-emacs-mct-demo/][Minibuffer and Completions in Tandem (mct.el)]].

The minibuffer is the epicentre of extended interactivity with all sorts
of Emacs workflows: to select a buffer, open a file, provide an answer
to some prompt, such as a number, regular expression, password, and so
on.

Emacs has built-in capabilities to perform two distinct tasks related to
such interactions:

+ Narrowing :: Use pattern matching algorithms to limit the list of
  choices (known as "candidates" or "completion candidates") to those
  matching the given input.  There are several pattern matching styles
  already built-in, while we can opt to extend them further.

+ Selecting :: Visualise the list of completion candidates and pick an
  item out of it using regular motions or concomitant extras.  By
  default, Emacs visualises results in a special =*Completions*= buffer,
  which does not have lots of features and is not particularly pleasing
  to use.

There are third party completion frameworks that accomplish both of the
aforementioned, such as Ivy and Helm.  While others focus on the latter,
namely, Selectrum, Vertico, and the built-in Icomplete.  Then, there is
also Embark which has a facility to display completion candidates in a
live updating buffer (Embark is not limited to task---read the details
of [[#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984][Extended minibuffer actions and more (embark.el and prot-embark.el)]]).

I have used Ivy and Icomplete in the past, though I felt that the best
experience was with Embark.  However, as of 2021-04-02 I realised that
Emacs version 28 comes with a built-in way to render =*Completions*= in a
vertical list, one item per line.  So equipped with my knowledge of
extending Embark, I implemented a layer of interactivity that, I feel,
is just as good as what other frameworks provide.  As of 2021-10-22 this
is its own package, called "Minibuffer and Completions in Tandem", else
MCT (or variants).  The technicalities are in the =mct.el= file, which is
reproduced after the following code block.

Read [[https://protesilaos.com/emacs/mct][the official manual of MCT]] as it covers its basics, explains its
key bindings, and shows how to configure it further.

Finally, here is an overview of the settings covered herein:

+ Completion styles :: I rely on a mixture of built-in styles as well as
  the external =orderless= package by Omar Antolín Camarena.  Orderless is
  placed last on the list because simpler searches work fine with the
  other styles.  Orderless is better suited for complex pattern
  matching.  The way completion styles work, when one style cannot match
  anything, Emacs tries the next one on the list, until one of them
  yields results.  As such, it is easy to activate Orderless on demand,
  either by separate input groups by spaces or passing one of the style
  dispatchers that are acceptable (read [[#h:7b1374dd-6b1f-4548-8fbf-1034230c80e0][the Orderless completion style]]).

  For file queries in particular, there exists a niche functionality in
  the built-in =initials= and =partial-completion= styles to navigate
  abbreviated paths.  Here is an example with the latter: you can type
  =~/.l/s/fo= which will match =~/.local/share/fonts= (combine that with the
  file shadowing mentioned above, for a minimalist, decluttered flow).
  The variable =completion-category-overrides= can control the standard
  option of =completion-styles= on a per-category basis.

+ Recursive minibuffers :: I enable recursive minibuffers.  This
  practically means that you can start something in the minibuffer,
  switch to another window, call the minibuffer again, run some
  commands, and then move back to what you initiated in the original
  minibuffer.  Or simply call an =M-x= command while in the midst of a
  minibuffer session.  To exit, hit =C-]= (=abort-recursive-edit=), though
  the regular =C-g= should also do the trick.

  The =minibuffer-depth-indicate-mode= will show a recursion indicator,
  represented as a number, next to the minibuffer prompt, if a recursive
  edit is in progress (also check [[#h:bb707bec-bcaf-44d0-bb82-1ed6bb0cb33b][Mode line recursion indicators]]).

Also check my setup for the [[#h:2733674b-51f9-494e-b34d-e8842ac4ef96][Minibuffer history (savehist-mode)]].  After
several months of full time usage, I am confident in the built-in
mechanism's ability to sort things well enough and to surface the
results I am most likely interested in, based on previous selections.

#+begin_src emacs-lisp
;;; Minibuffer configurations and my extras (mct.el)
(prot-emacs-builtin-package 'minibuffer
  ;; NOTE 2021-10-25: I am adding `basic' because it works better as a
  ;; default for some contexts.  Read:
  ;; <https://debbugs.gnu.org/cgi/bugreport.cgi?bug=50387>.
  (setq completion-styles
        '(basic substring initials flex partial-completion orderless))
  (setq completion-category-overrides
        '((file (styles . (basic partial-completion orderless)))))
  (setq completion-cycle-threshold 2)
  (setq completion-flex-nospace nil)
  (setq completion-pcm-complete-word-inserts-delimiters nil)
  (setq completion-pcm-word-delimiters "-_./:| ")
  (setq completion-ignore-case t)
  (setq completions-detailed t)
  (setq-default case-fold-search t)   ; For general regexp

  ;; Grouping of completions for Emacs 28
  (setq completions-group t)
  (setq completions-group-sort nil)
  (setq completions-group-format
        (concat
         (propertize "    " 'face 'completions-group-separator)
         (propertize " %s " 'face 'completions-group-title)
         (propertize " " 'face 'completions-group-separator
                     'display '(space :align-to right))))

  (setq read-buffer-completion-ignore-case t)
  (setq read-file-name-completion-ignore-case t)

  (setq enable-recursive-minibuffers t)
  (setq read-answer-short t) ; also check `use-short-answers' for Emacs28
  (setq resize-mini-windows t)
  (setq minibuffer-eldef-shorten-default t)

  (setq echo-keystrokes 0.25)           ; from the C source code

  ;; Do not allow the cursor to move inside the minibuffer prompt.  I
  ;; got this from the documentation of Daniel Mendler's Vertico
  ;; package: <https://github.com/minad/vertico>.
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))

  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

  (file-name-shadow-mode 1)
  (minibuffer-depth-indicate-mode 1)
  (minibuffer-electric-default-mode 1)

  ;; I use this prefix for other searches
  (define-key minibuffer-local-must-match-map (kbd "M-s") nil))

;; Source: <https://gitlab.com/protesilaos/mct.el>.
;; Manual: <https://protesilaos.com/emacs/mct>.
(prot-emacs-builtin-package 'mct
  (setq mct-remove-shadowed-file-names t) ; when `file-name-shadow-mode' is enabled
  (setq mct-hide-completion-mode-line t)
  (setq mct-show-completion-line-numbers nil)
  (setq mct-apply-completion-stripes nil)
  (setq mct-minimum-input 3)
  (setq mct-live-update-delay 0.6)
  (setq mct-completion-blocklist nil)
  (setq mct-completion-passlist
        '( embark-prefix-help-command Info-goto-node
           Info-index Info-menu vc-retrieve-tag
           prot-bookmark-cd-bookmark
           prot-bongo-playlist-insert-playlist-file
           project-switch-to-buffer))

  ;; You can place the Completions' buffer wherever you want, by
  ;; following the syntax of `display-buffer-alist' (check elsewhere in
  ;; this file).  For example, try this:

  ;; (setq mct-display-buffer-action
  ;;       (quote ((display-buffer-reuse-window
  ;;                display-buffer-in-side-window)
  ;;               (side . left)
  ;;               (slot . 99)
  ;;               (window-width . 0.3))))

  (mct-region-global-mode 1) ; Or use `mct-region-mode' per major-mode
  (mct-minibuffer-mode 1)

  (define-key minibuffer-local-completion-map (kbd "<tab>") #'minibuffer-force-complete)
  (define-key global-map (kbd "C-x :") #'mct-focus-mini-or-completions))
#+end_src

And here is =mct.el= (from [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/mct.el src emacs-lisp :tangle no

*** Minibuffer history (savehist-mode)
:PROPERTIES:
:CUSTOM_ID: h:2733674b-51f9-494e-b34d-e8842ac4ef96
:END:

The built-in =savehist-mode= keeps a record of actions involving the
minibuffer.  You can access previous inputs with =M-p= and =M-n=.  Well
designed commands that use completion will have their own history, so
those key bindings will only cycle through relevant results.  You can
also search backwardly through them with =M-r=.

This kind of functionality is of paramount importance to a fast and
efficient workflow involving any completion framework that leverages the
built-in mechanisms.

Emacs will remember your input and choices so it will prioritise the
desired results when trying to force complete a given input.  Make sure
to also read the [[#h:c110e399-3f43-4555-8427-b1afe44c0779][Minibuffer configurations and my extras (mct.el)]] for
the minibuffer-specific setup.

#+begin_src emacs-lisp
;;; Minibuffer history (savehist-mode)
(prot-emacs-builtin-package 'savehist
  (setq savehist-file (locate-user-emacs-file "savehist"))
  (setq history-length 10000)
  (setq history-delete-duplicates t)
  (setq savehist-save-minibuffer-history t)
  (add-hook 'after-init-hook #'savehist-mode))
#+end_src

*** Enhanced minibuffer commands (consult.el and prot-consult.el)
:PROPERTIES:
:CUSTOM_ID: h:9c9401d6-8c53-4276-be4c-3bff345d3eeb
:END:

Daniel Mendler's Consult is a welcome addition to the ecosystem of
modular, extensible tools that work with the standard minibuffer
completion mechanisms and, by extension, with every user interface that
largely conforms with them (Icomplete, Selectrum) or fully respects them
(Embark and [[https://github.com/minad/vertico][Daniel's own Vertico]]).  For my case, this means that it
works with everything included in [[#h:98d3abcc-f34e-4029-aabc-740f0b6421f8][Completion framework and extras]].

Consult's value proposition is two-fold: (1) remain aligned with the
Emacs completion paradigm, and (2) offer minibuffer-centric commands
that either enhance aspects of interactivity and functionality found in
existing commands or outright provide them from scratch.

Some Consult commands are drop-in replacements for built-in options.
For example =consult-complex-command= offers an improved interactive
experience over the default =repeat-complex-command=.  Same principle for
=consult-goto-line= which displays the line numbers and offers a live
preview of where you are about to land.

Other commands enhance the defaults with a filtering mechanism that
targets candidates by their type.  A case in point is =consult-imenu=
which recognises syntactic constructs that are variables, functions,
macros (configurable via =consult-imenu-narrow=, =consult-imenu-toplevel=).

This "filtering" mechanism, which is internally known as "narrowing",
can be accessed via a key binding for all commands that support it.  In
my case, that key is the right angled bracket, or greater than sign (=>=)
from inside the minibuffer (configure =consult-narrow-key=).  So you type
the narrow key and follow it up with another key that matches the
relevant targets.  Hit backspace to remove the narrowing.  As for the
available keys, type =?= which calls =consult-narrow-help=.

This narrowing-by-type mechanism can also be used without inputting the
=consult-narrow-key=, just by typing in the appropriate character and
inserting a space.  For instance, to search only for functions in
=consult-imenu=, you type =f= and then a space.  Consult will add an
indicator to the minibuffer prompt describing the active filter.

In general, commands that involve multiple groups can benefit from this
type of narrowing.  The prime example is =consult-buffer= which combines
sources of recently visited files, bookmarks, and buffers (those are
configurable via the variable =consult-buffer-sources=).  Though others
follow the same principle, such as the aforementioned =consult-imenu= and
=consult-bookmark=.

Another intriguing facility of Consult is its asynchronous call to
external processes, such as =grep= and =find=.  Those calls can be
configured to return some output based on a minimum number of
characters, while they also allow for tweaks to their update delays.
Interactivity is already a given, meaning that you can continue typing
and see the results pop up.  Furthermore, they implement a two-stage
input scheme, separated by a configurable delimiter (=#= by default and
controlled with =consult-async-default-split=):

+ First you type in the pattern that should be sent to the external
  program.  This is what triggers the asynchronous call.  So your input
  looks like this: =#PATTERN=.  The pattern will typically consist of some
  text or a regular expression, but can also include command line flags
  for the underlying CLI program (check Consult's documentation for the
  technicalities).

+ Then you can add another field delimiter to instruct Consult to (i)
  keep the results that =#PATTERN= gave you and (ii) leverage Emacs' own
  mechanisms to further narrow the list.  Now your input looks like
  this: =#PATTERN#MORE-PATTERNS=.  The =#MORE-PATTERNS= will use whatever
  completion styles you have configured (check my =completion-styles=).

As already suggested, Consult provides previews for its commands.  This
feature should work without any further intervention.

Consult can shine when used in tandem with Embark to produce buffers
that hold all the candidates of any given minibuffer completion command
([[#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984][Extended minibuffer actions and more (embark.el and prot-embark.el)]]).
For example, =embark-export= can be called from inside =consult-grep= (and
variants) to deliver a dedicated =grep-mode= buffer, which can then be
edited with the help of the =wgrep= package (check [[#h:42624165-f4cb-4318-abce-c11232426880][wgrep (writable grep)]]).
Use that to quickly refactor some pattern across your files.

Other nice extensions of Consult are (i) its ability to work as a
generic front-end for completion, and (ii) its preview facility for
registers.  The former is done by =consult-completion-in-region= which
provides completion for commands such as =dabbrev-completion= or the TAB
key in programming buffers (see [[#h:d51d37df-4e58-4e0b-85a1-019ceda342f6][Tabs, indentation, and the TAB key]]).
While the latter is an overall prettier presentation for the familiar
register preview window (watch: [[https://protesilaos.com/codelog/2020-03-08-emacs-registers/][Primer on Emacs “registers”]]
(2020-03-08)).

As for registers themselves, Consult furnishes three commands, one
focused on minibuffer completion and two as do-what-I-mean alternatives
to the built-in facilities of storing and inserting---or jumping
to---registered data.

+ =consult-register= is what you use for completion.  It searches through
  the contents of the registered compartments and, thus, works well when
  you have text-heavy registers that you need to filter through before
  inserting one at point.

+ =consult-register-store= will save a "thing" to the specified key.  What
  the thing is depends on the context:

  + If the region is active, it will operate on the affected text.
  + If you call it with a numeric argument, it will store that number.
  + If no region is active and no numeric prefix is supplied, it will
    let you select between the current position (point), window
    configuration (window), set of frames with their window
    configurations (frameset), or keyboard macro (kmacro).

  This do-what-I-mean facility is complemented by an actions' menu that
  offers hints on the keys you can use to specify the desired step
  forward.  For example, if you are operating on a region, =M-a= will let
  you append the text to the given register.

+ =consult-register-load= simplifies the mental workload of actually using
  a register.  Unlike the Emacs default where you need to know in
  advance what type of data does the register holds in order to use the
  right action for it, Consult's version just handles that for you.  All
  you have to do is instruct it to use the given register and it will
  know whether it should insert some text or jump to a point/frameset,
  etc.

In practice, I only ever use =consult-register= because I have already
developed muscle memory for the register-related actions.  Though using
all three of the above is easier to learn and more consistent overall.

Note that my =prot-consult.el= (reproduced after the following package
configurations) defines some /quick and dirty/ extensions or thin wrappers
around Consult commands.  The former *will be reviewed* in favour of
better alternatives, even though they "simply work" with everything I
try.

#+begin_src emacs-lisp
;;; Enhanced minibuffer commands (consult.el and prot-consult.el)
(prot-emacs-elpa-package 'consult
  (setq consult-line-numbers-widen t)
  ;; (setq completion-in-region-function #'consult-completion-in-region)
  (setq consult-async-min-input 3)
  (setq consult-async-input-debounce 0.5)
  (setq consult-async-input-throttle 0.8)
  (setq consult-narrow-key ">")
  (setq consult-imenu-config
        '((emacs-lisp-mode :toplevel "Functions"
                           :types ((?f "Functions" font-lock-function-name-face)
                                   (?m "Macros"    font-lock-keyword-face)
                                   (?p "Packages"  font-lock-constant-face)
                                   (?t "Types"     font-lock-type-face)
                                   (?v "Variables" font-lock-variable-name-face)))))
  ;; Search C-h f for more "bookmark jump" handlers.
  (setq consult-bookmark-narrow
        `((?d "Docview" ,#'doc-view-bookmark-jump)
          (?e "Eshell" ,#'eshell-bookmark-jump)
          (?f "File" ,#'bookmark-default-handler)
          (?h "Help" ,#'help-bookmark-jump)
          (?i "Info" ,#'Info-bookmark-jump)
          (?m "Man" ,#'Man-bookmark-jump)
          (?p "PDF" ,#'pdf-view-bookmark-jump)
          (?v "VC Dir" ,#'vc-dir-bookmark-jump)
          (?w "EWW" ,#'prot-eww-bookmark-jump)))
  (setq register-preview-delay 0.8
        register-preview-function #'consult-register-format)
  (setq consult-find-args "find . -not ( -wholename */.* -prune )")
  (setq consult-preview-key 'any)

  (add-hook 'completion-list-mode-hook #'consult-preview-at-point-mode)

  (let ((map global-map))
    (define-key map (kbd "C-x r b") #'consult-bookmark) ; override `bookmark-jump'
    (define-key map (kbd "C-x M-:") #'consult-complex-command)
    (define-key map (kbd "C-x M-m") #'consult-minor-mode-menu)
    (define-key map (kbd "C-x M-k") #'consult-kmacro)
    (define-key map [remap goto-line] #'consult-goto-line)
    (define-key map (kbd "M-K") #'consult-keep-lines) ; M-S-k is similar to M-S-5 (M-%)
    (define-key map (kbd "M-F") #'consult-focus-lines) ; same principle
    (define-key map (kbd "M-s M-b") #'consult-buffer)
    (define-key map (kbd "M-s M-f") #'consult-find)
    (define-key map (kbd "M-s M-g") #'consult-grep)
    (define-key map (kbd "M-s M-m") #'consult-mark)
    (define-key map (kbd "C-x r r") #'consult-register)) ; Use the register's prefix
  (define-key consult-narrow-map (kbd "?") #'consult-narrow-help))

(prot-emacs-builtin-package 'prot-consult
  (setq consult-project-root-function #'prot-consult-project-root)
  (setq prot-consult-command-centre-list
        '(consult-line
          prot-consult-line
          consult-mark))
  (setq prot-consult-command-top-list
        '(consult-outline
          consult-imenu
          prot-consult-outline
          prot-consult-imenu))
  (prot-consult-set-up-hooks-mode 1)
  (let ((map global-map))
    (define-key map (kbd "M-s M-i") #'prot-consult-imenu)
    (define-key map (kbd "M-s M-s") #'prot-consult-outline)
    (define-key map (kbd "M-s M-y") #'prot-consult-yank)
    (define-key map (kbd "M-s M-l") #'prot-consult-line)))
#+end_src

Here is =prot-consult.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-consult.el src emacs-lisp :tangle no

**** Switch to directories (consult-dir.el)
:PROPERTIES:
:CUSTOM_ID: h:4c41ab10-9533-40b2-8c0a-e38b5f0194f6
:END:

This is another nifty package by Karthik Chikmagalur (author of
=project-x=, among others, which I configure elsewhere in this document:
[[#h:4de10a0e-af55-4fdd-8000-d1e3a8ca8055][Extra features for projects (project-x.el)]]).  =consult-dir= provides an
all-in-one interface with minibuffer completion for switching to a
directory that belongs to (i) your list of bookmarks, (ii) the current
project, (iii) your other projects, or (iv) recent files.  It thus
integrates nicely with other parts of the Emacs setup, where those are
present:

+ [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Projects (project.el and prot-project.el)]].
+ [[#h:79cd6177-a81b-420f-8759-e6927b974377][Built-in bookmarking framework (bookmark.el and prot-bookmark.el)]].
+ [[#h:5723c4bb-ff6c-449f-bb60-be66fab3f137][Completion for recent files and directories (prot-recentf.el)]].

As its name suggests, =consult-dir= builds on the Consult package by
Daniel Mendler ([[#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb][Enhanced minibuffer commands (consult.el)]]).  It thus
retains the functionality of its base library, such as the ability to
narrow the list of candidates to a subset in the same way as, e.g., the
=consult-buffer= command does it: while at the empty minibuffer prompt,
type =r= for recent directories, =m= for bookmarked entries, =p= for projects,
and follow it up with an empty space.  This applies the relevant filter.
To remove it just delete backwards.

There are two main uses of the =consult-dir= command.  The first is the
general feature of switching to the buffer of choice.  The other is when
faced with a minibuffer prompt that expects a file path, such as when
you copy or rename a file with Dired.  In that case you want to perform
the operation with one of your directories of interest as the target, so
you call the =consult-dir= command, select one item in a recursive
minibuffer (a minibuffer command inside a minibuffer command), and have
that populate the original prompt.

#+begin_src emacs-lisp
;;; Switch to directories (consult-dir.el)
(prot-emacs-elpa-package 'consult-dir
  (setq consult-dir-shadow-filenames nil)
  (setq consult-dir-sources '( consult-dir--source-bookmark
                               consult-dir--source-default
                               consult-dir--source-project
                               consult-dir--source-recentf))

  ;; Overrides `list-directory' in the `global-map', though I never used
  ;; that anyway.
  (dolist (map (list global-map minibuffer-local-filename-completion-map))
    (define-key map (kbd "C-x C-d") #'consult-dir)))
#+end_src

*** Extended minibuffer actions and more (embark.el and prot-embark.el)
:PROPERTIES:
:CUSTOM_ID: h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984
:END:

Video introduction: [[https://protesilaos.com/codelog/2021-01-09-emacs-embark-extras/][Embark and my extras]] (2021-01-09).  Also read
[[https://karthinks.com/software/fifteen-ways-to-use-embark/][Fifteen ways to use Embark]] (2021-10-06) by Karthik Chikmagalur.

[ NOTE 2021-04-02: the part in that video that deals with cycling
  through the completion candidates has been moved to the file
  =prot-minibuffer.el=, though the effect is practically the same.  UPDATE
  2021-10-22: It now is its own standalone package, called
  =mct.el=---[[#h:c110e399-3f43-4555-8427-b1afe44c0779][Minibuffer configurations and my extras (mct.el)]]. ]

Embark provides a unified framework of regular Emacs keymaps which let
you carry out /contextually relevant actions/ on *targets* through a common
*point of entry*, typically a /prefix key/.

+ "Actions" are standard Emacs commands, such as =describe-symbol= or some
  interactive command you have defined that reads an argument from the
  minibuffer.

+ "Targets" are semantically sensitive constructs, such as the symbol at
  point, a URL, a file name, the active region, or the current
  completion candidate in the minibuffer (or the completions'
  buffer---more on that in the next section).  Embark has so-called
  "clasifiers" which help it determine the category that the target
  belongs to.

+ The "contextually relevant [actions]" are defined in keymaps whose
  scope matches the category of the target.  So =embark-file-map= holds
  all key and command associations for when Embark recognises a file
  name as its target.  =embark-region-map= is for actions pertaining to
  the active region; =embark-buffer-map= for buffer names that you access
  through, say, =switch-to-buffer= (=C-x b=).  And so on.

+ As for the "point of entry" or "prefix key", it is an Embark command,
  such as =embark-act= or =embark-become=.  Those activate the appropriate
  keymap, thus granting you access to the relevant commands.

Embark can act on individual targets (e.g. the region) or sets of
targets (e.g. the list of minibuffer completion candidates).

Emacs users are already familiar with this contextuality of Embark, even
though they may not realise it.  Think, for example, that hitting the =j=
key in an =org-mode= buffer performs the action of inserting that letter
in the buffer: you type something.  While the same =j= key performs a
different action in, say, a =dired-mode= buffer.  There is no conflict
between those actions because each of them is bound to a distinct
keymap, and only one of those keymaps applies in their respective
context.

The beauty of Embark's design is that you configure its contextuality in
the exact same way you define all of your Emacs key bindings.  So you
can bind any command to whatever key you want and confine that action to
a context you specify.

On Emacs 28, learn more about the keymaps with =M-x describe-keymap= and
then search for =embark=.

Now a few things about actions that you can gain access to by invoking
either of =embark-act= (most cases), or =embark-become= (where appropriate):

+ Embark has two ways to help you learn about its actions, though you
  will probably only ever need one of them.  The first one, which is the
  default, is to display a detailed buffer when the variable
  =embark-indicator= is set to a value of =embark-mixed-indicator= or
  =embark-verbose-indicator=.  Those will produce a buffer that shows the
  available actions, the keys they are bound to, and a description of
  what each action does.  The other method, which is only really useful
  if =embark-indicator= is set to =embark-minimal-indicator= is to follow up
  the =embark-act= with =C-h=.  That will produce a minibuffer prompt
  showing all available key bindings.

  - Keymaps aside, you can call /any command/ after invoking =embark-act=.
    This can be either with =M-x= or via its key binding.  For example, if
    you want to grep for the symbol at point in the current project, you
    can do =embark-act= and then =C-x p g= (=project-find-regexp=) (also read
    [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Projects (project.el and prot-project.el)]]).  This will, of course,
    work as expected for commands that typically prompt you for
    something to operate on.

  - Using the =C-h= as a suffix is a standard procedure in Emacs to get a
    Help buffer that contains references to all commands+keys that
    extend a give key chord.  So, for example, =C-x r C-h= will show you
    all commands under the =C-x r= prefix (see [[#h:83730fe8-d917-4d94-96f4-bbc5c900fe38][How do you learn Emacs?]]).
    While the generic =C-h= is fine in its own right, Embark offers an
    alternative that leverages minibuffer completion: the
    =embark-prefix-help-command=.  You can either select an action from
    there or type =@= and the corresponding key.

+ You will often be targeting individual items, such as the current
  completion candidate in the minibuffer, or the symbol at point.  You
  can, however, collect the entire set of targets and store it in a
  buffer, which you can then re-use at your convenience or save it on
  disk (with =write-file= bound to =C-x C-w= by default).  This is done by
  the =embark-collect-snapshot= command, which you can always access
  through =embark-act=.

  - The "Embark Collect" buffer can be presented as a grid or a list,
    with the possibility to manually switch between the two by means of
    the =embark-collect-toggle-view= command.  The list view offers more
    room to the side of each candidate.  It can be used to display
    annotations (see [[#h:09d657c7-eb4d-4fe3-987a-4a2cf419bb40][Completion annotations (marginalia)]]), such as the
    first line of a variable's doc string and current value, a command's
    key binding, the buffer's underlying file system path if it is
    visiting a file, and so on.

  - Embark's "collect" buffer also has a live-updating version, which
    can be use to filter the list of targets.  This particular feature
    can, in fact, be used as a medium for visualising the list of
    candidates in the active minibuffer session.  I used that setup for
    several months together with the default minibuffer as part my
    bespoke completion framework, though as of 2021-04-02 I handle the
    live-updating completions' buffer independently of Embark
    ([[#h:c110e399-3f43-4555-8427-b1afe44c0779][Minibuffer configurations and my extras (mct.el)]]).

  - Other than producing a snapshot, Embark can also collect the targets
    and present them in a buffer whose major-mode is specialised to work
    on the category those targets belong to.  This is done with the
    =embark-export= command.  If you are targeting files, then the export
    takes you to a =dired-mode= buffer (also refer to this document's
    section on [[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][Dired (directory editor, file manager)]]); buffers go to
    =ibuffer-mode= (check [[#h:06290f9c-491c-45b2-b213-0248f890c83d][Ibuffer and extras]]); grep results in a =grep-mode=
    buffer, and so on.

Finally, the =prot-embark.el= that is reproduced after the following block
contains a few keymaps that integrate Embark with packages like =consult=
([[#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb][Enhanced minibuffer commands (consult.el and prot-consult.el)]]).  The
=embark-consult= package provides glue code that allows Embark to produce
a correct export buffer while using relevant Consult commands, such as
=consult-grep=.

#+begin_src emacs-lisp
;;; Extended minibuffer actions and more (embark.el and prot-embark.el)
(prot-emacs-elpa-package 'embark
  (setq prefix-help-command #'embark-prefix-help-command)
  ;; (setq prefix-help-command #'describe-prefix-bindings) ; the default of the above
  (setq embark-collect-initial-view-alist '((t . list)))
  (setq embark-quit-after-action t)     ; XXX: Read the doc string!
  (setq embark-cycle-key (kbd "C-."))   ; see the `embark-act' key
  (setq embark-collect-live-update-delay 0.5)
  (setq embark-collect-live-initial-delay 0.8)
  (setq embark-indicator #'embark-mixed-indicator)
  ;; NOTE 2021-07-31: The mixed indicator starts out with a minimal view
  ;; and then pops up the verbose buffer, so those variables matter.
  (setq embark-verbose-indicator-excluded-actions
        '("\\`embark-collect-" "\\`customize-" "\\(local\\|global\\)-set-key"
          set-variable embark-cycle embark-export
          embark-keymap-help embark-become embark-isearch))
  (setq embark-verbose-indicator-buffer-sections
        `(target "\n" shadowed-targets " " cycle "\n" bindings))
  (setq embark-mixed-indicator-both nil)
  (setq embark-mixed-indicator-delay 1.2)
  ;;  NOTE 2021-07-28: This is used when `embark-indicator' is set to
  ;;  `embark-mixed-indicator' or `embark-verbose-indicator'.  We can
  ;;  specify the window parameters here, but I prefer to do that in my
  ;;  `display-buffer-alist' (search this document) because it is easier
  ;;  to keep track of all my rules in one place.
  (setq embark-verbose-indicator-display-action nil)

  (define-key global-map (kbd "C-,") #'embark-act)
  (let ((map minibuffer-local-completion-map))
    (define-key map (kbd "C-,") #'embark-act)
    (define-key map (kbd "C->") #'embark-become)
    (define-key map (kbd "M-q") #'embark-collect-toggle-view)) ; parallel of `fill-paragraph'
  (let ((map embark-collect-mode-map))
    (define-key map (kbd "C-,") #'embark-act)
    (define-key map (kbd "M-q") #'embark-collect-toggle-view))
  (let ((map embark-region-map))
    (define-key map (kbd "a") #'align-regexp)
    (define-key map (kbd "i") #'epa-import-keys-region)
    (define-key map (kbd "r") #'repunctuate-sentences) ; overrides `rot13-region'
    (define-key map (kbd "s") #'sort-lines)
    (define-key map (kbd "u") #'untabify))
  (let ((map embark-symbol-map))
    (define-key map (kbd ".") #'embark-find-definition)
    (define-key map (kbd "k") #'describe-keymap)))

;; Needed for correct exporting while using Embark with Consult
;; commands.
(prot-emacs-elpa-package 'embark-consult)

(prot-emacs-builtin-package 'prot-embark
  (prot-embark-keymaps 1)
  (prot-embark-setup-packages 1))
#+end_src

This is =prot-embark.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-embark.el src emacs-lisp :tangle no

*** Projects (project.el and prot-project.el)
:PROPERTIES:
:CUSTOM_ID: h:7862f39e-aed0-4d02-9f1e-60c4601a9734
:END:

Starting with Emacs 28, the current development target, =project.el=
contains lots of interesting additions that make it an all-round useful
tool.  Chief among them is a new prefix key bound to =C-x p=.  This has
good mnemonic value, like those for tabs (=C-x t=) and registers (=C-x r=).

A "project" is, in our case, a directory whose contents are related to
each other in terms of the end product they can provide.  Think, for
example, how Emacs' source code is a single "project" that delivers the
program we use.  In practical terms, a project is a version controlled
directory (or directory tree) governed by some program.  For my case
that is =git= though other backends are supported (by virtue of VC---see
section on [[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][Version control framework (vc.el and prot-vc.el)]] as well as
my related extras in [[#h:2ff46d23-09d5-4d92-b0af-2339dc19719f][Diff-mode (and prot-diff.el extensions)]]).

Using any of the commands listed in =C-x p C-h= will append the current
project to a list of "known projects", stored in the dynamically updated
=project--list= variable, whose contents are stored in a file defined by
=project-list-file= (remember that =C-h= can be added to any key sequence to
show its extensions and the commands associated with them---read my
brief guide on [[#h:83730fe8-d917-4d94-96f4-bbc5c900fe38][How do you learn Emacs?]]).  It is then possible to switch
between your projects and proceed to immediately perform an action on
them with =C-x p p=.  A menu with possible commands will appear once you
select a project.  That is customisable via =project-switch-commands=.

Also note that =C-x p p= (=project-switch-project=) can be used to store a
new version-controlled directory in the =project--list=.  Look for the
=... (choose a dir)= option.

Now an overview of the =prot-project.el= commands, which build on top of
an otherwise comprehensive system (full code further below):

+ =prot-project-commit-log= produces a list with the most recent commits
  in the project.  The default count is controlled by a customisation
  option: =prot-project-commit-log-limit=.  In case there is no project
  being acted upon, the command first prompts for completion against the
  project list.

+ =prot-project-find-subdir= provides completion for subdirectories in the
  current project.  It opens the match in a Dired buffer.  When no
  project is present, it prompts for completion.

+ =prot-project-magit-status= produces the =magit-status= buffer for the
  current project or prompts for completion.

+ =prot-project-retrieve-tag= lets you switch to an earlier tagged commit
  or branch using completion.  As always, when no project is present, it
  asks for one before doing its work.

To aid me in my work, I copied code from Manuel Uberti's website (also
referenced in the source code below this configuration block):

+ [[https://www.manueluberti.eu/emacs/2020/11/14/extending-project/][Extending project.el]] (2020-11-14)
+ [[https://www.manueluberti.eu/emacs/2020/11/21/flymake-projects/][Restricting Flymake to my projects]] (2020-11-21)

#+begin_src emacs-lisp
;;; Projects (project.el and prot-project.el)
(prot-emacs-builtin-package 'project
  ;; ;; Use this for Emacs 27 (I am on 28)
  ;; (add-to-list 'prot-emacs-ensure-install 'project)
  (setq project-switch-commands
        '((?f "File" project-find-file)
          (?s "Subdir" prot-project-find-subdir)
          (?g "Grep" project-find-regexp)
          (?d "Dired" project-dired)
          (?b "Buffer" project-switch-to-buffer)
          (?q "Query replace" project-query-replace-regexp)
          (?t "Tag switch" prot-project-retrieve-tag)
          (?m "Magit" prot-project-magit-status)
          (?v "VC dir" project-vc-dir)
          (?l "Log VC" prot-project-commit-log)
          (?e "Eshell" project-eshell)))
  (define-key global-map (kbd "C-x p q") #'project-query-replace-regexp)) ; C-x p is `project-prefix-map'

(prot-emacs-builtin-package 'prot-project
  (setq prot-project-project-roots '("~/Git/Projects/" "~/Git/build/"))
  (setq prot-project-commit-log-limit 25)
  (setq prot-project-large-file-lines 1000)
  (let ((map global-map))
    (define-key map (kbd "C-x p <delete>") #'prot-project-remove-project)
    (define-key map (kbd "C-x p l") #'prot-project-commit-log)
    (define-key map (kbd "C-x p m") #'prot-project-magit-status)
    (define-key map (kbd "C-x p s") #'prot-project-find-subdir)
    (define-key map (kbd "C-x p t") #'prot-project-retrieve-tag)))
#+end_src

This is =prot-project.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-project.el src emacs-lisp :tangle no

**** Extra features for projects (project-x.el)
:PROPERTIES:
:CUSTOM_ID: h:4de10a0e-af55-4fdd-8000-d1e3a8ca8055
:END:

This package by Karthik Chikmagalur provides some helpful extensions to
the =project.el= library (see [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Projects (project.el and prot-project.el)]]).

+ Persistent storage of window configuration :: The window layout for
  the given project can be saved and restored at will.  This is similar
  to how registers can store a window layout, with the key difference
  being that =project-x='s variants persist between Emacs sessions.  So
  you can start work on a project, save the window configuration and
  revisit it the day after.
+ Arbitrary project declaration :: By adding an empty =.project= file to
  the root of a directory, we make it a valid project.  This means that
  we can revisit it with the familiar =C-x p p= (=project-switch-project=)
  and generally perform every project-related operation we want.  The
  upside of using this method is that you can specify arbitrary file
  paths that (i) do not necessary work under version and (ii) you do not
  intend to treat them as your regular projects (e.g. the =elpa= directory
  where Emacs installs packages by default).

The =project-x-mode= streamlines the experience by adding a couple of key
bindings to the =C-x p= project prefix key chord.  Those bindings will be
familiar to anyone who has ever used registers: =C-x p w= will capture the
project's window configuration, while =C-x p j= will jump to an already
stored layout.

#+begin_src emacs-lisp
;;; Extra features for projects (project-x.el)
;; Project repo: <https://github.com/karthink/project-x>.  This is one
;; of the packages I handle manually via git, at least until it becomes
;; available through an ELPA.
;;
;; `prot-emacs-manual-package' is defined in my init.el
(prot-emacs-manual-package 'project-x
  (setq project-x-window-list-file (locate-user-emacs-file "project-x-window-list"))
  (setq project-x-local-identifier ".project")
  (project-x-mode 1))
#+end_src

*** Completion for recent files and directories (prot-recentf.el)
:PROPERTIES:
:CUSTOM_ID: h:5723c4bb-ff6c-449f-bb60-be66fab3f137
:END:

=recentf= is a built-in minor mode that keeps track of the files you have
opened, allowing you to revisit them faster.  Its true power consists in
the fact that its data, maintained in =recentf-list=, is a simple
variable.  This means that we can access it through any relevant piece
of Elisp functionality.

To that end, the functions I define in =prot-recentf.el= are meant to
either control the contents of the list or allow me to access them
through my completion framework or a dedicated file listing (refer to
the mega-section [[#h:98d3abcc-f34e-4029-aabc-740f0b6421f8][Completion framework and extras]]).

Note that there exists a built-in =recentf-open-files= function for
accessing the recent files through a bespoke buffer.  I find that I have
no use for it.

Also note that the Consult package provides its own =recentf= command as
well as the =consult-buffer= which combines candidates from multiple
sources, including bookmarks, recent files, and buffers (check more in
[[#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb][Enhanced minibuffer commands (consult.el and prot-consult.el)]]).

#+begin_src emacs-lisp
;;; Completion for recent files and directories (prot-recentf.el)
(prot-emacs-builtin-package 'recentf
  (setq recentf-save-file (locate-user-emacs-file "recentf"))
  (setq recentf-max-saved-items 200)
  (setq recentf-exclude '(".gz" ".xz" ".zip" "/elpa/" "/ssh:" "/sudo:"))
  (add-hook 'after-init-hook #'recentf-mode))

(prot-emacs-builtin-package 'prot-recentf
  (add-to-list 'recentf-keep 'prot-recentf-keep-predicate)
  (let ((map global-map))
    (define-key map (kbd "C-x C-r") #'prot-recentf-recent-files-or-dirs)))
#+end_src

This is a copy of =prot-recentf.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-recentf.el src emacs-lisp :tangle no

*** In-buffer completions
:PROPERTIES:
:CUSTOM_ID: h:98876022-57cc-40de-936e-4ee42cefd69a
:END:
**** Corfu (Completion Overlay Region FUnction) and CAPE
:PROPERTIES:
:CUSTOM_ID: h:675ebef4-d74d-41af-808d-f9579c2a5ec4
:END:

NOTE 2021-12-29: There are experiments to make MCT to the job that
Corfu does.  As such, I am disabling this for the time being, though I
strongly encourage you to stick with Corfu.

=corfu= is another nimble package by Daniel Mendler (author of Consult and
several others---search this document for a few of them), which focuses
on text expansion within the buffer.  Its User Interface involves a
pop-up that shows the completion candidates for the text before point.
This pop-up, technically a child frame, is invoked manually with the =TAB=
key.  While I would have preferred to use the minibuffer even for
in-buffer text expansion, for the sake of consistency and
predictability, I consider the added functionality more important than
my mild preference against pop-ups (though the fact that Corfu is
invoked manually makes this largely irrelevant).

As is the norm with Daniel's contributions, =corfu= is a sharp and focused
tool that works with the standard completion mechanisms, as it reads
from the =completion-styles= as well as the =completion-category-overrides=
(refer to [[#h:c110e399-3f43-4555-8427-b1afe44c0779][Minibuffer configurations and my extras (mct.el)]], though note
that if you are a fan of Daniel's work, you will probably want to check
the [[https://github.com/minad/vertico][Vertico package]] instead of my hacks for the default minibuffer
experience).

Unlike its more established counterpart, =company-mode=, Corfu does not
implement its own backends for various programming languages.  Instead,
it plugs in to the standard =completion-at-point-functions= (CAPF).
Perhaps that could be seen as a downside for users who program in a lot
of languages and/or who require some of Company's bespoke functionality.
For me though, the CAPF facility is good enough because it works with
the only programming language I have been coding in for the last several
months: Emacs Lisp.  CAPF also is future-proof in that any package that
provides its own completion table, automatically works with Corfu, such
as my contacts manager ([[#h:d386e14b-dcf7-46a2-851f-867cd84c6cae][EBDB (mail contacts)]]).  And I would assume that
it also works for any major mode that is in sync with the current best
practices in Emacs' design.  Besides, this approach makes the code
easier for me to understand and configure.

Once the Corfu overlay appears, use =C-n= and =C-p= to cycle through the
candidates.  Other motions work as well, such as =C-v=, =M-v=, =M-<=, =M->=,
though regular incremental motions is what you would normally want.  =RET=
selects the current item and exits, while =TAB= tries to complete as much
as possible, only exiting if the match is unique.  Additionally, you can
use =M-h= (=corfu-show-documentation=) and =M-g= (=corfu-show-documentation=)
over the selected candidate to either display its doc string or its
source code, respectively.

Note that for =TAB= to perform completion in addition to its primary
function of adjusting indentation, we need =tab-always-indent= to be set
to a =complete= value (check [[#h:d51d37df-4e58-4e0b-85a1-019ceda342f6][Tabs, indentation, and the TAB key]] and/or
read that variable's doc string).

Finally, the =cape= package, also by Daniel, adds some more backends for
the aforementioned CAPF facility.  They make Corfu work in more
contexts.  Basically, this is the sort of thing that you set up and it
"just works".

#+begin_src emacs-lisp
;;; Corfu (Completion Overlay Region FUnction)
;; (prot-emacs-elpa-package 'corfu
;;   ;; (dolist (mode '( message-mode-hook text-mode-hook prog-mode-hook
;;   ;;                  shell-mode-hook eshell-mode-hook))
;;   ;;   (add-hook mode #'corfu-mode))
;;   (corfu-global-mode 1)
;;   (define-key corfu-map (kbd "<tab>") #'corfu-complete))
;;
;; (prot-emacs-elpa-package 'cape
;;   (setq cape-dabbrev-min-length 2)
;;   (dolist (backend '( cape-keyword-capf cape-file-capf cape-dabbrev-capf))
;;     (add-to-list 'completion-at-point-functions backend)))
#+end_src

**** Dabbrev (dynamic word completion)
:PROPERTIES:
:CUSTOM_ID: h:57dcf193-0c4e-4ee6-9b2d-6892558b0a84
:END:

This is Emacs' own approach to dynamic/arbitrary text completion inside
the buffer: "dynamic abbreviation" or else =dabbrev=.  This mechanism
works by reading all text before point to find a suitable match.
Different scenaria determine whether it should also look forward and in
other buffers.  In essence, Dabbrev helps you re-type what you already
have.

With =dabbrev-expand= we make an attempt to complete the text at point.
Repeated invocations will cycle through the candidates.  No feedback is
provided, much in the same way yanking from the kill-ring works (though
for Emacs28 =yank-pop= on =M-y= will use completion if the previous command
was not =yank= on =C-y=).  To complete a phrase, matching the last succesful
=dabbrev-expand=, you need to supply an empty space and call the command
again.  This will match the next word, and so on for N words.

Whereas =dabbrev-completion= benefits from minibuffer interactivity and
the pattern matching styles in effect ([[#h:98d3abcc-f34e-4029-aabc-740f0b6421f8][Completion framework and extras]]).
With the help of Corfu, the completion candidates are displayed in a
pop-up window near point ([[#h:675ebef4-d74d-41af-808d-f9579c2a5ec4][Corfu for in-buffer completion]]).

The =dabbrev-abbrev-char-regexp= is configured to match both regular words
and symbols (e.g. words separated by hyphens).  This makes it equally
suitable for code and ordinary language.

While the =dabbrev-abbrev-skip-leading-regexp= is instructed to also
expand words and symbols that start with any of these: =$=, =*=, =/=, ===, =~=, ='=.
This regexp may be expanded in the future, but the idea is to be able to
perform completion in contexts where the known word/symbol is preceded
by a special character.  For example, in the =org-mode= version of this
document, all inline code must be placed between the equals sign.  So
now typing the ===, then a letter, will still allow me to expand text
based on that input.

To check what I have on regular expressions, see further below my
configurations and documentation for [[#h:6c6759c8-3ae3-40b0-8356-05cc0975e12a][re-builder (regexp-builder)]].

#+begin_src emacs-lisp
;;; Dabbrev (dynamic word completion)
(prot-emacs-builtin-package 'dabbrev
  (setq dabbrev-abbrev-char-regexp "\\sw\\|\\s_")
  (setq dabbrev-abbrev-skip-leading-regexp "[$*/=~']")
  (setq dabbrev-backward-only nil)
  (setq dabbrev-case-distinction 'case-replace)
  (setq dabbrev-case-fold-search nil)
  (setq dabbrev-case-replace 'case-replace)
  (setq dabbrev-check-other-buffers t)
  (setq dabbrev-eliminate-newlines t)
  (setq dabbrev-upcase-means-case-search t)
  (let ((map global-map))
    (define-key map (kbd "M-/") #'dabbrev-expand)
    (define-key map (kbd "C-x M-/") #'dabbrev-completion)))
#+end_src

**** Abbreviations or Abbrevs
:PROPERTIES:
:CUSTOM_ID: h:33cd69cc-1a50-4abb-9f09-cae98dc8998b
:END:

The =abbrev= library provides an easy way to automatically correct some of
your most common typos or write an abbreviation that expands into
another string of characters when =abbrev-mode= is enabled in the relevant
mode.  For example, I have set it up to convert =latex= into =LaTeX= when I
am using =text-mode= or derivates, such as =org-mode=.  This expansion is
case-insensitive, so =Latex= will still become =LaTeX=.

The expansion is triggered by a non-text character such as a space or
newline, or the command =expand-abbrev= (=C-x a e=) after the target text
has been filled in and point is at the end of it.

Abbreviations are stored in tables.  In general, we want to have our
most common entries in the =global-abbrev-table=.  Then we can refine our
substitutes based on the major mode we are in.  Each major modes comes
with its own abbrev table, so we can have something like
=message-mode-abbrev-table= which only works in =message-mode=.

The Emacs manual also covers the concept of "skeletons", which are
templates that can be parameterised with Elisp and then expanded as
abbrevs.  I have no real use for them right now.

#+begin_src emacs-lisp
;;; Abbreviations or Abbrevs
(prot-emacs-builtin-package 'abbrev
  (setq abbrev-file-name (locate-user-emacs-file "abbrevs"))
  (setq only-global-abbrevs nil)

  (let ((table global-abbrev-table))
    (define-abbrev table "meweb" "https://protesilaos.com")
    (define-abbrev table "megit" "https://gitlab.com/protesilaos"))

  (let ((table text-mode-abbrev-table))
    (define-abbrev table "latex" "LaTeX")
    (define-abbrev table "github" "GitHub")
    (define-abbrev table "gitlab" "GitLab")
    (define-abbrev table "sourcehut" "SourceHut")
    (define-abbrev table "auctex" "AUCTeX")
    (define-abbrev table "Emacs27" "Emacs 27")
    (define-abbrev table "Emacs28" "Emacs 28")
    (define-abbrev table "Emacs29" "Emacs 29")
    (define-abbrev table "asciidoc" "AsciiDoc"))

  (with-eval-after-load 'message
    (let ((table message-mode-abbrev-table)
          (name "Protesilaos (or simply \"Prot\")"))
      (define-abbrev table "bestregards" (format "Best regards,\n%s" name))
      (define-abbrev table "allthebest" (format "All the best,\n%s" name))
      (define-abbrev table "abest" "All the best,\nProt")
      (define-abbrev table "bregards" "Best regards,\nProt")))

  (let ((map global-map))
    (define-key map (kbd "C-x a e") #'expand-abbrev) ; default, just here for visibility
    (define-key map (kbd "C-x a u") #'unexpand-abbrev))

  ;; message-mode derives from text-mode, so we don't need a separate
  ;; hook for it.
  (dolist (hook '(text-mode-hook git-commit-mode-hook))
    (add-hook hook #'abbrev-mode)))
#+end_src

** Configurations for---or extensions to---built-in search commands
:PROPERTIES:
:CUSTOM_ID: h:67dac9fe-5c15-437d-bb3e-26b293affa45
:END:

These are meant to enhance the functionality of tools that are already
shipped with Emacs.

*** Isearch, occur, grep, and extras (prot-search.el)
:PROPERTIES:
:CUSTOM_ID: h:b67687ee-25a3-4bf4-a924-180ccb63c629
:END:

The built-in search mechanisms, defined in the libraries =isearch.el= and
=replace.el= are minimal in their presentation, yet powerful in their
applications.  There are the main points of entry to the commands they
offer:

+ =isearch-forward= (=C-s=) prompts for a string after point and offers live
  feedback on its progress.  =isearch-backward= (=C-r=) moves in the
  opposite direction.

  - Two distinct keys may seem redundant at first, but you really
    appreciate this level of precision when recording keyboard macros
    (see, for example, my video about [[https://protesilaos.com/codelog/2020-01-21-emacs-isearch-kmacro/][Isearch powers in keyboard macros]]
    (2020-01-21)).

  - Use =C-M-s= and =C-M-r= for running a search against a regular
    expression, or call =isearch-toggle-regexp= (=M-r=) after starting a
    regular isearch.

+ =query-replace= (=M-%=) replaces all matches of a string and asks you for
  confirmation on each of them.  If you check its help page (press =?=
  after invoking the command), you will learn that =!= stands for an
  affirmative answer to all, which is a standard in all such prompts.

  - =query-replace-regexp= (=C-M-%=) does the same for regular expressions.

+ =occur= (=M-s o=) places all matches of a regular expression or string in
  a dedicated buffer.  That can function as an index for moving to the
  relevant points in the buffer, but also as a means of refactoring all
  matches at once.  Just make the =*Occur*= buffer editable with =e=.
  Running =occur= with a numeric argument provides N lines of context
  around the given match.

The beauty of the Occur and Replace commands is that they can be
initiated from within an active Isearch session, using the same keys.
So =C-s INPUT M-s o= will search for input and then run =occur= on it.  Try
=C-h k C-s= to get a help menu with all the extra keys you can use with
=isearch=.  These are the ones I use the most:

| Key chord | Description                         |
|-----------+-------------------------------------|
| C-s C-w   | Search char or word at point        |
| M-s .     | Search for symbol at point          |
| M-s M-.   | Search for thing at point (Emacs28) |
| M-s o     | Run `occur' on regexp               |
| M-s h r   | Highlight regexp                    |
| M-s h u   | Undo the highlight                  |
| C-s M-r   | Toggle regexp search                |
| M-%       | Run `query-replace'                 |
| C-M-%     | `query-replace-regexp'              |

Every one of the above, except the first item, can be executed on their
own, or as extensions of =C-s= (and variants).  In the latter case, when
you run a regexp-aware Isearch (=C-M-s= or =C-M-r=) a =M-%= will automatically
be interpreted as =C-M-%=.

The Occur and Replace operations are aware of the active region, so if
you highlight, say, a paragraph and do =M-%= you will only replace matches
inside of that area (while not relevant to our point, this also works
for =undo= (=C-/=), which is super useful).  Though one can achieve pretty
much the same result by leveraging Emacs' narrowing commands, like
=narrow-to-defun= (learn about all of them with =C-x n C-h=)

Now here is a neat trick I discovered a while ago that makes Isearch
even better for most tasks: the ability to interpret a space as a
wildcard.  This is due to the combined effect of the values assigned to
the variables =search-whitespace-regexp=, =isearch-lax-whitespace=,
=isearch-regexp-lax-whitespace=.  So you can now search for something like
=se di bu al= and it will return =setq display-buffer-alist=.  And you can
still combine it with all of the aforementioned!  Note that *this affects
regular searches* (the standard =C-s= and =C-r=).  The regexp-sensitive
functions =C-M-s= and =C-M-r= remain in tact.  You can always toggle
whitespace matching behaviour while performing a search, with =M-s SPC=
(revert back to just literal spaces).

Now on to my =prot-search.el= library which provides some extensions to
an already well-designed architecture (the code is reproduced after the
package configurations).

+ =prot-search-isearch-other-end= simply places point at the opposite end
  of the current match.  Particularly helpful while recording keyboard
  macros.  This is to work around the default behaviour of Isearch which
  puts the point at either the beginning or the end of the match,
  depending on the direction it is moving in.  For single words or
  balanced expressions this is not an issue because you can always
  confirm+exit a search by using a motion key (so, for example, move to
  the end of the matching word with =M-f=).  There are, however, matches
  that are not limited to such boundaries, especially with the wildcard
  hack mentioned above.  For those cases moving to the opposite end
  might require multiple key presses, which is bad when trying to record
  an efficient keyboard macro.  Note though that you can achieve the
  same result by changing the direction the search is moving towards
  with =C-s= or =C-r= (though I still prefer my minor addition).

+ =prot-search-isearch-abort-dwim= deletes the entirety of the
  non-matching input while leaving the valid parts in place.  Otherwise
  it behaves like a standard backward character deletion. The built-in
  method to remove the entirety of a mismatched input is to hit =C-g=
  following a failed search.  However, I find that the choice of key
  binding can prove problematic, since =C-g= also exits a successful
  search, while I also prefer a "do-what-I-mean" behaviour.

+ =prot-search-isearch-replace-symbol= runs a forward-looking
  =query-replace= for the symbol at point.  Simple and effective for
  quickly refactoring a given function/variable name (and one of the
  reasons why I have never needed an extra package for such tasks).

+ =prot-search-isearch-beginning-of-buffer= and its counterpart
  =prot-search-isearch-end-of-buffer= move to the first or last instance
  of the symbol at point.  They also accept a numeric argument, which
  they interpret as an offset.  In practice, this is the same as running
  =M-s . M-s <= or =M-s . M-s >=.

+ =prot-search-occur-urls= gathers all URLs in the current buffer and
  places them in an Occur buffer /without their context/ while also making
  them clickable (we say that it "buttonises" them).

+ =prot-search-occur-outline= produces an outline of the buffer based on a
  configurable association of major mode and regular expression.  Check
  the variable =prot-search-outline-regexp-alist=.  The command can prompt
  for a regexp style to use, defaulting to the current major mode if an
  outline regexp exists for it.  An arbitrary regexp can also be
  inserted either through interactive use or from Lisp code.

+ =prot-search-occur-browse-url= gathers all URLs in the buffer and
  prompts you to select one with completion.  It then browses that item
  using whatever browser you have for =browse-url-browser-function=.

+ =prot-search-grep= runs a local grep in the current directory.  With a
  prefix argument, it runs recursively instead.  This is a thin wrapper
  around the built-in =lgrep= and =rgrep= commands: it makes the process
  faster by not asking for a directory and file extension pattern.  All
  output is placed in a separate buffer.  Note that I also have a
  variant for git-controlled projects: it is =prot-vc-git-grep= from
  [[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][Version control framework (vc.el and prot-vc.el)]].  Also note that
  Consult provides a live version: refer to the [[#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb][section on consult.el]].
  (I normally use Consult and export the results with Embark, except for
  when I know exactly what I am looking for and want it in a buffer, so
  the added features are not needed).

#+begin_src emacs-lisp
;;; Isearch, occur, grep, and extras (prot-search.el)
(prot-emacs-builtin-package 'isearch
  (setq search-highlight t)
  (setq search-whitespace-regexp ".*?")
  (setq isearch-lax-whitespace t)
  (setq isearch-regexp-lax-whitespace nil)
  (setq isearch-lazy-highlight t)
  ;; All of the following variables were introduced in Emacs 27.1.
  (setq isearch-lazy-count t)
  (setq lazy-count-prefix-format nil)
  (setq lazy-count-suffix-format " (%s/%s)")
  (setq isearch-yank-on-move 'shift)
  (setq isearch-allow-scroll 'unlimited)
  ;; These variables are from Emacs 28
  (setq isearch-repeat-on-direction-change t)
  (setq lazy-highlight-initial-delay 0.5)
  (setq lazy-highlight-no-delay-length 3)
  (setq isearch-wrap-pause t)

  (define-key minibuffer-local-isearch-map (kbd "M-/") #'isearch-complete-edit)
  (let ((map isearch-mode-map))
    (define-key map (kbd "C-g") #'isearch-cancel) ; instead of `isearch-abort'
    (define-key map (kbd "M-/") #'isearch-complete)))

(prot-emacs-builtin-package 'replace
  (setq list-matching-lines-jump-to-current-line t)
  (add-hook 'occur-mode-hook #'hl-line-mode)
  (add-hook 'occur-mode-hook #'prot-common-truncate-lines-silently) ; from `prot-common.el'
  (define-key occur-mode-map (kbd "t") #'toggle-truncate-lines))

(prot-emacs-builtin-package 'grep)

(prot-emacs-builtin-package 'prot-search
  (setq prot-search-outline-regexp-alist
        '((emacs-lisp-mode . "^\\((\\|;;;+ \\)")
          (org-mode . "^\\(\\*+ +\\|#\\+[Tt][Ii][Tt][Ll][Ee]:\\)")))

  (let ((map global-map))
    (define-key map (kbd "M-s %") #'prot-search-isearch-replace-symbol)
    (define-key map (kbd "M-s M-<") #'prot-search-isearch-beginning-of-buffer)
    (define-key map (kbd "M-s M->") #'prot-search-isearch-end-of-buffer)
    (define-key map (kbd "M-s g") #'prot-search-grep)
    (define-key map (kbd "M-s u") #'prot-search-occur-urls)
    (define-key map (kbd "M-s M-o") #'prot-search-occur-outline)
    (define-key map (kbd "M-s M-u") #'prot-search-occur-browse-url))
  (let ((map isearch-mode-map))
    (define-key map (kbd "<up>") #'prot-search-isearch-repeat-backward)
    (define-key map (kbd "<down>") #'prot-search-isearch-repeat-forward)
    (define-key map (kbd "<backspace>") #'prot-search-isearch-abort-dwim)
    (define-key map (kbd "<C-return>") #'prot-search-isearch-other-end)))
#+end_src

Here is =prot-search.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-search.el src emacs-lisp :tangle no

*** Test regular expressions (re-builder)
:PROPERTIES:
:CUSTOM_ID: h:6c6759c8-3ae3-40b0-8356-05cc0975e12a
:END:

Emacs offers a built-in tool for testing regular expressions: invoke it
with the =regexp-builder= or =re-builder= command.  It pops up a buffer at
the bottom of the current window, which lets you test a regular
expression on the contents of the buffer from where the command was
called.  By default, =re-builder= uses Emacs-style notation, where escape
sequences are written as a double backslash.  You can switch between the
various styles by using =C-c TAB= inside of the regexp builder's buffer.
I choose to keep this style as the default as it is what I also use when
writing a pattern in some Elisp file.

To learn more about regular expressions, read the relevant pages in the
official manual by evaluating this: =(info "(emacs) Regexps")=.  Also
consider watching my ~35 minute-long video [[https://protesilaos.com/codelog/2020-01-23-emacs-regexp-primer/][primer on Emacs regexp]]
(2020-01-23).  If you actually need to do a regexp-aware query and
replace operation that performs an arbitrary elisp function on a group
check my article on how to use [[https://protesilaos.com/codelog/2021-03-03-emacs-query-replace-downcase/][query-replace-regexp to downcase matches]]
(2021-03-03).  Remember that you can always get interactivity by first
using something like =isearch-forward-regexp= and then switching to the
=query-replace= operation with =M-%= (in this case, =query-replace=
automatically becomes regexp-aware).

Also check: [[#h:b67687ee-25a3-4bf4-a924-180ccb63c629][Isearch, occur, grep, and extras (prot-search.el)]].

#+begin_src emacs-lisp
;;; Test regular expressions (re-builder)
(prot-emacs-builtin-package 're-builder
  (setq reb-re-syntax 'read))
#+end_src

*** wgrep (writable grep)
:PROPERTIES:
:CUSTOM_ID: h:42624165-f4cb-4318-abce-c11232426880
:END:

With =wgrep= we can directly edit the results of a =grep= and save the
changes to all affected buffers.  In principle, this is the same as what
the built-in =occur= offers.  We can use it to operate on a list of
matches by leveraging the full power of Emacs' editing capabilities
(e.g. keyboard macros, query and replace a regexp...).

#+begin_src emacs-lisp
;;; wgrep (writable grep)
(prot-emacs-elpa-package 'wgrep
  (setq wgrep-auto-save-buffer t)
  (setq wgrep-change-readonly-file t)
  (let ((map grep-mode-map))
    (define-key map (kbd "e") #'wgrep-change-to-wgrep-mode)
    (define-key map (kbd "C-x C-q") #'wgrep-change-to-wgrep-mode)
    (define-key map (kbd "C-c C-c") #'wgrep-finish-edit)))
#+end_src

*** Cross-references (xref.el)
:PROPERTIES:
:CUSTOM_ID: h:594bca38-542c-4aac-95f5-349f034c6802
:END:

Xref provides helpful commands for code navigation and discovery, such
as =xref-find-definitions= (=M-.=) and its counterpart =xref-pop-marker-stack=
(=M-,=).  It is a library that gets used by a variety of tools, including
=project.el= (see [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Projects (project.el and prot-project.el)]]).

Here are just the basics.  I might add more in the future.

#+begin_src emacs-lisp
;;; Cross-references (xref.el)
(prot-emacs-builtin-package 'xref
  ;; All those have been changed for Emacs 28
  (setq xref-show-definitions-function #'xref-show-definitions-completing-read) ; for M-.
  (setq xref-show-xrefs-function #'xref-show-definitions-buffer) ; for grep and the like
  (setq xref-file-name-display 'project-relative)
  (setq xref-search-program 'grep))
#+end_src

* Directory, buffer, window management
:PROPERTIES:
:CUSTOM_ID: h:402cb0db-1e93-4b1f-8f6d-e17b4409fb86
:END:
** Dired file manager (and prot-dired.el extras)
:PROPERTIES:
:CUSTOM_ID: h:c519300f-8a9a-472b-b26d-c2f49adbdb5d
:END:

The directory editor abbreviated as "Dired" (which I pronounce like
"tired", "mired", etc.) is a built-in tool that performs file management
operations inside of an Emacs buffer.  It is simply superb!  I use it
daily for a number of tasks.

You can interactively copy, move (rename), symlink, delete files and
directories, handle permissions, compress or extract archives, run shell
commands, combine Dired with regular editing capabilities as part of a
keyboard macro, search[+replace] across multiple files, encrypt/decrypt
files, start an email with the current or marked files attached to the
message, and more.  Combine that with the possibility of matching items
with regular expressions, such as for marking files or narrowing the
list, or creating an editable Dired buffer to bulk rename entries, and
you have everything you need to maximise your productivity.

Watch some of my older videos:

+ [[https://protesilaos.com/codelog/2019-08-12-emacs-dired-tweaks/][Dired tweaks and refinements]] (2019-08-12).
+ [[https://protesilaos.com/codelog/2019-09-03-emacs-dired-macros/][Use Dired and keyboard macros]] (2019-09-03).
+ [[https://protesilaos.com/codelog/2019-09-19-dired-narrow/][Techniques to narrow Dired]] (2019-09-19).
+ [[https://protesilaos.com/codelog/2019-11-16-emacs-dired-chmod/][Change multi-file permissions with Dired]] (2019-11-16).
+ [[https://protesilaos.com/codelog/2019-11-13-emacs-bongo-music/][Music management with Dired and Bongo]] (2019-11-13).
+ [[https://protesilaos.com/codelog/2019-11-18-emacs-dired-bongo/][Dired+Bongo and macros to handle music playlists]] (2019-11-18).
+ [[https://protesilaos.com/codelog/2019-12-08-emacs-multi-replace/][Search and replace across multiple files (not Dired-specific)]] (2019-12-08).

The following package configurations are fairly comprehensive.  First an
overview of the options I specify for Dired proper:

+ Copy and delete recursively.  No need to be prompted about each
  action.

+ While in detailed view, search only file names when point is on one of
  them, else apply the query to the rest of the data.

+ Deletion sends items to the system's Trash, making it safer than the
  standard =rm=.  The trash can be a life-saver, as it lets you restore
  deleted files (check: [[#h:954adfb4-8f2c-4665-bb5b-e098926341b0][dired-like mode for the trash (trashed.el)]]).

+ Reformat output.  Sort directories first.  Show dotfiles and place
  them before anything else.  Omit implicit directories (the single and
  double dots).  Use human-readable size units.  To learn everything
  about these switches, you need to read the manpage of =ls=.  You can do
  so with =M-x man RET ls= or =M-x woman=.

  - Note that =dired-listing-switches= and =find-ls-option= are configured
    to show hidden directories and files /before/ their non-hidden
    counterparts.  If you want to reverse this order, you must include
    the =-X= option (such as =-AFXhlv --group-directories-first=).

+ Hide all the details by default (permissions, size, etc.).  Those can
  easily be toggled on with the left parenthesis.  Also enable
  highlighting of the current line (=hl-line-mode=), which makes it even
  easier to spot the current item (I do not enable this globally,
  because I only want it for line-oriented interfaces, such as Dired's,
  but not for text editing).

+ While having two dired buffers open, the rename and copy operations
  will place the path of the inactive one as the target destination.
  When multiple dired buffers are present, this works between the
  current and most recently used ones, with =M-n= and =M-p= on the
  minibuffer prompt allowing you to switch between all possible targets.

+ For Emacs 27.1 or higher, Dired can automatically create destination
  directories for its copy and rename operations.  So you can, for
  example, move (copy or rename) =file= to =/non-existent-path/file= and you
  will get what you want right away.

+ For Emacs 27.1 or higher, renaming a file of a version-controlled
  repository (git) will be done using the appropriate VC mechanism.
  This is to ensure that file name changes are tracked correctly (also
  check my detailed: [[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][Version control framework (vc.el and prot-vc.el)]]).

And here are a few words about the more specialised parts of the Dired
ecosystem:

+ Dired subtree :: This third-party package which is part of the
  [[https://github.com/Fuco1/dired-hacks][dired-hacks project by Matus Goljer]] offers tree-style navigation,
  meaning that the subdirectories of the current Dired buffer can be
  expanded and contracted in place.  It is possible to perform the same
  kind of folding on their subdirectories, and so on.

  Tree-style navigation is useful in my workflow when all I want is a
  quick peek at a directory's contents.

+ Dired extras (dired-x) :: These are some additional features that are
  shipped with Emacs.  The one I need the most is =dired-jump= and its
  "other window" variant.  These are among my favourite commands.  They
  will always take you to the directory that contains the current
  buffer. (Note for Emacs 28 users: =dired-jump= is now part of =dired.el=).

  'Jumping' works even when you are inside buffers that do not visit
  files, such as Magit, Diff, or Eshell: it just takes you to the
  =default-directory=.  This is its most valuable quality!  Edit a file
  then proceed to do some file management, then invoke =previous-buffer=
  or =winner-undo= to go back to where you were (I have a few key bindings
  for those in the [[#h:12591f89-eeea-4b12-93e8-9293504e5a12][Window configuration section]]).  Everything happens
  naturally.  Emacs' interconnectedness at its best!

  The other neat features of =dired-x= are (1) its ability to open Info
  files in place (=dired-info= command, bound to =I=), and (2) to open all
  marked files at once (=dired-do-find-marked-files= bound to =F= by
  default).

+ Writable Dired (wdired) :: This is the standard editable state of a
  dired buffer.  You can access it with =C-x C-q=.  Write changes to files
  or directories, as if it were a regular buffer, then confirm them with
  =C-c C-c=.  This practically means that you can rename files and change
  permissions (when the detailed list is available).  Note that while
  renaming a file, any forward slash is treated like a directory and *is
  created directly* upon successful exit.  Combine this utility with
  keyboard macros, rectangle edits, or =query-replace= (and its regexp
  variant---[[#h:b67687ee-25a3-4bf4-a924-180ccb63c629][Isearch, occur, grep, and extras (prot-search.el)]]) and you
  have one potent tool at your disposal.

+ Image dired :: This built-in library offers facilities for generating
  thumbnails out of a selection of images and displaying them in a
  separate buffer.  An external program is needed to convert the images
  into thumbnails: =imagemagick=.  Other useful external packages are
  =optipng= and =sxiv= (or equivalent).  The former is for operating on PNG
  files, while the latter is a lightweight image viewer.  I feel this
  process is a bit cumbersome and can be very slow if you try to
  generate lots of images at once.  The culprit is the image converter.
  As such, only use this for smaller collections.  Besides, Emacs can
  open an image in a buffer and that works well for viewing individual
  items (else use =!= or =&= to run an external process, with the latter
  being asynchronous).  I don't keep a lot of images around, so I am not
  the best person to comment on this feature.  Instead, I recommend you
  view the video of [[https://www.youtube.com/watch?v=NrY3t3W0_cM][image-dired by Emacs Elements (Raoul Comninos)]].

+ prot-dired.el :: This file (reproduced in its entirety below those
  configurations) contains a few custom extensions for streamlining some
  repetitive tasks.  The video on [[https://protesilaos.com/codelog/2021-07-21-emacs-dired-custom-extras/][my custom Dired extras]] (2021-07-21)
  may also be of help.

  1. It contains methods for opening media files using an external
     program.  The idea is to provide a default option when invoking
     either =!= or =&= on a given file.  So if, for example, you try to open
     an image, it will search the system for the first program matching
     the elements in the =prot-dired-image-viewers= variable.  Same
     principle for media players.

  2. The =prot-dired-limit-regexp= command is a convenience wrapper around
     built-in capabilities of narrowing the listing to the files that
     match (or don't) a given regular expression.  When called directly,
     it prompts for a regexp and removes everything that does not match
     it.  This operation does not delete files.  It just hides them
     (restore the view either with =g= or by using the =undo= command).
     When the command is invoked with a universal prefix argument (=C-u=)
     it inverts the meaning of the regular expression so that it hides
     the matching entries.

  3. The =prot-dired-insert-subdir= is a general purpose command for
     inserting the contents of a subdirectory in the current Dired
     buffer.  It basically provides a superset of features found in the
     standard =dired-maybe-insert-subdir= (bound to =i= by default).  When
     items are marked, it searches among them for the subdirectories to
     the current directory and inserts them in the buffer, while
     ignoring invalid entries.  If no marks are active and point is on a
     subdirectory line, it inserts it directly.  If no marks are active
     and point is not on a subdirectory, then it prompts for minibuffer
     completion and inserts the selected item.  When invoked with a
     single prefix argument (=C-u=) it first asks for the command-line
     flags to pass to the underlying =ls= program, which can be helpful if
     you want to get some more verbose information or pass the =-R= flag
     to directly insert a tree recursively.  And when the command is
     called with a double prefix argument (=C-u C-u=) it removes all
     inserted subdirectories in one go.  As always, the =undo= command can
     help you manage each step.

     Tip: to remove a single subdirectory, you can still use =C-u k= over
     its heading (=dired-do-kill-lines= with its ARG).

     Another tip: to update the =ls= switches for the whole buffer, type
     =C-u s= (=dired-sort-toggle-or-edit= with its ARG).

  4. An Imenu index is set up which lets you jump to the headers of all
     inserted directories using minibuffer completion (either with the
     generic =M-x imenu= or some third-party variant).  The are commands
     which provide directional motions to move between such headings:
     =prot-dired-subdirectory-next= and =prot-dired-subdirectory-previous=.

  5. The command =prot-dired-grep-marked-files= streamlines a common
     workflow I have of using =find= on the command line to grep for file
     contents.  It performs a search in the marked files.  When no items
     are marked, it goes through all files in the current directory
     (non-recursive).  Its doc string covers the technicalities.  The
     command serves as a specialised variant of =prot-search-grep=
     ([[#h:b67687ee-25a3-4bf4-a924-180ccb63c629][Isearch, occur, grep, and extras (prot-search.el)]]).

#+begin_src emacs-lisp
;;; Dired file manager (and prot-dired.el extras)
(prot-emacs-builtin-package 'dired
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'always)
  (setq delete-by-moving-to-trash t)
  (setq dired-listing-switches
        "-AGFhlv --group-directories-first --time-style=long-iso")
  (setq dired-dwim-target t)
  (setq dired-auto-revert-buffer #'dired-directory-changed-p) ; also see `dired-do-revert-buffer'
  (setq dired-make-directory-clickable t) ; Emacs 29.1
  (setq dired-free-space nil) ; Emacs 29.1

  (add-hook 'dired-mode-hook #'dired-hide-details-mode)
  (add-hook 'dired-mode-hook #'hl-line-mode))

(prot-emacs-builtin-package 'dired-aux
  (setq dired-isearch-filenames 'dwim)
  ;; The following variables were introduced in Emacs 27.1
  (setq dired-create-destination-dirs 'ask)
  (setq dired-vc-rename-file t)
  ;; And this is for Emacs 28
  (setq dired-do-revert-buffer (lambda (dir) (not (file-remote-p dir))))

  (let ((map dired-mode-map))
    (define-key map (kbd "C-+") #'dired-create-empty-file)
    (define-key map (kbd "M-s f") #'nil)
    (define-key map (kbd "C-x v v") #'dired-vc-next-action))) ; Emacs 28

;; ;; NOTE 2021-05-10: I do not use `find-dired' and related commands
;; ;; because there are other tools that offer a better interface, such
;; ;; as `consult-find', `consult-grep', `project-find-file',
;; ;; `project-find-regexp', `prot-vc-git-grep'.
;; (prot-emacs-builtin-package 'find-dired
;;   (setq find-ls-option
;;         '("-ls" . "-AGFhlv --group-directories-first --time-style=long-iso"))
;;   (setq find-name-arg "-iname"))

(prot-emacs-builtin-package 'dired-x
  (setq dired-clean-up-buffers-too t)
  (setq dired-clean-confirm-killing-deleted-buffers t)
  (setq dired-x-hands-off-my-keys t)    ; easier to show the keys I use
  (setq dired-bind-man nil)
  (setq dired-bind-info nil)
  (define-key dired-mode-map (kbd "I") #'dired-info))

(prot-emacs-builtin-package 'prot-dired
  (setq prot-dired-image-viewers '("feh" "sxiv"))
  (setq prot-dired-media-players '("mpv" "vlc"))
  (setq prot-dired-media-extensions
        "\\.\\(mp[34]\\|ogg\\|flac\\|webm\\|mkv\\)")
  (setq prot-dired-image-extensions
        "\\.\\(png\\|jpe?g\\|tiff\\)")
  (setq dired-guess-shell-alist-user ; those are the defaults for ! and & in Dired
        `((,prot-dired-image-extensions (prot-dired-image-viewer))
          (,prot-dired-media-extensions (prot-dired-media-player))))

  (add-hook 'dired-mode-hook #'prot-dired-setup-imenu)

  (let ((map dired-mode-map))
    (define-key map (kbd "i") #'prot-dired-insert-subdir) ; override `dired-maybe-insert-subdir'
    (define-key map (kbd "/") #'prot-dired-limit-regexp)
    (define-key map (kbd "C-c C-l") #'prot-dired-limit-regexp)
    (define-key map (kbd "M-n") #'prot-dired-subdirectory-next)
    (define-key map (kbd "C-c C-n") #'prot-dired-subdirectory-next)
    (define-key map (kbd "M-p") #'prot-dired-subdirectory-previous)
    (define-key map (kbd "C-c C-p") #'prot-dired-subdirectory-previous)
    (define-key map (kbd "M-s G") #'prot-dired-grep-marked-files))) ; M-s g is `prot-search-grep'

(prot-emacs-elpa-package 'dired-subtree
  (setq dired-subtree-use-backgrounds nil)
  (let ((map dired-mode-map))
    (define-key map (kbd "<tab>") #'dired-subtree-toggle)
    (define-key map (kbd "<backtab>") #'dired-subtree-remove))) ; S-TAB

(prot-emacs-builtin-package 'wdired
  (setq wdired-allow-to-change-permissions t)
  (setq wdired-create-parent-directories t))

(prot-emacs-builtin-package 'image-dired
  (setq image-dired-external-viewer "xdg-open")
  (setq image-dired-thumb-size 80)
  (setq image-dired-thumb-margin 2)
  (setq image-dired-thumb-relief 0)
  (setq image-dired-thumbs-per-row 4)
  (define-key image-dired-thumbnail-mode-map
    (kbd "<return>") #'image-dired-thumbnail-display-external))
#+end_src

These are the contents of =prot-dired.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-dired.el src emacs-lisp :tangle no

*** dired-like mode for the trash (trashed.el)
:PROPERTIES:
:CUSTOM_ID: h:954adfb4-8f2c-4665-bb5b-e098926341b0
:END:

=trashed= applies the principles of =dired= to the management of the user's
filesystem trash.  Use =C-h m= to see the docs and keybindings for its
major mode.

Basically, its interaction model is as follows:

- =m= to mark for some deferred action, such as =D= to delete, =R= to restore.
- =t= to toggle the status of all items as marked.  Use this without marks
  to =m= (mark) all items, then call a deferred action to operate on them.
- =d= to mark for permanent deletion.
- =r= to mark for restoration.
- =x= to execute these special marks.

#+begin_src emacs-lisp
;;; dired-like mode for the trash (trashed.el)
(prot-emacs-elpa-package 'trashed
  (setq trashed-action-confirmer 'y-or-n-p)
  (setq trashed-use-header-line t)
  (setq trashed-sort-key '("Date deleted" . t))
  (setq trashed-date-format "%Y-%m-%d %H:%M:%S"))
#+end_src

** Working with buffers
:PROPERTIES:
:CUSTOM_ID: h:137f16fe-4f88-4b4d-bd71-cd978c9fdcd5
:END:

*** Keymap for buffers (Emacs28)
:PROPERTIES:
:CUSTOM_ID: h:17933226-27a8-47c0-80f9-3cc609aacae0
:END:

Starting with Emacs version 28, there is a keymap that can be accessed
with the =C-x x= sequence.  This new keymap (=ctl-x-x-map=), is meant to be
used for commands that pertain to the current buffer.  What I have here
are just some tweaks to make it work the way I prefer.

#+begin_src emacs-lisp
;;; Keymap for buffers (Emacs28)
(let ((map ctl-x-x-map))              ; Emacs 28
  (define-key map "e" #'eval-buffer)
  (define-key map "f" #'follow-mode)  ; override `font-lock-update'
  (define-key map "r" #'rename-uniquely))

(with-eval-after-load 'org
  (define-key ctl-x-x-map "i" #'prot-org-id-headlines)
  (define-key ctl-x-x-map "h" #'prot-org-ox-html))
#+end_src

*** Unique names for buffers
:PROPERTIES:
:CUSTOM_ID: h:60a70340-49dc-4f45-b147-12a4141db42b
:END:

These settings make it easier to work with multiple buffers.  When two
buffers have the same name, Emacs will try to disambiguate them by
displaying their element of differentiation in accordance with the style
of =uniquify-buffer-name-style=.  While =uniquify-strip-common-suffix= will
remove the part of the file system path they have in common.

All such operations are reversed once an offending buffer is removed
from the list, allowing Emacs to revert to the standard of displaying
only the buffer's name.

#+begin_src emacs-lisp
;;; Unique names for buffers
(prot-emacs-builtin-package 'uniquify
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-strip-common-suffix t)
  (setq uniquify-after-kill-buffer-p t))
#+end_src

*** Ibuffer and extras (dired-like buffer list manager)
:PROPERTIES:
:CUSTOM_ID: h:06290f9c-491c-45b2-b213-0248f890c83d
:END:

=ibuffer.el= ships with Emacs and it provides a drop-in replacement for
=list-buffers=.  Compared to its counterpart, it allows for granular
control over the buffer list and is more powerful overall.  For this
reason I bind it to =C-x C-b=.

Overview of its features:

- mark and delete buffers same way you do in =dired= (see the previous
  sections on [[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][dired (directory editor, file manager)]]);
- mark by a predicate, such as name, major mode, etc.;
- sort buffers by name, filesystem path, major mode, size;
- run =occur= on the marked buffers (remember: Occur produces a buffer
  that you can edit once you enable the editable state with =e=);
- run =query-replace= or =query-replace-regexp= on marked buffers.

Run the universal help command for major mode documentation (=C-h m=)
while inside =ibuffer= to get a detailed list of all available commands
and their key bindings.

With regard to the following package configurations, these are my tweaks
to the default behaviour and presentation:

+ Prompt for confirmation only when deleting a modified buffer.
+ Hide the summary.
+ Do not open on the other window; use the current one.
+ Do not show empty filter groups.
+ Do not cycle movements.  So do not go to the top when moving downward
  at the last item on the list.

Also watch my [[https://protesilaos.com/codelog/2020-04-02-emacs-intro-ibuffer/][introduction to Ibuffer]] (2020-04-02).

Now some extras that I introduced after I published that video, which
pertain to my =prot-ibuffer.el= library (copied in its entirety below the
package configurations):

+ =prot-ibuffer-buffers-major-mode= produces a filtered list of buffers
  that match the major mode of the current buffer and lets you pick one
  using minibuffer completion.  With an optional prefix argument (=C-u=)
  it places the results in an Ibuffer list.

+ =prot-ibuffer-buffers-vc-root= filters the list to items that match the
  current buffer's version-controlled directory.  In practice, this
  fills the same niche as the built-in =project-switch-to-buffer= (for
  Emacs 28+), with the crucial difference that it neither reads from nor
  writes to the list of known projects (also check my configurations for
  [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Projects (project.el and prot-project.el)]]).  When called with an
  optional prefix argument, this command puts its matching candidates in
  an Ibuffer view.

For those two I received guidance from Omar Antolín Camarena with regard
to the use of =read-buffer= and the =lambda= passed to it (any errors are my
own).  This method informs other tools that this type of completion
pertains to buffers, so they can adapt accordingly.  See, in particular,
[[#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984][Extended minibuffer actions and more (embark.el and prot-embark.el)]].

#+begin_src emacs-lisp
;;; Ibuffer and extras (dired-like buffer list manager)
(prot-emacs-builtin-package 'ibuffer
  (setq ibuffer-expert t)
  (setq ibuffer-display-summary nil)
  (setq ibuffer-use-other-window nil)
  (setq ibuffer-show-empty-filter-groups nil)
  (setq ibuffer-movement-cycle nil)
  (setq ibuffer-default-sorting-mode 'filename/process)
  (setq ibuffer-use-header-line t)
  (setq ibuffer-default-shrink-to-minimum-size nil)
  (setq ibuffer-formats
        '((mark modified read-only locked " "
                (name 40 40 :left :elide)
                " "
                (size 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " " filename-and-process)
          (mark " "
                (name 16 -1)
                " " filename)))
  (setq ibuffer-saved-filter-groups nil)
  (setq ibuffer-old-time 48)
  (add-hook 'ibuffer-mode-hook #'hl-line-mode)
  (define-key global-map (kbd "C-x C-b") #'ibuffer)
  (let ((map ibuffer-mode-map))
    (define-key map (kbd "* f") #'ibuffer-mark-by-file-name-regexp)
    (define-key map (kbd "* g") #'ibuffer-mark-by-content-regexp) ; "g" is for "grep"
    (define-key map (kbd "* n") #'ibuffer-mark-by-name-regexp)
    (define-key map (kbd "s n") #'ibuffer-do-sort-by-alphabetic)  ; "sort name" mnemonic
    (define-key map (kbd "/ g") #'ibuffer-filter-by-content)))

(prot-emacs-builtin-package 'prot-ibuffer
  (let ((map global-map))
    (define-key map (kbd "M-s b") #'prot-ibuffer-buffers-major-mode)
    (define-key map (kbd "M-s v") #'prot-ibuffer-buffers-vc-root)))
#+end_src

Here is =prot-ibuffer.el= (find everything in [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-ibuffer.el src emacs-lisp :tangle no

** Window configuration
:PROPERTIES:
:CUSTOM_ID: h:12591f89-eeea-4b12-93e8-9293504e5a12
:END:

I believe that Emacs' true power lies in its buffer management rather
than its multiplexing.  The latter becomes inefficient at scale, since
it tries to emulate the limitations of the real world, namely, the
placement of things on a desk.

By leveraging the power of the computer, we can use search methods to
easily reach any item.  There is no need to remain confined to the idea
of a finite space (screen real estate) that needs to be carefully
managed.

That granted, Emacs' multiplexing can be turned into a powerhouse as
well, covering everything from window placement rules, to the recording
of history and layouts, as well as directional or direct window
navigation.

*** Window rules and basic tweaks (window.el)
:PROPERTIES:
:CUSTOM_ID: h:3d8ebbb1-f749-412e-9c72-5d65f48d5957
:END:

The =display-buffer-alist= is intended as a rule-set for controlling the
placement of windows.  This is mostly needed for ancillary buffers, such
as shells, compilation output, and the like.  The objective is to create
a more intuitive workflow where targeted buffer groups or types are
always shown at a given location, on the premise that predictability
improves usability.

For each buffer action in =display-buffer-alist= we can define several
functions for selecting the appropriate window.  These are executed in
sequence, but my usage thus far suggests that a simpler method is just
as effective for my case.

Everything pertaining to buffer actions is documented at length in the
GNU Emacs Lisp Reference Manual (evaluate =(elisp) Displaying Buffers=).
Information can also be found at all times via =C-h f display-buffer= and,
for my particular settings, with =C-h f display-buffer-in-side-window=.

With regard to the key bindings you will find here, most combinations
are complementary to the standard ones, such as =C-x 1= being aliased as
=s-1=, =C-x o= turning into =s-o= and the like.  They *do not replace* the
defaults: they just provide more convenient access to their
corresponding functions.  Some involve the Super key, in accordance with
the norms described in the relevant [[#h:fbba4dea-9cc8-4e73-bffa-02aab10a6703][note on the matter]].  Concerning the
=balance-windows-area= I find that it is less intrusive than the original
=balance-windows= normally bound to the same =C-x +=.  Lastly, the
=resize-window-repeat-map= is for repeatable key chords that work with the
=repeat-mode= for Emacs28 (read my description of what it is and how to
set it up: [[#h:33d9a35a-54ed-4f9d-8f30-5c99c1a45ad0][Repeatable key chords (repeat-mode)]]).

Make sure to also review the other window-related keys in those
sections:

+ [[#h:6b4f7792-6ccd-45d5-b262-01d200639072][Window history (winner-mode)]].
+ [[#h:230d96c8-a955-4b82-844d-9de9a1b7c531][Directional window motions (windmove)]].

For a demo of the =display-buffer-alist= and the functions that
accompany it, watch my [[https://protesilaos.com/codelog/2020-01-07-emacs-display-buffer/][video on rules for buffer placement]]
(2020-01-07).

#+begin_src emacs-lisp
;;; Window rules and basic tweaks (window.el)
(prot-emacs-builtin-package 'window
  (setq display-buffer-alist
        `(;; no window
          ("\\`\\*Async Shell Command\\*\\'"
           (display-buffer-no-window))
          ;; top side window
          ("\\**prot-elfeed-bongo-queue.*"
           (display-buffer-reuse-window display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . -2))
          ("\\*\\(prot-elfeed-mpv-output\\|world-clock\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . -1))
          ("\\*\\(Flymake diagnostics\\|Package-Lint\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 0))
          ("\\*Messages.*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 1))
          ("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\|Flymake log\\)\\*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 2))
          ;; left side window
          ("\\*\\(.* # Help.*\\|Help\\)\\*"    ; See the hooks for `visual-line-mode'
           (display-buffer-reuse-mode-window display-buffer-in-side-window)
           (window-width . 0.25)
           (side . left)
           (slot . 0))
          ;; right side window
          ("\\*keycast\\*"
           (display-buffer-in-side-window)
           (dedicated . t)
           (window-width . 0.25)
           (side . right)
           (slot . -1)
           (window-parameters . ((no-other-window . t)
                                 (mode-line-format . none))))
          ;; bottom side window
          ("\\*Org Select\\*"
           (display-buffer-in-side-window)
           (dedicated . t)
           (side . bottom)
           (slot . 0)
           (window-parameters . ((mode-line-format . none))))
          ;; bottom buffer (NOT side window)
          ("\\*Embark Actions\\*"
           (display-buffer-reuse-mode-window display-buffer-at-bottom)
           (window-height . fit-window-to-buffer)
           (window-parameters . ((no-other-window . t)
                                 (mode-line-format . none))))
          ;; ("\\*\\(Embark\\)?.*Completions.*"
          ;;  (display-buffer-reuse-mode-window display-buffer-at-bottom)
          ;;  (window-parameters . ((no-other-window . t))))
          ("\\*\\(Output\\|Register Preview\\).*"
           (display-buffer-reuse-mode-window display-buffer-at-bottom))
          ;; below current window
          ("\\*.*\\(e?shell\\|v?term\\).*"
           (display-buffer-reuse-mode-window display-buffer-below-selected))
          ("\\*\\vc-\\(incoming\\|outgoing\\|git : \\).*"
           (display-buffer-reuse-mode-window display-buffer-below-selected)
           ;; NOTE 2021-10-06: we cannot `fit-window-to-buffer' because
           ;; the height is not known in advance.
           (window-height . 0.2))
          ("\\*\\(Calendar\\|Bookmark Annotation\\).*"
           (display-buffer-reuse-mode-window display-buffer-below-selected)
           (window-height . fit-window-to-buffer))))
  (setq window-combination-resize t)
  (setq even-window-sizes 'height-only)
  (setq window-sides-vertical nil)
  (setq switch-to-buffer-in-dedicated-window 'pop)

  (add-hook 'help-mode-hook #'visual-line-mode)
  (add-hook 'custom-mode-hook #'visual-line-mode)

  (let ((map global-map))
    (define-key map (kbd "C-x <down>") #'next-buffer)
    (define-key map (kbd "C-x <up>") #'previous-buffer)
    (define-key map (kbd "C-x C-n") #'next-buffer)     ; override `set-goal-column'
    (define-key map (kbd "C-x C-p") #'previous-buffer) ; override `mark-page'
    (define-key map (kbd "C-x !") #'delete-other-windows-vertically)
    (define-key map (kbd "C-x _") #'balance-windows)      ; underscore
    (define-key map (kbd "C-x -") #'fit-window-to-buffer) ; hyphen
    (define-key map (kbd "C-x +") #'balance-windows-area)
    (define-key map (kbd "C-x }") #'enlarge-window)
    (define-key map (kbd "C-x {") #'shrink-window)
    (define-key map (kbd "C-x >") #'enlarge-window-horizontally) ; override `scroll-right'
    (define-key map (kbd "C-x <") #'shrink-window-horizontally)) ; override `scroll-left'
  (let ((map resize-window-repeat-map))
    (define-key map ">" #'enlarge-window-horizontally)
    (define-key map "<" #'shrink-window-horizontally)))
#+end_src

*** Window history (winner-mode)
:PROPERTIES:
:CUSTOM_ID: h:6b4f7792-6ccd-45d5-b262-01d200639072
:END:

Also check: [[#h:230d96c8-a955-4b82-844d-9de9a1b7c531][Directional window motions (windmove)]].

Winner is a built-in tool that keeps a record of buffer and window
layout changes.  It then allows us to move back and forth in the history
of said changes.  As noted in the section about the =tab-bar=, the main
problem with Winner is that it cannot keep parallel histories, each for
a given tab (see [[#h:63ad472f-c9c2-40ad-9675-1dc529487788][Tabs for window layouts (tab-bar.el and prot-tab.el)]]).
The alternative is to use =tab-bar-history-mode= and the commands it
provides or, more specifically, the wrappers I have defined which fall
back to Winner when tabs are not in use.

#+begin_src emacs-lisp
;;; Window history (winner-mode)
(prot-emacs-builtin-package 'winner
  (add-hook 'after-init-hook #'winner-mode)

  ;; ;; NOTE 2021-07-31: Those are superseded by the commands
  ;; ;; `prot-tab-winner-undo' and `prot-tab-winner-redo' in prot-tab.el
  ;; ;; (search this document).
  ;; (let ((map global-map))
  ;;   (define-key map (kbd "C-x <right>") #'winner-redo)
  ;;   (define-key map (kbd "C-x <left>") #'winner-undo))
  )
#+end_src

*** Directional window motions (windmove)
:PROPERTIES:
:CUSTOM_ID: h:230d96c8-a955-4b82-844d-9de9a1b7c531
:END:

Windmove is also built into Emacs.  It provides functions for selecting
a window in any of the cardinal directions: a decent addition to the
simpler =other-window= command (=C-x o= by default).  It also has commands
for deleting a window in the given direction as well as for switching
the current window with the one in the given direction.  I do not need
the directional deletion motions, as they require extra key bindings
while I feel that it is easy enough to select a window and delete it
outright with =delete-window= (on =C-x 0= by default).

The =windmove-create-window= variable specifies what should happen when
trying to move past the edge of the frame.  The idea with this is to
allow it to create a new window with the contents of the current buffer.
I tried it for a while but felt that the times it would interfere with
my layout by mistake where more than those it would actually speed up my
workflow.

Also read: [[#h:6b4f7792-6ccd-45d5-b262-01d200639072][Window history (winner-mode)]].

#+begin_src emacs-lisp
;;; Directional window motions (windmove)
(prot-emacs-builtin-package 'windmove
  (setq windmove-create-window nil)     ; Emacs 27.1
  (let ((map global-map))
    ;; Those override some commands that are already available with
    ;; C-M-u, C-M-f, C-M-b.
    (define-key map (kbd "C-M-<up>") #'windmove-up)
    (define-key map (kbd "C-M-<right>") #'windmove-right)
    (define-key map (kbd "C-M-<down>") #'windmove-down)
    (define-key map (kbd "C-M-<left>") #'windmove-left)
    (define-key map (kbd "C-M-S-<up>") #'windmove-swap-states-up)
    (define-key map (kbd "C-M-S-<right>") #'windmove-swap-states-right) ; conflicts with `org-increase-number-at-point'
    (define-key map (kbd "C-M-S-<down>") #'windmove-swap-states-down)
    (define-key map (kbd "C-M-S-<left>") #'windmove-swap-states-left)))
#+end_src

*** Tabs for window layouts (tab-bar.el and prot-tab.el)
:PROPERTIES:
:CUSTOM_ID: h:63ad472f-c9c2-40ad-9675-1dc529487788
:END:

Starting with version 27.1, Emacs has built-in support for two distinct
concepts of "tabs":

1. Work spaces that contain windows in any given layout.
2. A list of buffers presented as buttons at the top of the window.

The former, represented by the =tab-bar= library, is best understood as
the equivalent of "virtual desktops", as these are used in most desktop
environments or window managers.

The latter, implemented in =tab-line=, is the same as the tabs you are
used to in web browsers.  Each buffer is assigned to a single tab.
Clicking on the tab takes you to the corresponding buffer.

I do not need the =tab-line= as I find such tabs to be inefficient at
scale.  Finding a buffer through search mechanisms is generally faster:
it does not matter whether you have ten or a hundred buffers on the list
(unless, of course, they all have similar names in which case you are in
trouble either way---do not forget to check my [[#h:06290f9c-491c-45b2-b213-0248f890c83d][Ibuffer settings]]).

On the other hand, the work spaces (=tab-bar=) are very useful for
organising the various applications that are running inside of Emacs.
You can, for example, have your current project on tab (workspace) 1,
your email and news reader on 2, music on 3, and so on.  Of course, this
can also be achieved by using separate frames for each of these, though
I generally prefer working in a single frame (plus you can define a
window configuration or frameset in a register).

Starting with Emacs 28, the =tab-bar= can re-use indicators from the mode
line.  With a bit of tweaking (and dirty hacks---but, hey, they work!)
we can hide all mode lines and replace them with a single status bar
that spans the length of the frame (just like the Tmux status line, if
you have ever used that).  I was aware of this possibility for a long
time, as I keep track of developments in emacs.git, but I never actually
tinkered with the available options...  Until Philip Kaludercic
published the article [[http://ruzkuku.com/texts/emacs-global.html][Emacs 28 has a global mode line]] (2021-07-29) which
inspired me to finally start experimenting.

As of this writing (2021-07-30), upstream Emacs only covers the part of
the mode line that shows the current time and the like (technically the
=global-mode-string=).  So my =prot-tab.el= library, which is reproduced
after the following package configurations, implements some more
indicators that I want to use.

The minor mode which takes care of this new "status line" concept is
=prot-tab-status-line=.  Check the code to notice the dirty hacks I
alluded to.

In the past, I was using a command which would merely toggle the display
of the =tab-bar= (=prot-tab-bar-toggle=), but now that I can finally avoid
the duplication of information and keep things cleaner, I think I am not
going back to the paradigm where each window has its own mode line.

To learn about the key bindings that the =tab-bar= uses, type its prefix
key =C-x t= and follow it up with =C-h= (read [[#h:83730fe8-d917-4d94-96f4-bbc5c900fe38][How do you learn Emacs?]]).

Finally, now that =tab-bar-history-mode= is a de facto replacement for
=winner-mode=.  Like Winner, it stores a history of window layouts.
Unlike Winner, it keeps histories that are specific to each tab.  The
problem with Winner is that when we switch between tabs, it continues to
retain a linear history, so when we try to undo in one tab, we
effectively get the state of the previous one.  As such, my two commands
=prot-tab-winner-undo= and =prot-tab-winner-redo= provide thin wrappers
around the two modes.  If tabs are present, then we use the history for
them, else we fall back to Winner.

Here are my settings, followed by the entirety of =prot-tab.el=.

#+begin_src emacs-lisp
;;; Tabs for window layouts (tab-bar.el and prot-tab.el)
(prot-emacs-builtin-package 'tab-bar
  (setq tab-bar-close-button-show nil)
  (setq tab-bar-close-last-tab-choice nil)
  (setq tab-bar-close-tab-select 'recent)
  (setq tab-bar-new-tab-choice t)
  (setq tab-bar-new-tab-to 'right)
  (setq tab-bar-position nil)
  (setq tab-bar-show nil)
  (setq tab-bar-tab-hints nil)
  (setq tab-bar-tab-name-function 'tab-bar-tab-name-current)

  (tab-bar-mode -1)                     ; see `prot-tab-status-line'

  ;; Same concept as `winner-mode'.  See the `prot-tab-winner-undo' and
  ;; its counterpart.
  (tab-bar-history-mode 1))

(prot-emacs-builtin-package 'prot-tab
  (setq prot-tab-tab-select-num-threshold 3)
  (setq tab-bar-format                    ; Emacs 28
        '(prot-tab-format-space-single
          prot-tab-format-mule-info
          prot-tab-format-modified
          tab-bar-format-tabs-groups
          prot-tab-format-space-double
          prot-tab-format-position
          prot-tab-format-space-double
          prot-tab-format-vc
          prot-tab-format-space-double
          prot-tab-format-modes         ; FIXME 2021-07-30: Make it work with `minions'.
          tab-bar-format-align-right
          prot-tab-format-misc-info
          prot-tab-format-space-double
          tab-bar-format-global
          prot-tab-format-space-single))

  (add-hook 'after-init-hook #'prot-tab-status-line)

  (let ((map global-map))
    (define-key map (kbd "C-x <right>") #'prot-tab-winner-redo)
    (define-key map (kbd "C-x <left>") #'prot-tab-winner-undo)
    (define-key map (kbd "<f8>") #'prot-tab-status-line) ; unopinionated alternative: `prot-tab-bar-toggle'
    (define-key map (kbd "C-x t t") #'prot-tab-select-tab-dwim)))

;; ;; This is only included as a reference.
;; (prot-emacs-builtin-package 'tab-line
;;   (global-tab-line-mode -1))
#+end_src

The =prot-tab.el= code, which is in [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]:

#+include: prot-lisp/prot-tab.el src emacs-lisp :tangle no

*** Transposition and rotation of windows
:PROPERTIES:
:CUSTOM_ID: h:753ea060-57e4-4dba-9bf9-b6337e478839
:END:

The =transpose-frame= library defines a set of commands for shifting the
layout of Emacs windows.  Rather than me describing how these work, I
strongly encourage you to read the "Commentary" section in the source
code.  Do it with =M-x find-library transpose-frame=.

Remember that you can always repeat a command with =C-x z=.  And if you
have the right settings, you can repeat again just by pressing another =z=
(see [[#h:33d9a35a-54ed-4f9d-8f30-5c99c1a45ad0][Repeatable key chords (repeat-mode)]]).

#+begin_src emacs-lisp
;;; Transposition and rotation of windows
(prot-emacs-elpa-package 'transpose-frame
  (let ((map global-map))
    (define-key map (kbd "C-x M-r") #'rotate-frame-clockwise)))
#+end_src

* Applications and utilities
:PROPERTIES:
:CUSTOM_ID: h:fa8bd8af-de14-489b-bc56-1a9bb3ef9f0f
:END:

This section includes configurations for programs like email clients,
news reader, music players…  Anything you would normally see in a
standalone application.  The end goal is to eventually integrate every
aspect of my computing inside of Emacs.

** Built-in bookmarking framework (bookmark.el and prot-bookmark.el)
:PROPERTIES:
:CUSTOM_ID: h:79cd6177-a81b-420f-8759-e6927b974377
:END:

Bookmarks are compartments that store data persistently about a file,
directory, Info node, Man or WoMan page, image-mode entry, Docview or
pdf-tools document, Eshell buffer...  Basically there can be a bookmark
for anything that Emacs can access, as long as it has a handler function
configured for it.  Do =M-x apropos-function= and search for =bookmark jump=
to see what is on offer (packages can add their own support).

When you set a bookmark with the command =bookmark-set= (bound by default
to =C-x r m=), Emacs remembers both the current item and, when data
persists on disk, the position of the point in it.  The command prompts
you for a name, which wil make it easier for you to retrieve the
information afterwards.  Alternatively, use =bookmark-set-no-overwrite=
(=C-x r M=) to prevent yourself from overriding existing bookmarks (though
I generally prefer to write meaningful names for my entries).

To access bookmarks with minibuffer completion, invoke the command
=bookmark-jump= (=C-x r b=).  To get an overview in a tabulated list, call
=list-bookmarks= (=C-x r l=).

If you would like to browse bookmarks (and other sources such as recent
files) through an all-in-one interface, use the =consult-buffer= command
(see [[#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb][Enhanced minibuffer commands (consult.el and prot-consult.el)]]).
Consult also offers the command =consult-bookmark= which is like the
standard =bookmark-jump= except that it also has support for group
headings (so all files are under one heading, all Info nodes in
another).  I thus consider it a drop-in replacement for =C-x r b=.

The =list-bookmarks= interface provides several commands for visiting, or
deleting bookmarks.  Use =C-h m= (=describe-mode=) to get a help buffer with
an explanation of what those are (and remember to make best use of
Emacs' self-documentation system: [[#h:83730fe8-d917-4d94-96f4-bbc5c900fe38][How do you learn Emacs?]]).

Internally, bookmarks are similar to registers.  As such, I encourage
you to read the official manual on the matter by evaluating this form:
=(info "(emacs) Registers")=.  Also watch my [[https://protesilaos.com/codelog/2020-03-08-emacs-registers/][Primer on Emacs “registers”]]
(2020-03-08).

=bookmark.el= offers a few customisation options, though I find that the
out-of-the-box design works well for my needs.  What I am still not sure
about is the option to query for a longer form annotation (the variable
=bookmark-use-annotations=) /while recording a new bookmark/.  It pops up a
buffer where you can write a note on what is about to be recorded.  The
note will appear in a separate buffer while visiting that bookmark (for
its placement see [[#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][Window rules and basic tweaks (window.el)]]).  To skip
annotating the bookmark, just do not insert any text and either kill the
buffer or type =C-c C-c= to accept the empty annotation.  In such a case,
no buffer will pop up while visiting the bookmark.  Perhaps a less
intrusive alternative is to annotate bookmarks after the fact, through
the =list-bookmarks= view by typing =e= with point over the entry of
interest.

Speaking of the =list-bookmarks= view, items with an annotation have an
asterisk prepended to their line.  With point over such a line, type =a=
to produce a buffer with the contents of the annotation, or =A= to show
all bookmarks with their annotations or lack thereof.

On the presentation front, Emacs28 adds a fringe marker on the line
where a bookmark is set or on the line where you land after visiting a
bookmark.  This is controlled by the variable =bookmark-set-fringe-mark=.
While my =prot-bookmark.el= (reproduced after the following package
configurations) defines some extra faces for the =list-bookmarks= view.
Those help differentiate URLs from files, PDFs, and directories, though
it is a work-in-progress and will likely cover more cases.

URL bookmarks are handled by my =prot-eww.el= extensions, by means of a
custom handler that leverages the standard =bookmark.el= framework instead
of the EWW-only bookmarking facility that is available by default
([[#h:524bc702-ff55-4ed9-9a38-26d30d64591d][Simple HTML Renderer, Emacs Web Wowser, Elpher, prot-eww.el]]).

Also watch: [[https://protesilaos.com/codelog/2021-09-08-emacs-bookmarks-intro/][Primer on Emacs bookmarks]] (2021-09-08).

#+begin_src emacs-lisp
;;; Built-in bookmarking framework (bookmark.el and prot-bookmark.el)
(prot-emacs-builtin-package 'bookmark
  (setq bookmark-use-annotations nil)
  (setq bookmark-automatically-show-annotations t)
  (setq bookmark-set-fringe-mark t) ; Emacs28

  (add-hook 'bookmark-bmenu-mode-hook #'hl-line-mode))

(prot-emacs-builtin-package 'prot-bookmark
  (prot-bookmark-extra-keywords 1))
#+end_src

Here is =prot-bookmark.el= (from [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-bookmark.el src emacs-lisp :tangle no

*** Ibuffer-like bookmark list (blist.el)
:PROPERTIES:
:CUSTOM_ID: h:67b7944e-6398-44a8-91d6-79e423b3e5f1
:END:

/NOTE 2021-09-16: Work-in-progress./

This is a new package by Sévère Durand which makes the listing of
bookmarks look more organised and provides many functions for operating
on them, just like how =ibuffer= does it:

1. [[#h:79cd6177-a81b-420f-8759-e6927b974377][Built-in bookmarking framework (bookmark.el and prot-bookmark.el)]].
2. [[#h:06290f9c-491c-45b2-b213-0248f890c83d][Ibuffer and extras (dired-like buffer list manager)]].

Durand is also the author of the useful =rlist= package, which lets you
see your registers in a list and, optionally, delete the ones you no
longer need ([[#h:aad79917-cd80-491b-9020-db27867ab132][Dired-like list for registers (rlist)]]).

#+begin_src emacs-lisp
;;; Ibuffer-like bookmark list (blist.el)
;; Project repo: <https://gitlab.com/mmemmew/blist>.  Its dependency is
;; `ilist', by the same author: <https://gitlab.com/mmemmew/blist>.
;;
;; I handle those manually via git, at least until they become available
;; through an ELPA.
;;
;; `prot-emacs-manual-package' is defined in my init.el
(prot-emacs-elpa-package 'ilist)

(prot-emacs-elpa-package 'blist
  (setq blist-expert t)
  (setq blist-discard-empty-p t)

  ;; NOTE 2021-09-16: This package is still in its early days.  Things
  ;; will change.
  (with-eval-after-load 'prot-eww
    (blist-define-criterion "eww" "EWW"
      (eq (bookmark-get-handler bookmark)
          #'prot-eww-bookmark-jump)))

  (with-eval-after-load 'prot-eshell
    (blist-define-criterion "eshell" "Eshell"
      (eq (bookmark-get-handler bookmark)
          #'prot-eshell-bookmark-jump)))

  (blist-define-criterion "info" "Info"
    (eq (bookmark-get-handler bookmark)
        #'Info-bookmark-jump))

  (with-eval-after-load 'pdf-tools
    (blist-define-criterion "pdf" "PDF"
      (eq (bookmark-get-handler bookmark)
          #'pdf-view-bookmark-jump-handler)))

  (setq blist-filter-groups
        (list
         (cons "EWW" #'blist-eww-p)
         (cons "Eshell" #'blist-eshell-p)
         (cons "PDF" #'blist-pdf-p)
         (cons "Info" #'blist-info-p)
         (cons "Default" #'blist-default-p)))

  (define-key global-map (kbd "C-x r l") #'blist-list-bookmarks))
#+end_src

** Custom extensions for "focus mode" (prot-logos.el)
:PROPERTIES:
:CUSTOM_ID: h:77d14350-978d-4820-ab7f-4641706c445a
:END:

My =prot-logos.el= (copied verbatim after the package configurations)
provides the necessary infrastructure for my preferred "focus mode"
aesthetic.  Everything is controlled by =prot-logos-focus-mode=.  Bind
that to a key and you are good to go.  An overview of its components,
which are contingent on other features:

+ Olivetti (centred buffer content) :: I spend much of my time in Emacs
  reading and writing long form texts.  It is nice to be able to easily
  toggle a mode that centres the buffer, allowing for greater comfort.
  Olivetti covers that niche very nicely.  It is not aggressive in its
  requirements, which is important to play well with my paragraph and
  fill-mode settings ([[#h:1ae84fae-efc1-4bcc-9542-55b4ab8391a3][Paragraphs and fill-mode (prot-fill.el)]]): it
  respects my existing line length and my preference for auto-filling
  text, while it does not introduce any kind of functionality beyond the
  scope of bringing the current window's buffer to the centre of the
  view.  This is exactly what I need.  Any other enhancement, such as a
  larger font size can be delegated to a specialised instrument.  Thanks
  to Paul W. Rankin for providing such a nimble tool!  For =prot-logos=
  Olivetti always gets activated.

+ =variable-pitch-mode= (mixed fonts) :: This is a built-in mode that
  remaps the =default= face's font family to a proportionately spaced one
  (also see [[#h:e03b6415-a18f-4058-b9b0-5721d38c6c50][Font configurations (prot-fonts.el)]]).  It can produce a
  prose-friendly presentation, especially if the =variable-pitch= face is
  set to some nice font family.  As the effect is not particularly good
  in =prog-mode= buffers, due to misalignments in spacing and indentation,
  =prot-logos= only applies variable width fonts in =text-mode= buffers.
  The activation is further controlled by =prot-logos-variable-pitch= (off
  by default).  Bear in mind that =variable-pitch-mode= is quite
  aggressive in its application, as it affects all other faces, unless
  the active theme (or some minor mode) makes provisions to retain fixed
  typographic spacing for those elements that require it, such as code
  blocks and inline code elements, tables, and indentation (refer to
  [[#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6][Modus themes (my highly accessible themes)]]).

+ =org-tree-slide= and =org-indent= :: The former is a third-party package
  and the latter is part of the Org distribution.  What the first does
  is convert headings into pseudo slides.  While the other indents
  content visually, without actually affecting the underlying initial
  spacing, to match the heading's depth.  Those two are disabled by
  default and the =prot-logos-org-presentation= toggle determines whether
  they should be activated.

+ Scroll lock :: Sometimes you want the cursor to remain centred on the
  screen while your focus is on writing or reading.  This is controlled
  by the variable =prot-logos-scroll-lock= (off by default), which
  controls the activation of the built-in =scroll-lock-mode=.

+ Modeline :: The variable =prot-logos-hidden-modeline= (off by default)
  can be set to =t= to hide the modeline while entering the focused state.
  For me this is mostly useful for presentations.

+ Fringes :: There is also a function that unconditionally disables
  fringes on the edge of the window.  It ensures that we do not see that
  area and any indicators that may be placed on it while entering the
  focus state (refer to [[#h:26a4fac6-33e2-4f6c-8589-9463df8525c9][Fringe mode]] for the relevant configurations,
  while their overall presentation is controlled by the active theme).

+ Cursor :: My =prot-cursor.el= defines some convenient extras for setting
  the overall style of the cursor: the shape and the blink rate.  When
  in a "focus mode" we may want to have one particular style available,
  which differs from the default (for all the technicalities refer to
  [[#h:cf9086c1-1b33-4127-a716-de94259e14a0][Cursor appearance and tweaks (prot-cursor.el)]]).

All those combined contribute to an outcome that is appropriate for long
reading or writing sessions, as well as presentations.  I intentionally
do not introduce any font-resizing effect, as my needs vary in that
regard depending on the context (though do refer to the =prot-fonts.el= I
linked to earlier).

For video demonstrations, albeit with earlier versions of my code, watch
these:

+ [[https://protesilaos.com/codelog/2020-07-16-emacs-focused-editing/][“Focused editing” tools for Emacs]] (2020-07-16)
+ [[https://protesilaos.com/codelog/2020-07-17-emacs-mixed-fonts-org/][Configuring mixed fonts for Org mode and others]] (2020-07-17)

#+begin_src emacs-lisp
;;; Custom extensions for "focus mode" (prot-logos.el)
(prot-emacs-builtin-package 'face-remap)

(prot-emacs-elpa-package 'olivetti
  (setq olivetti-body-width 0.7)
  (setq olivetti-minimum-body-width 80)
  (setq olivetti-recall-visual-line-mode-entry-state t))

(prot-emacs-elpa-package 'org-tree-slide
  (setq org-tree-slide-breadcrumbs nil)
  (setq org-tree-slide-header nil)
  (setq org-tree-slide-slide-in-effect nil)
  (setq org-tree-slide-heading-emphasis nil)
  (setq org-tree-slide-cursor-init t)
  (setq org-tree-slide-modeline-display nil)
  (setq org-tree-slide-skip-done nil)
  (setq org-tree-slide-skip-comments t)
  (setq org-tree-slide-fold-subtrees-skipped t)
  (setq org-tree-slide-skip-outline-level 8)
  (setq org-tree-slide-never-touch-face t)
  (setq org-tree-slide-activate-message
        (format "Presentation %s" (propertize "ON" 'face 'success)))
  (setq org-tree-slide-deactivate-message
        (format "Presentation %s" (propertize "OFF" 'face 'error)))
  (let ((map org-tree-slide-mode-map))
    (define-key map (kbd "<C-down>") #'org-tree-slide-display-header-toggle)
    (define-key map (kbd "<C-right>") #'org-tree-slide-move-next-tree)
    (define-key map (kbd "<C-left>") #'org-tree-slide-move-previous-tree)))

(prot-emacs-builtin-package 'prot-logos
  (setq prot-logos-org-presentation nil)
  (setq prot-logos-variable-pitch nil)
  (setq prot-logos-scroll-lock nil)
  (setq prot-logos-hidden-modeline t)
  (setq prot-logos-affect-prot-cursor t)
  (define-key global-map (kbd "<f9>") #'prot-logos-focus-mode))
#+end_src

And here is =prot-logos.el= in its totality.  It is available as a file in
[[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]] (same for all my Emacs libraries):

#+include: prot-lisp/prot-logos.el src emacs-lisp :tangle no

** USLS --- Unassuming Sidenotes of Little Significance
:PROPERTIES:
:CUSTOM_ID: h:787df548-0d95-4512-a61d-27852198f561
:END:

NOTE 2021-12-29: USLS is subject to a rewrite.  I have been using it
daily since its inception, though the code needs to be refactored.  As a
proof-of-concept of its utility, check out my =invtr= (only for curious
hackers, not actual users): [[#h:c66a0f25-840a-49f0-a615-66dfca61890b][INVTR (toy inventory and client manager)]].

This is a library that I am developing to help me flesh out my
note-taking system.  In essence, =usls= is a set of helper functions
around standard Emacs tools, such as =find-file=, =dired=, and internal
libraries like =thingatpt=.  It has no external dependencies whatsoever.
This blog post of mine documents the principles and general ideas about
it: [[https://protesilaos.com/codelog/2020-10-08-intro-usls-emacs-notes/][My simple note-taking system for Emacs (without Org)]] (2020-10-08).

Because this is standard Emacs stuff, I can always benefit from the rest
of my setup, such as to search for file contents in the current
directory.  Study the entirety of my [[#h:98d3abcc-f34e-4029-aabc-740f0b6421f8][Completion framework and extras]].

In the =usls.el= code I wanted to respect key binding conventions, so I
did not bind any keys: this is a user-level customisation.  The other
options I have here are for the sake of visibility and are left to their
default values.

The code for this project is on the [[https://gitlab.com/protesilaos/usls][USLS Gitlab repo]] and reproduced in
the subsequent code block.

#+begin_src emacs-lisp
;;; USLS --- Unassuming Sidenotes of Little Significance
(prot-emacs-builtin-package 'usls
  (setq usls-directory (expand-file-name "~/Documents/notes/"))
  (setq usls-known-categories '("economics" "philosophy" "politics"))
  (setq usls-file-type-extension ".txt") ; {.txt,.org,.md}
  (setq usls-subdir-support nil)
  (setq usls-file-region-separator 'line) ; {'line,'heading, OR string of your choice}
  (setq usls-file-region-separator-heading-level 1)
  (setq usls-custom-header-function nil)

  (add-hook 'usls-mode-hook #'goto-address-mode)

  (let ((map global-map))               ; globally bound keys
    (define-key map (kbd "C-c n d") #'usls-dired)
    (define-key map (kbd "C-c n f") #'usls-find-file)
    (define-key map (kbd "C-c n a") #'usls-append-region-buffer-or-file)
    (define-key map (kbd "C-c n n") #'usls-new-note))
  (let ((map usls-mode-map))            ; only for usls buffers
    (define-key map (kbd "C-c n i") #'usls-id-insert)
    (define-key map (kbd "C-c n l") #'usls-follow-link)))
#+end_src

Here is the =usls.el= code, which is also part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]] (as
with all my Elisp code):

#+include: prot-lisp/usls.el src emacs-lisp :tangle no

** INVTR (toy inventory and client manager)
:PROPERTIES:
:CUSTOM_ID: h:c66a0f25-840a-49f0-a615-66dfca61890b
:END:

I am intentionally not documenting this because it is not intended for
public use.  It is a *highly experimental proof-of-concept* of a nimble
inventory and client manager that extends the file-naming methodology of
my USLS (see [[#h:787df548-0d95-4512-a61d-27852198f561][USLS --- Unassuming Sidenotes of Little Significance]]).

#+begin_src emacs-lisp
;;; INVTR (toy inventory and client manager)
;; DO NOT USE THIS!!!
(prot-emacs-builtin-package 'invtr)
#+end_src

#+include: prot-lisp/invtr.el src emacs-lisp :tangle no

** tmr.el (TMR Must Recur)
:PROPERTIES:
:CUSTOM_ID: h:c90ba6fa-ebec-42a2-98a6-3ff9027b1ffa
:END:

Sometimes I need to set off a timer with a notification.  I used to rely
on a homegrown shell script for such a task, but where is the fun in
that?

This package of mine provides a single command for setting a timer: =tmr=.

The command prompts for a unit of time, which is represented as a string
that consists of a number and, optionally, a single character suffix
which specifies the unit of time.

Valid formats:

| Input | Meaning   |
|-------+-----------|
| 5     | 5 minutes |
| 5m    | 5 minutes |
| 5s    | 5 seconds |
| 5h    | 5 hours   |

If =tmr= is called with an optional prefix argument (=C-u=), it also asks
for a description which accompanies the given timer.  Preconfigured
candidates are specified in the user option =tmr-descriptions-list=,
though any arbitrary input is acceptable at the minibuffer prompt.

When the timer is set, a message is sent to the echo area recording the
current time and the point in the future when the timer elapses.  Echo
area messages can be reviewed with the =view-echo-area-messages= which is
bound to =C-h e= by default.

Once the timer runs its course, it produces a desktop notification and
plays an alarm sound.  The notification's message is practically the
same as that which is sent to the echo area.  The sound file for the
alarm is defined in =tmr-sound-file=, while the urgency of the
notification can be set through the =tmr-notification-urgency= option.

The =tmr-cancel= command cancels the last =tmr=.  Note that for the time
being it has no notion of multiple timers---just the last one.

#+begin_src emacs-lisp
;;; TMR Must Recur (just my generic timer)
(prot-emacs-builtin-package 'tmr
  (setq tmr-sound-file
        "/usr/share/sounds/freedesktop/stereo/alarm-clock-elapsed.oga")
  (setq tmr-notification-urgency 'normal)
  (setq tmr-descriptions-list (list "Boil water" "Prepare tea" "Bake bread"))
  (let ((map global-map))
    (define-key map (kbd "C-c t t") #'tmr)
    (define-key map (kbd "C-c t c") #'tmr-cancel)))
#+end_src

This is its code (from [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/tmr.el src emacs-lisp :tangle no

** Version control tools
:PROPERTIES:
:CUSTOM_ID: h:0e2fe4c7-9d4b-4570-a293-9a9629021ff7
:END:

*** Diff-mode (and prot-diff.el extensions)
:PROPERTIES:
:CUSTOM_ID: h:2ff46d23-09d5-4d92-b0af-2339dc19719f
:END:

This covers the standard =diff-mode.el=, which I use quite often, such as
while interfacing with the built-in Version Control framework (see the
section on [[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][Version control framework (vc.el and prot-vc.el)]]), or while
browsing various code-related mailing lists through notmuch (refer to
the [[#h:5ad80664-3163-4d9d-be65-462637d77903][email settings]]).

Overview of my preferences for how diffs should look:

+ Always start the buffer in a read-only state.  A typo will mess things
  up when trying to apply a patch.
+ After applying a diff hunk (=diff-apply-hunk= with =C-c C-a=) move on to
  the next one.
+ Update hunk headers automatically following an edit to the diff.
+ Do not show word-wise ("refined") changes upon activation.  I prefer
  to do so manually.  All such highlights are removed if you generate
  the buffer again (with =g= as expected) and the default is to not show
  word-wise changes.
+ Do not prettify headers.  I like the standard "patch" looks.  It also
  makes it easier to copy the diff elsewhere.

Now some notes on my =prot-diff.el= extensions, combined with a
description of the basics of =diff-mode= (as always you can get
documentation about the current buffer's major mode with =C-h m=---read
[[#h:83730fe8-d917-4d94-96f4-bbc5c900fe38][How do you learn Emacs?]] in the FAQ section appended to this document):

+ =prot-diff-buffer-dwim= will produce a diff that compares the current
  buffer to the last saved state of the underlying file.  If the buffer
  has no unsaved edits, the command will produce a diff that compares
  the file to its last registered version-controlled state.  Calling the
  command with an optional prefix argument (=C-u=) will enable word-wise
  highlighting across the diff.

+ =prot-diff-refine-cycle= is how I manually control word-wise diff
  highlights.  This command has a buffer-local cyclic behaviour.  The
  first time it is called, it acts on the diff hunk at point.  Upon
  second invocation, it operates on the entire buffer.  And on third
  call it removes the word-wise diffs altogether.

+ =prot-diff-narrow-dwim= narrows to the diff hunk at point.  If narrowing
  is already present, it widens the buffer.  When invoked with an
  optional prefix argument, it narrows to the current file.

+ =C-c C-c= or =M-o= takes you to the point of the changes in the source
  file.  If you run this of the diff hunk's heading, you go to the
  beginning of the context.  But if you place the point somewhere inside
  of the diff's added changes or context, you will visit that exact
  position in the original file (does not work for removed text because
  technically it does not exist).

+ When working with patches to source code, which are distributed
  e.g. through email, you can apply the current hunk with =C-c C-a= or
  test for compatibility with =C-c C-t=.  This is a nice way to easily
  merge contributions from others, without having to go through the
  workflow of some proprietary Git/Version-Control forge.

+ With =M-n= and =M-p= you move between hunks.  With =M-}= and =M-{= or =M-N=, =M-P=
  do the same between files.

The =prot-diff-*= commands are part of my =prot-diff.el= library, reproduced
in its entirety after this set of package configurations.

*Pro tip:* enable =outline-minor-mode= to make diff sections foldable.
Check [[#h:a8e737b8-7c90-4c68-8814-acf2f637ffa1][Outline mode, outline minor mode, and extras (prot-outline.el)]].

Also read these sections:

+ [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Projects (project.el and prot-project.el)]].
+ [[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][Version control framework (vc.el and prot-vc.el)]].

Changes to all tracked files are optionally highlighted in the fringe
thanks to the =diff-hl= package by Dmitry Gutov (refer to the section on
[[#h:cb76fcee-e304-4b86-a764-6c3c6775da51][Line numbers and relevant indicators (prot-sideline.el)]]).  Any rules
that control the placement of VC-related (and other) buffers are defined
in the section on [[#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][window rules and basic tweaks]] (specifically, refer to
the variable =display-buffer-alist=).

#+begin_src emacs-lisp
;;; Diff-mode (and prot-diff.el extensions)
(prot-emacs-builtin-package 'diff-mode
  (setq diff-default-read-only t)
  (setq diff-advance-after-apply-hunk t)
  (setq diff-update-on-the-fly t)
  ;; The following are from Emacs 27.1
  (setq diff-refine nil)                ; I do it on demand
  (setq diff-font-lock-prettify nil)    ; better for patches
  ;; The following is further controlled by
  ;; `prot-diff-modus-themes-diffs'
  (setq diff-font-lock-syntax 'hunk-also))

(prot-emacs-builtin-package 'prot-diff
  (prot-diff-modus-themes-diffs)
  (add-hook 'modus-themes-after-load-theme-hook #'prot-diff-modus-themes-diffs)

  (prot-diff-extra-keywords 1)

  ;; `prot-diff-buffer-dwim' replaces the default for `vc-diff' (which I
  ;; bind to another key---see VC section).
  (define-key global-map (kbd "C-x v =") #'prot-diff-buffer-dwim)
  (let ((map diff-mode-map))
    (define-key map (kbd "C-c C-b") #'prot-diff-refine-cycle) ; replace `diff-refine-hunk'
    (define-key map (kbd "C-c C-n") #'prot-diff-narrow-dwim)))
#+end_src

This is =prot-diff.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-diff.el src emacs-lisp :tangle no

*** Version control framework (vc.el and prot-vc.el)
:PROPERTIES:
:CUSTOM_ID: h:31deeff4-dfae-48d9-a906-1f3272f29bc9
:END:

VC consists of set of libraries that provide the means for working with
several version control systems, else "backends".  It is built into
Emacs.  Compared with =magit= (see section on [[#h:76d1b392-e693-40dc-b320-d4c1047115ab][Magit configs]]), =vc= offers a
more abstract, buffer-oriented paradigm that does a fine job at covering
all basic versioning needs.  It however never stands as Magit's peer
when it comes to the sheer coverage of Git features.

To my mind, VC and Magit can be used as part of the same setup.  Employ
the former for common tasks such as viewing diffs and logs, committing
changes in bulk, pushing and pulling from a remote.  And let Magit
handle the more involved and specialised cases of staging a partial
diff, rebasing commits interactively, writing a commit fixup, and so on.

Also refer to the section on [[#h:2ff46d23-09d5-4d92-b0af-2339dc19719f][Diff-mode (and prot-diff.el extensions)]]
which includes various neat extras, such as extra fontification rules
for diff buffers.  And watch my videos on this topic:

1. [[https://protesilaos.com/codelog/2020-03-30-emacs-intro-vc/][Introduction to the Emacs Version Control framework]] (2020-03-30).
2. [[https://protesilaos.com/codelog/2021-01-22-emacs-vc-git-extras/][Extensions for Emacs' vc-git]] (2021-01-22).
3. [[https://protesilaos.com/codelog/2021-02-08-emacs-vc-workflow/][My workflow with VC for Git projects]] (2021-02-08).

Here is an overview of the keys I define, with only a few of them being
left to their default values (note that =prot-diff-buffer-dwim= is part of
the =prot-diff.el= that I linked to above):

| Command                          | C-x v prefix | Mnemonic          |
|----------------------------------+--------------+-------------------|
| vc-update                        | F            | Fetch and Fuse    |
| vc-push                          | P            |                   |
| vc-log-incoming                  | f            | Fetch only        |
| vc-log-outgoing                  | O            |                   |
| vc-create-tag                    | t            |                   |
| vc-retrieve-tag                  | b            | Branch/tag switch |
| vc-diff                          | d            | Diff current file |
| vc-root-diff                     | D            | Diff project      |
| prot-diff-buffer-dwim            | =            | Equality check    |
| prot-vc-project-or-dir           | p            | Project status    |
| prot-vc-custom-log               | SPC          |                   |
| prot-vc-git-patch-apply          | a            | Apply patch       |
| prot-vc-git-patch-create-dwim    | c            | Create patch      |
| prot-vc-git-show                 | s            | Show commit       |
| prot-vc-git-grep                 | g            |                   |
| prot-vc-git-log-grep             | G            |                   |
| prot-vc-git-find-revision        | r            | Revisit version   |
| prot-vc-git-blame-region-or-file | B            | Blame             |
| prot-vc-git-log-insert-commits   | i            | Insert commit log |
| prot-vc-git-reset                | R            | Reset (--soft)    |

My =prot-vc.el= library (reproduced after the package configurations)
defines several commands that extend VC to suit my needs as a Git user.
Check the key maps I assign those commands to, in order to further
appreciate the scope of each action.  In short:

+ =prot-vc-git-grep= is a simple wrapper around =vc-git-grep=.  Instead of
  asking for a directory and a file extension pattern, it just prompts
  for a regexp and performs the search across the entire VC-controlled
  directory tree.  All matches are placed directly in a buffer.

+ =prot-vc-git-log-edit-extract-file-name= is used in log-edit buffers to
  derive the file name of the item being committed.  For example, as I
  am writing this, I may want to compose a summary of my changes like
  "prot-emacs: expand VC section docs".  The "prot-emacs: " part comes
  directly from this command, which reads from the "prot-emacs.org"
  file.  If there are multiple files to be committed, then a minibuffer
  prompt asks to pick one among them.  This helps me write clean and
  meaningful summaries.

+ The commands =prot-vc-git-log-edit-{next,previous,complete}-comment= are
  used to access information about previous commit messages that are
  stored in the dedicated ring.  The next/previous operations will cycle
  through the ring in the given direction.  While the "complete" command
  will use minibuffer completion to insert the select item at point.

+ =prot-vc-git-log-insert-commits= will simply insert at point N number of
  commits starting from the HEAD of the current project.  The number is
  inserted at the minibuffer following a prompt.  This runs the =git log=
  shell command in the background.  If the command is not called from
  inside a version-controlled directory or if it is invoked with a
  prefix argument (=C-u=), it first asks for a project and eventually
  prints a log for it.  Again, this is useful while writing the message
  of a commit, as I occasionally need to reference earlier changes.

+ =prot-vc-git-patch-apply= prompts for a file system path to a patch
  file.  By default, it applies the patch directly to the current git
  repo.  If no such repository is found or if called with an optional
  prefix argument the command prompts for a project to use.  This makes
  it very simple to apply a patch from anywhere, such as while reading
  my email (also refer to [[#h:5ad80664-3163-4d9d-be65-462637d77903][Email settings]]).  Arguments that are passed to
  it are those specified in =prot-vc-git-patch-apply-args=, unless the
  command is called from Lisp, in which case it accepts ARGS as a list
  of strings (read the =git am= man pages if you ever need this).

+ =prot-vc-git-patch-create-dwim= produces a properly formatted patch for
  a given commit.  The outputted file is saved in a directory that is
  selected via a minibuffer completion prompt: default candidates are
  stored in =prot-vc-patch-output-dirs= and are complemented by the root
  of the current project.

  - When browsing a =log-view= buffer, the commit is the one around point.

  - When the region is active in Log View buffers, the command will
    capture the included range of commits, instead of just the one at
    point.

  - With a prefix argument (=C-u=), a minibuffer completion prompt will
    ask for a commit to use as the base in a range against HEAD.  This
    will skip the check for the commit at point, though an active region
    in Log View buffers will still take precedence.

  - Beware of how Git interprets those ranges: the base commit is the
    one before the earliest in the range, so if you need to produce
    patches for the topmost 4 commits, you must include the last 5 in
    the region.

  - That granted, I also use [[#h:81c71e25-d6c4-4ef2-ad21-4fd57b00c301][git-email.el for preparing patches]] that
    must be sent via email outright.

+ =prot-vc-git-checkout-remote= prompts for a remote branch and proceeds
  to checkout a local branch that is set up to track it.  So if you have
  a remote named =origin/dev= it will do =git checkout -b dev origin/dev=.
  I only use this command inside VC-dir buffers.

+ =prot-vc-custom-log= prints a log of commits that matches a custom file
  set.  This is of great value when you need to inspect the history of
  only some files rather than that of the entire repository.  What files
  to choose is determined in two ways: (1) the file-at-point in Dired
  buffers, or all marked files, and (2) files in the current directory
  selected with minibuffer completion.

+ =prot-vc-log-view-toggle-entry-all= will toggle the visibility of all
  commits in a compact log view.  I often employ this in tandem with
  =prot-vc-custom-log=.

+ =prot-vc-git-show= lets you read a given commit that you access with
  completion.  A simple and effective wrapper for =git show=.

+ =prot-vc-git-log-grep= provides a search utility for commit logs.  It
  accepts a regular expression, which may just be a string, and shows
  all commits whose message includes that pattern.  When called with a
  universal prefix argument (=C-u=), the log will also include the
  corresponding diff of each commit.

+ =prot-vc-git-find-revision= allows you to revisit a previous state of the
  current file, by selecting a commit with completion.  Quite powerful
  when you want to search, for example, my dotemacs from when I first
  introduced a certain package, say, =prot-vc.el=.

+ =prot-vc-git-reset= prompts for a commit to reset back to, using
  minibuffer completion.  This is a "soft" undo process in that all
  changes are kept in place while any commits are removed.  Remember to
  only do this for local logs as it is not good practice to reset
  publicly available histories: it will break the local copies of other
  users.

+ =prot-vc-git-log-reset= is like the above command, only that it is meant
  to be called from inside a Log View buffer (e.g.  =vc-print-root-log=
  which is bound to =C-x v L= by default).  The commit to reset back to is
  the one at point.  Calling the command with a prefix argument (=C-u=)
  will change the meaning of the reset operation from a soft to a hard
  one.  The latter deletes all commits up to the selected commit /and
  removes all changes/, so please be careful.

+ =prot-vc-project-or-dir= produces a =vc-dir= buffer for the current
  project (also see [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Projects (project.el and prot-project.el)]]).  With a
  =C-u= prefix argument the command limits the matches to the present
  directory.

+ =prot-vc-log-kill-hash= appends to the kill-ring the hash of the commit
  around point.  It is meant to be used in =log-view= buffers.

+ =prot-vc-git-setup-mode= is a minor mode that refashions the log edit
  buffer while adding a small tweak to the log view buffers.

  - Normally the log edit buffer (what you use to write the commit
    message) will pop up in a window with a smaller window below it
    showing the files to be committed.  The window layout does not
    automatically show the corresponding diff, while there is no readily
    available information as to what branch we are about to commit the
    changes to.  So my minor mode removes the small window with the
    files and in its stead adds a comment block in the main message
    composition buffer (like the standard =git commit=).  It then displays
    the diff window on one side and the edit buffer on the other (yes,
    just like Magit, though the order of the windows is always the
    same).  The prior window configuration and the point are saved
    before entering the log edit session and immediately restored upon
    exit (either by committing the changes or aborting).

  - The behaviour of cycling the ring of prior commits is reworked to
    account for the custom git comment.  In addition to back/forth
    motions through the ring's items (=M-p=, =M-n=), a command for picking a
    commit message with minibuffer completion is also made available in
    the stead of the generic commands for searching through the ring,
    with =M-s= or =M-r= (the defaults lack visual feedback and are, in my
    opinion, not appropriate for the task).

  - The =Amend= pseudo header is displayed by default to make it easier to
    edit the last commit, if necessary, and to raise awareness about
    this possibility.

  - For the log view buffers (commit logs) the minor mode instructs the
    command that expands the message of a commit on the current line to
    include more information from =git log= than what it normally would.
    It shows diff stats and affected file names, while also creating
    some much needed negative space for better usability.  Those file
    names are not purely cosmetic, as they can now serve to power Emacs'
    contextuality and "future history" such as when you put point over
    the name and type =C-x p f= (=project-find-file=): the file at point
    becomes the default choice and the one you will also get with =M-n= in
    the minibuffer (=next-history-element=).

Finally, a few tips for acting in the log-edit buffer (remember to use
=C-h m= (=M-x describe-mode=) in every unfamiliar major mode and read the
manual for more on the matter):

+ Use =C-c C-d= (=log-edit-show-diff=) to produce a diff of the changes
  to-be-committed.  Of course this is of no use if my aforementioned
  minor mode is enabled.  Still, it is good to know (by the way, this
  command also works in Magit's commit composition buffers).

+ With =C-c C-w= (=log-edit-generate-changelog-from-diff=) generate an
  overview of documented changes to the given file set.  While this may
  not be useful for everyday commits, it is mandatory when preparing
  patches for upstream Emacs (and probably other GNU projects).

+ Normally the window layout is set up to include files for the given
  commit, but I disable that via my minor mode.  You can opt to display
  them with =C-c C-f= (=log-edit-show-files=).

+ =C-c C-k= (=log-edit-kill-buffer=) cancels the log editing process.

+ =M-n= (=log-edit-next-comment=) and =M-p= (=log-edit-previous-comment=) let
  you cycle through prior commit messages.

#+begin_src emacs-lisp
;;; Version control framework (vc.el and prot-vc.el)
(prot-emacs-builtin-package 'vc
  ;; Those offer various types of functionality, such as blaming,
  ;; viewing logs, showing a dedicated buffer with changes to affected
  ;; files.
  (require 'vc-annotate)
  (require 'vc-dir)
  (require 'vc-git)
  (require 'add-log)
  (require 'log-view)

  ;; This one is for editing commit messages.
  (require 'log-edit)
  (setq log-edit-confirm 'changed)
  (setq log-edit-keep-buffer nil)
  (setq log-edit-require-final-newline t)
  (setq log-edit-setup-add-author nil)

  ;; Note that `prot-vc-git-setup-mode' will run the following when
  ;; activated:
  ;;
  ;;   (remove-hook 'log-edit-hook #'log-edit-show-files)
  ;;
  ;; If you need the window to pop back up, do it manually with C-c C-f
  ;; which calls `log-edit-show-files'.

  (setq vc-find-revision-no-save t)
  (setq vc-annotate-display-mode 'scale) ; scale to oldest
  ;; I use a different account for git commits
  (setq add-log-mailing-address "info@protesilaos.com")
  (setq add-log-keep-changes-together t)
  (setq vc-git-diff-switches '("--patch-with-stat" "--histogram"))
  (setq vc-git-print-log-follow t)
  (setq vc-git-revision-complete-only-branches nil) ; Emacs 28
  (setq vc-git-root-log-format
        '("%d %h %ad %an: %s"
          ;; The first shy group matches the characters drawn by --graph.
          ;; We use numbered groups because `log-view-message-re' wants the
          ;; revision number to be group 1.
          "^\\(?:[*/\\|]+\\)\\(?:[*/\\| ]+\\)?\
\\(?2: ([^)]+) \\)?\\(?1:[0-9a-z]+\\) \
\\(?4:[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}\\) \
\\(?3:.*?\\):"
          ((1 'log-view-message)
           (2 'change-log-list nil lax)
           (3 'change-log-name)
           (4 'change-log-date))))

  (add-hook 'log-view-mode-hook #'hl-line-mode)

  ;; NOTE: I override lots of the defaults
  (let ((map global-map))
    (define-key map (kbd "C-x v b") #'vc-retrieve-tag)  ; "branch" switch
    (define-key map (kbd "C-x v t") #'vc-create-tag)
    (define-key map (kbd "C-x v f") #'vc-log-incoming)  ; the actual git fetch
    (define-key map (kbd "C-x v o") #'vc-log-outgoing)
    (define-key map (kbd "C-x v F") #'vc-update)        ; "F" because "P" is push
    (define-key map (kbd "C-x v d") #'vc-diff))
  (let ((map vc-dir-mode-map))
    (define-key map (kbd "b") #'vc-retrieve-tag)
    (define-key map (kbd "t") #'vc-create-tag)
    (define-key map (kbd "O") #'vc-log-outgoing)
    (define-key map (kbd "o") #'vc-dir-find-file-other-window)
    (define-key map (kbd "f") #'vc-log-incoming) ; replaces `vc-dir-find-file' (use RET)
    (define-key map (kbd "F") #'vc-update)       ; symmetric with P: `vc-push'
    (define-key map (kbd "d") #'vc-diff)         ; parallel to D: `vc-root-diff'
    (define-key map (kbd "k") #'vc-dir-clean-files)
    (define-key map (kbd "G") #'vc-revert)
    (let ((prot-vc-git-branch-map (make-sparse-keymap)))
      (define-key map "B" prot-vc-git-branch-map)
      (define-key prot-vc-git-branch-map "n" #'vc-create-tag) ; new branch/tag
      (define-key prot-vc-git-branch-map "s" #'vc-retrieve-tag) ; switch branch/tag
      (define-key prot-vc-git-branch-map "c" #'prot-vc-git-checkout-remote) ; "checkout" remote
      (define-key prot-vc-git-branch-map "l" #'vc-print-branch-log))
    (let ((prot-vc-git-stash-map (make-sparse-keymap)))
      (define-key map "S" prot-vc-git-stash-map)
      (define-key prot-vc-git-stash-map "c" 'vc-git-stash) ; "create" named stash
      (define-key prot-vc-git-stash-map "s" 'vc-git-stash-snapshot)))
  (let ((map vc-git-stash-shared-map))
    (define-key map "a" 'vc-git-stash-apply-at-point)
    (define-key map "c" 'vc-git-stash) ; "create" named stash
    (define-key map "D" 'vc-git-stash-delete-at-point)
    (define-key map "p" 'vc-git-stash-pop-at-point)
    (define-key map "s" 'vc-git-stash-snapshot))
  (let ((map vc-annotate-mode-map))
    (define-key map (kbd "M-q") #'vc-annotate-toggle-annotation-visibility)
    (define-key map (kbd "C-c C-c") #'vc-annotate-goto-line)
    (define-key map (kbd "<return>") #'vc-annotate-find-revision-at-line))
  (let ((map log-view-mode-map))
    (define-key map (kbd "<tab>") #'log-view-toggle-entry-display)
    (define-key map (kbd "<return>") #'log-view-find-revision)
    (define-key map (kbd "s") #'vc-log-search)
    (define-key map (kbd "o") #'vc-log-outgoing)
    (define-key map (kbd "f") #'vc-log-incoming)
    (define-key map (kbd "F") #'vc-update)
    (define-key map (kbd "P") #'vc-push)))

(prot-emacs-builtin-package 'prot-vc
  (setq prot-vc-log-limit 100)
  (setq prot-vc-log-bulk-action-limit 50)
  (setq prot-vc-git-log-edit-show-commits t)
  (setq prot-vc-git-log-edit-show-commit-count 10)
  (setq prot-vc-shell-output "*prot-vc-output*")
  (setq prot-vc-patch-output-dirs (list "~/" "~/Desktop/"))
  (add-to-list' log-edit-headers-alist '("Amend"))

  ;; This refashions log view and log edit buffers
  (prot-vc-git-setup-mode 1)

  ;; NOTE: I override lots of the defaults
  (let ((map global-map))
    (define-key map (kbd "C-x v i") #'prot-vc-git-log-insert-commits)
    (define-key map (kbd "C-x v p") #'prot-vc-project-or-dir)
    (define-key map (kbd "C-x v SPC") #'prot-vc-custom-log)
    (define-key map (kbd "C-x v g") #'prot-vc-git-grep)
    (define-key map (kbd "C-x v G") #'prot-vc-git-log-grep)
    (define-key map (kbd "C-x v a") #'prot-vc-git-patch-apply)
    (define-key map (kbd "C-x v c") #'prot-vc-git-patch-create-dwim)
    (define-key map (kbd "C-x v s") #'prot-vc-git-show)
    (define-key map (kbd "C-x v r") #'prot-vc-git-find-revision)
    (define-key map (kbd "C-x v B") #'prot-vc-git-blame-region-or-file)
    (define-key map (kbd "C-x v R") #'prot-vc-git-reset))
  (let ((map vc-git-log-edit-mode-map))
    (define-key map (kbd "C-C C-n") #'prot-vc-git-log-edit-extract-file-name)
    (define-key map (kbd "C-C C-i") #'prot-vc-git-log-insert-commits)
    ;; Also done by `prot-vc-git-setup-mode', but I am putting it here
    ;; as well for visibility.
    (define-key map (kbd "C-c C-c") #'prot-vc-git-log-edit-done)
    (define-key map (kbd "C-c C-a") #'prot-vc-git-log-edit-toggle-amend)
    (define-key map (kbd "M-p") #'prot-vc-git-log-edit-previous-comment)
    (define-key map (kbd "M-n") #'prot-vc-git-log-edit-next-comment)
    (define-key map (kbd "M-s") #'prot-vc-git-log-edit-complete-comment)
    (define-key map (kbd "M-r") #'prot-vc-git-log-edit-complete-comment))
  (let ((map log-view-mode-map))
    (define-key map (kbd "<C-tab>") #'prot-vc-log-view-toggle-entry-all)
    (define-key map (kbd "a") #'prot-vc-git-patch-apply)
    (define-key map (kbd "c") #'prot-vc-git-patch-create-dwim)
    (define-key map (kbd "R") #'prot-vc-git-log-reset)
    (define-key map (kbd "w") #'prot-vc-log-kill-hash)))
#+end_src

And here is =prot-vc.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-vc.el src emacs-lisp :tangle no

**** git-email.el for preparing patches
:PROPERTIES:
:CUSTOM_ID: h:81c71e25-d6c4-4ef2-ad21-4fd57b00c301
:END:

This neat library by Xinglu Chen streamlines the process of formatting
and sending Git patches via email, all from the comfort of Emacs.  Its
main point of entry is the command =git-email-format-patch=, which prompts
you for a commit that is read as the range between the current HEAD and
the one you specify.  In doing so, it allows you to prepare a series of
patches, using the correct message headers.

=git-email.el= is meant to work with the standard message composition
buffer, such as the one you get when you call =M-x compose-email= (by
default that command is bound to =C-x m= and I keep it that way).  Email
clients like Gnus and Notmuch are also supported.  For my case as a user
of the latter, I just activate =git-email-notmuch-mode= in order to add
the relevant settings to the message composition buffers.  For more on
Notmuch and all related configurations, refer to the mega-section on
[[#h:5ad80664-3163-4d9d-be65-462637d77903][Email settings]].

So here is the typical workflow with this package:

+ Visit a file and make some changes.
+ Commit those changes.
+ Invoke =git-email-format-patch= and select the base commit against which
  your commits are to be read.  So if your commit is the current HEAD,
  then just pick the one right before.
+ Pass any optional flags.  Multiple flags can be completed against
  using a comma as a separator (or whatever your =crm-separator= is).
+ Fill in the email details, which probably is just an email address
  (and a cover letter, if you use that option).
+ Send.  Done!

The maintainer of the project will then be able to apply your patch,
using standard git commands (read the manpages of =git-apply= for
attachments and =git-am= for mailbox-type patches).

Alternatively, you may already have a patch available and wish to email
it directly.  Visit its directory and with the point over it call the
command =git-email-send-email=.  This also works for the marked items of
the Dired buffer ([[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][Dired (directory editor, file manager)]]).

Overall, =git-email.el= is a welcome addition to the ecosystem.  Apart
from also working with the built-in Version Control framework of Emacs
(consult [[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][Version control framework (vc.el and prot-vc.el)]]), it offers us
the means to conveniently implement a truly decentralised workflow for
collaboration: git and email empower you to utilise the tools you want,
instead of forcing you through some unwieldy pull/merge request process
that certain git forges encourage.  I prefer this approach and am eager
to see it getting more widespread adoption.

#+begin_src emacs-lisp
;;; git-email.el for preparing patches
;; Project repo: <https://git.sr.ht/~yoctocell/git-email>.  This is one
;; of the packages I handle manually via git, at least until it becomes
;; available through an ELPA.
;;
;; `prot-emacs-manual-package' is defined in my init.el
(prot-emacs-manual-package 'git-email
  (with-eval-after-load 'notmuch
    (require 'git-email-notmuch)
    (git-email-notmuch-mode 1))
  (define-key global-map (kbd "C-x v RET") #'git-email-format-patch) ; VC prefix and C-m
  (define-key dired-mode-map (kbd "C-x v RET") #'git-email-send-email))
#+end_src

*** Interactive and powerful git front-end (Magit)
:PROPERTIES:
:CUSTOM_ID: h:76d1b392-e693-40dc-b320-d4c1047115ab
:END:

As noted in the [[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][section on the built-in Version Control framework]] I use
Magit for easy access to the /advanced features of Git/.  While I rely on
the built-in tools for all day-to-day operations.

Magit offers a modal interface where the full power of =git= is neatly
organised in sets of keys that are directly accessible without holding
down any modifiers.

While inside the =magit-status= buffer, hit =?= to produce a transient menu
with the possible vectors to action.  Do it again inside each of the
Magit buffers to view the keys that work for their context.

Consider viewing my [[https://protesilaos.com/codelog/2020-04-04-emacs-intro-magit/][Introduction to Magit]] (2020-04-04) for how to stage
diffs, commit changes, view logs, create branches, and so on.

Magit has great defaults and it should work admirably without any
further tweaks or extra setup.  That granted, the =git-commit= package
(part of Magit) is configured in accordance with the guidelines provided
by this article on [[https://chris.beams.io/posts/git-commit/][writing a Git commit message]].  The gist is to compose
commits that are clean and easy to read.  The =fill-column= is set
elsewhere in this document to 72 characters long.

#+begin_src emacs-lisp
;;; Interactive and powerful git front-end (Magit)
(prot-emacs-elpa-package 'magit
  (setq magit-define-global-key-bindings nil)
  (define-key global-map (kbd "C-c g") #'magit-status)

  (require 'git-commit)
  (setq git-commit-summary-max-length 50)
  (setq git-commit-known-pseudo-headers
        '("Signed-off-by"
          "Acked-by"
          "Modified-by"
          "Cc"
          "Suggested-by"
          "Reported-by"
          "Tested-by"
          "Reviewed-by"))
  (setq git-commit-style-convention-checks
        '(non-empty-second-line
          overlong-summary-line))

  (require 'magit-diff)
  (setq magit-diff-refine-hunk t)

  (require 'magit-repos)
  (setq magit-repository-directories
        '(("~/Git/Projects" . 1))))
#+end_src

*** Smerge and Ediff
:PROPERTIES:
:CUSTOM_ID: h:fb9e0507-5ab1-4ebd-8870-8c32cfe742c1
:END:

*Read this section, because it matters more than the code below it.*

Sometimes we face a situation where we have conflicting versions of a
file and the version control backend cannot solve them on its own.  This
can happen fairly often when collaborating with other people or, more
generally, when we keep our work spread across multiple feature branches
with diverging histories.  Whenever such conflicts arise, Emacs will
automatically annotate the offending files with special markers that
show the conflicting differences.  Visiting those files will then
activate =smerge-mode=.  At which point we are in control.

Smerge revolves around the concept of dividing the conflicting part into
an "upper" (red) and a "lower" section (green), possibly with their
common ancestor or last point of convergence in the middle (yellow).

With this in mind we can operate on the marked differences by relying on
the functions that Smerge provides, all of which are accessed by default
through the common prefix of =C-c ^=.  Start by typing the prefix followed
by =C-h= to see all possible key chords.  These are the commands I have
used the most:

+ =C-c ^ u= (=smerge-keep-upper=)
+ =C-c ^ l= (=smerge-keep-lower=)
+ =C-c ^ b= (=smerge-keep-base=)
+ =C-c ^ a= (=smerge-keep-all=)
+ =C-c ^ n= (=smerge-next=)
+ =C-c ^ p= (=smerge-prev=)

Proceed to edit the file the way you want until no more conflicts exist.
You can also do things through manual editing, with standard commands
and motions, but that can be prone to errors (which lead to more
conflicts).  At any moment in this process, you can switch to =ediff=,
which offers a more powerful way of working with differences.  Type the
key chord =C-c ^ E= (=smerge-ediff=).

Ediff is a powerhouse that is likely to cover all your needs in this
area (including those you are not aware of).  For our purposes, what
matters is to understand the basic concepts.

The way this tool works is that it starts by producing a layout of the
two conflicting versions with access to a "control panel" for operating
on them.  By default, the panel is positioned on a new frame, but I find
that rather awkward---my config puts it inside an Emacs window instead.
While focusing the control panel, you can move between each diff range
with =n= and =p=.  The focused section will be coloured using red, green,
and yellow, while all other diffs will be presented in gray.

On each diff, you have three options: to use the version of buffer A
(red), of buffer B (green), or a combination of the two.  The keys for
each of those are =a=, =b=, and =+= respectively.  Your choice will be
reflected in buffer C (the yellow one).  Use these to resolve all
conflicts and then quit the session with =q=.

Concerning the combination of versions between A and B, Ediff has the
behaviour of also inserting as plain text the annotation markers that
Smerge relied on.  As of this writing (2020-04-10), I am not aware of an
automatic or convenient way to omit those prior to confirming our edits.
To that end, I tweak the wording of the markers to some unique string
(see package below) and then run =flush-lines= to remove them before
saving the resulting buffer (so right after the =q=).  For more on this,
check =prot/ediff-flush-combination-pattern=.

For =git= users, to actually /reference the common ancestor/ (the point
before the branching paths started) we must run this command once in our
command-line prompt (writes to your global =.gitconfig= file):

#+begin_src
git config --global merge.conflictStyle diff3
#+end_src

This is optional, but I find that I like it.  At any rate, the
configurations I have below are straightforward (learn more about this
powerful tool by hitting =?= inside of its control panel and by consulting
its comprehensive manual):

+ Do not keep all the buffers after exiting the Ediff session.
+ Keep buffers in an editable state.  Otherwise it is impossible to
  perform the changes we are interested in.
+ Show the common ancestor in another buffer.  This helps provide
  further context of how things took their form.
+ Show only the conflicting parts.  This is not a review of all diffs.
+ Prefer putting windows side-by-side, rather than one below the other.
+ Do not enter the ediff session in a new frame.  This also means that
  the control panel will be inside an Emacs window (at the bottom part)
  rather than in a tiny frame of its own.

There actually is nothing in terms of Smerge-related configurations.
The package is small and does one thing well.

Also watch my video of [[https://protesilaos.com/codelog/2020-04-10-emacs-smerge-ediff/][Smerge and Ediff for git conflict resolution]]
(2020-04-10).

#+begin_src emacs-lisp
;;; Smerge and Ediff
(prot-emacs-builtin-package 'smerge-mode)

(prot-emacs-builtin-package 'ediff
  (setq ediff-keep-variants nil)
  (setq ediff-make-buffers-readonly-at-startup nil)
  (setq ediff-merge-revisions-with-ancestor t)
  (setq ediff-show-clashes-only t)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)

  ;; Tweak those for safer identification and removal
  (setq ediff-combination-pattern
        '("<<<<<<< prot-ediff-combine Variant A" A
          ">>>>>>> prot-ediff-combine Variant B" B
          "####### prot-ediff-combine Ancestor" Ancestor
          "======= prot-ediff-combine End"))

  ;; TODO automate process in a robust way, or at least offer a good key
  ;; binding.
  (defun prot/ediff-flush-combination-pattern ()
    "Remove my custom `ediff-combination-pattern' markers.

This is a quick-and-dirty way to get rid of the markers that are
left behind by `smerge-ediff' when combining the output of two
diffs.  While this could be automated via a hook, I am not yet
sure this is a good approach."
    (interactive)
    (flush-lines ".*prot-ediff.*" (point-min) (point-max) nil)))
#+end_src

** Command-line shells
:PROPERTIES:
:CUSTOM_ID: h:2c1966a1-bf33-4fe3-ac45-9f31158efd9b
:END:

It should come to no surprise that Emacs can operate as both a /terminal
emulator for command line shells/ and /toolkit for terminal emulators/.
The present section covers only the former category as I never use the
likes of =ansi-term= or =vterm=.

*** Eshell and prot-eshell.el
:PROPERTIES:
:CUSTOM_ID: h:103a8795-c29c-474f-9ddf-ecafaa2f6775
:END:

Eshell is a strictly line-oriented command prompt written in Emacs Lisp.
This comes with its pros and cons: it can understand Elisp but does not
behave exactly like Unix shells, say, Bash.  Eshell cannot display the
kind of pseudo graphics a terminal emulator can, such as those you find
in =mutt=, =htop=, =ncmpcpp=, =newsboat= and so on.  As each user's needs are
different, you will have to determine whether Eshell can fit into your
workflow.  Start by reading its fairly short, yet insightful, manual.

For me this tool is one of the most promising in the Emacs milieu
because while it is a competent shell it can seamlessly integrate with
the rest of Emacs' capabilities.  This is best exemplified by its
extensibility, such as what I am doing with =prot-eshell.el=.  More on
that below.

The fact that Eshell cannot reproduce the artefacts of the ncurses
library does not pose a hindrance to my workflow, as I have replacements
for all such "graphical" programs within Emacs.  Notmuch has an Emacs
client which handles my email (yes, the CLI works as well), =M-x proced=
lets me interact with system processes, Bongo deals with media playback,
while Elfeed fills the niche of following RSS/Atom feed.

Read relevant sections:

+ [[#h:a196812e-1644-4536-84ba-687366867def][Notmuch (mail indexer and mail user agent (MUA))]].
+ [[#h:6b56ce11-c84c-4b6d-98c7-bc3eefbe9325][Proced (process monitor, similar to `top')]].
+ [[#h:758afe0d-bc7c-4afc-9c6b-b5e569901591][Bongo (music or media manager)]].
+ [[#h:0cd8ddab-55d1-40df-b3db-1234850792ba][Elfeed (RSS/Atom feed reader)]].

Now an overview of =prot-eshell.el=, with the full code reproduced right
after the package configurations:

+ There are several =prot-eshell-ffap-*= commands that operate on the file
  at point.  Say you have called =ls= and wish to expand the contents of a
  file at the command prompt.  With point over the file name of
  interest, use =prot-eshell-ffap-insert=.  Wish to visit the file
  instead, so that you may edit it?  Try =prot-eshell-ffap-find-file=.
  The command =prot-eshell-ffap-kill-save= copies the file's full file
  system path, while =prot-eshell-ffap-dired-jump= opens a Dired buffer in
  that file's directory (see [[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][Dired (directory editor, file manager)]]).

+ =prot-eshell-export= takes the prompt and output of the last command and
  places it in a bespoke buffer.  The name of the buffer is controlled
  by the variable =prot-eshell-output-buffer=.  If that buffer does not
  exist, it is created.  Otherwise subsequent invocations of this
  "export" command will append their contents to the existing ones.
  This is good for keeping a record of something you are working on.
  And because this is a standard buffer, you can edit it at will as well
  as call =write-file= (=C-x C-w=) to save it permanently to a file.

+ =prot-eshell-redirect-to-buffer= provides a completion prompt to help
  you redirect the output of a command to a given buffer.  Simple and
  effective.

+ =prot-eshell-narrow-output-highlight-regexp= prompts for a regexp to
  highlight in the output of the last command.  It then narrows the
  Eshell buffer to the contents of that output and emphasises the
  matches of the regexp.  Very useful when you need to inspect some logs
  or other terse output.  Remember that to widen the view you use the
  standard =widen= command, bound to =C-x n w= by default.

+ =prot-eshell-complete-history= lets you pick a command from your history
  using minibuffer completion.  Forget about a non-interactive regexp
  search or, worse, consecutive calls to =M-p= and =M-n= to cycle through
  your recent inputs one at a time.

+ =prot-eshell-complete-recent-dir= provides a minibuffer prompt with
  completion that queries through all paths in your =cd= input history.
  This is much more convenient that standard actions like =cd -= or =cd -N=
  where =N= is the position of the item in the history of entries
  (retrieved with =cd ==).

+ =prot-eshell-find-subdirectory-recursive= uses completion to help you
  pick a subdirectory that extends the present working directory.  It
  does so recursively, which makes it powerful, but can cause problems
  when called from the root of some massive directory tree.  Exercise
  restraint.

+ =prot-eshell-root-dir= switches the present working directory to that of
  the current project's root directory, if one is found.

Here is a [[https://protesilaos.com/codelog/2020-05-08-emacs-eshell-demo/][video on Eshell and my extras]] (2020-05-08) which, however,
showcases older code than what I have here.

For further inspiration, check these valuable resources (in no
particular order):

+ [[https://cestlaz.github.io/post/using-emacs-66-eshell-elisp][Mike Zamansky's video demo]] that also shows how to program an Eshell
  switcher.
+ [[https://www.youtube.com/watch?v=RhYNu6i_uY4][Howard Abrahams' video]] that covers the features of Eshell.
+ [[https://ambrevar.xyz/emacs-eshell/][Pierre Neidhardt's detailed blog post]] on the pros and cons of Eshell.
+ [[https://git.spwhitton.name/dotfiles][Sean Whitton's comprehensive dotfiles repository]] which includes lots
  of useful snippets, including for Eshell.  Some commands/functions of
  mine are either copied or adapted from Sean's implementation,
  following the review that was done on 2022-01-04.

#+begin_src emacs-lisp
;;; Eshell and prot-eshell.el
(prot-emacs-builtin-package 'eshell
  (require 'esh-mode)
  (require 'esh-module)
  (setq eshell-modules-list             ; It works but may need review
        '(eshell-alias
          eshell-basic
          eshell-cmpl
          eshell-dirs
          eshell-glob
          eshell-hist
          eshell-ls
          eshell-pred
          eshell-prompt
          eshell-script
          eshell-term
          eshell-tramp
          eshell-unix))
  (setenv "PAGER" "cat") ; solves issues, such as with 'git log' and the default 'less'
  (require 'em-cmpl)
  (require 'em-dirs)
  (setq eshell-cd-on-directory t)

  (require 'em-tramp)
  (setq password-cache t)
  (setq password-cache-expiry 600)

  (require 'em-hist)
  (setq eshell-hist-ignoredups t)
  (setq eshell-save-history-on-exit t))

(prot-emacs-builtin-package 'prot-eshell
  (setq prot-eshell-output-buffer "*Exported Eshell output*")
  (setq prot-eshell-output-delimiter "* * *")
  (let ((map eshell-mode-map))
    (define-key map (kbd "M-k") #'eshell-kill-input)
    (define-key map (kbd "C-c C-f") #'prot-eshell-ffap-find-file)
    (define-key map (kbd "C-c C-j") #'prot-eshell-ffap-dired-jump)
    (define-key map (kbd "C-c C-w") #'prot-eshell-ffap-kill-save)
    (define-key map (kbd "C-c C->") #'prot-eshell-redirect-to-buffer)
    (define-key map (kbd "C-c C-e") #'prot-eshell-export)
    (define-key map (kbd "C-c C-r") #'prot-eshell-root-dir))
  (let ((map eshell-cmpl-mode-map))
    (define-key map (kbd "C-c TAB") #'prot-eshell-ffap-insert) ; C-c C-i
    (define-key map (kbd "C-c C-h") #'prot-eshell-narrow-output-highlight-regexp))
  (let ((map eshell-hist-mode-map))
    (define-key map (kbd "M-s") #'nil) ; I use this prefix for lots of more useful commands
    (define-key map (kbd "M-r") #'prot-eshell-complete-history)
    (define-key map (kbd "C-c C-d") #'prot-eshell-complete-recent-dir)
    (define-key map (kbd "C-c C-s") #'prot-eshell-find-subdirectory-recursive)))
#+end_src

This is =prot-eshell.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-eshell.el src emacs-lisp :tangle no

*** Shell (M-x shell)
:PROPERTIES:
:CUSTOM_ID: h:98804f0d-f2dd-41a4-b8df-c1bd04ef7f7a
:END:

NOTE: I normally use Eshell.  Refer to the [[#h:103a8795-c29c-474f-9ddf-ecafaa2f6775][Eshell and prot-eshell.el]]
section.

This is a shell (Bash, in my case) that runs inside of Emacs.  Unlike
terminal emulators, this one can use standard Emacs keys and behaves
much like an ordinary buffer.  It also integrates nicely with the
built-in completion tools, which makes it particularly nice to work
with.

The one area where this Shell differs substantially from ordinary
buffers is with regard to the command prompt: you can re-run a command
on the scroll-back buffer by just hitting =RET= while point is on its line
(no need to go back to the end and cycle the command history with =M-p= or
=M-n=).

Another peculiarity relative to the standard commands in the terminal is
to search backward through your history with =M-r= (whereas in a terminal
emulator you use =C-r=).

Run =C-h m= inside of a shell buffer to learn about all the key bindings
and corresponding functions.

#+begin_src emacs-lisp
;;; Shell (M-x shell)
(prot-emacs-builtin-package 'shell
  (setq shell-command-prompt-show-cwd t) ; Emacs 27.1
  (setq ansi-color-for-comint-mode t))
#+end_src

** Org-mode (personal information manager)
:PROPERTIES:
:CUSTOM_ID: h:4e8347de-415e-4804-b383-d61499e05ca1
:END:

Also watch: [[https://protesilaos.com/codelog/2021-08-31-emacs-second-brain-mindfulness/][Emacs as a 'second brain' and mindfulness]] (2021-08-31).

In its purest form, Org is a markup language that is similar to
Markdown: symbols are used to denote the meaning of a construct in its
context, such as what may represent a headline element or a phrase that
calls for emphasis.

What lends Org its super powers though is everything else built around
it: a rich corpus of Elisp functions that automate, link, combine,
enhance, structure, or otherwise enrich the process of using this rather
straightforward system of plain text notation.

Couched in those terms, Org is at once a distribution of well integrated
libraries and a vibrant ecosystem that keeps producing new ideas and
workflows on how to organise one's life with plain text.

The present document is written in =org-mode= while its website version is
outputted by a tool (also part of Org) that exports Org notation to its
HTML equivalent.

Regarding the following code block, I strongly encourage you to make
liberal use of Emacs' documentation facilities to learn more about
functions, variables, symbols provided herein.  And do not forget to
read Org's manual.

What follows in an exposition about each of the subsesctions of this
package configurations:

+ Org links :: The =org-store-link= is one of the commands I use the most,
  as it allows me to, inter alia, connect the various sections of this
  document.  Use it to store a direct link to the heading you are
  currently under.  Or to produce a properly formatted link to supported
  buffers you are visiting (e.g. another file).

  There are several ways to insert such links.  With =C-c C-l= (which
  calls =org-insert-link=) you will be prompted to select a stored link
  from the link.  It will be inserted at point, using the right markup,
  but will first ask you for a description text.  Otherwise you can
  invoke =C-c C-l= with an active region, to create a link to that
  location with the selected text becoming the description.  Else just
  call =org-insert-last-stored-link= to skip the interactive process and
  insert the last link outright.

  In addition to these, =org-insert-link= can be used to create references
  on demand.  Say you have a URL on the kill-ring: =C-c C-l=, then =C-y=
  followed by =RET= to confirm your input.  Complete the process with a
  description and you are good to go.

+ Org capture :: The =org-capture= tool is a powerful way to quickly
  produce some kind of structured information that gets stored in the
  appropriate place.  The type of data and the way to store is
  determined by a system of templates which accepts a series of possible
  specifiers as well as the evaluated part of arbitrary elisp code.

  Each template is accessed via a key.  These are listed in a temporary
  buffer when you call =org-capture=.  Unique keys give direct access to
  their template, whereas templates that share a common initial key will
  produce a second selection list with the remaining options.  In the
  latter case, the initial key entry has no call to an actual function,
  but is just written as a heading.

  The visibility of a template is explicitly controlled by the alist
  =org-capture-templates-contexts=.  This allows us to tell Org the
  context in which we want certain options to appear in.  Otherwise they
  remain concealed from our view.  Equipped with this piece of
  functionality, we can freely write highly specialised templates that
  capture structured text when viewing some particular item, but are not
  needed for more general purposes.  I do this for certain actions that
  only come into effect when reading email inside of the relevant
  buffers (also check my [[#h:5ad80664-3163-4d9d-be65-462637d77903][comprehensive configurations for email]]).

  Speaking of mail, you will notice some specifiers like =:fromname=.  This
  refers to the =From= field in emails and will capture the name part only.
  Other similar keywords are =:from= (name and email), =:fromaddress= (email
  only), =:subject=.

  Specifiers that start with the caret sign (=^=) represent prompts for
  further user input.  The pattern =^{TEXT}= is a prompt whose expression
  is =TEXT=.  To offer possible options, use =^{Initial|ONE|TWO|THREE}=,
  where the first entry is the text of the prompt and all the rest are
  the available choices (depending on your completion framework, you may
  need to add an empty option as well, with =||=, should you ever want to
  insert nothing).  In some templates I use the =^t= specifier, which is a
  built-in method to ask for a specific date.

  The text that goes into a template can be written as part of a string or
  inside a function that is then evaluated.  I generally prefer to use
  simple strings, though I might revise this approach going forward.  To
  insert a new line inside of a string, use =\n=.

  The =%?= specifier determines where the point shall end in once the
  template is parsed.  While =%i= will insert the contents of the active
  region, if any.

  As things currently stand, my capture templates always write to headings
  inside of files.  Note though that there are more possibilities, as
  described in the manual.

  A file can be specified by its absolute path or just a name.  In the
  latter case, its location is understood relative to =org-directory=.
  When using the =file+headline= pattern, non-existent files are created
  automatically once you call the relevant template.  Same for their
  respective headings.

  Finally, the =prot-org--capture-no-delete-windows= from my =prot-org.el=
  (reproduced after the Org configs) addresses a problem I have when
  =org-capture= fails to carry out its operations when it is called from
  inside of a side window (for more on those, refer to the section on
  [[#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][Window rules and basic tweaks]]).  The code is taken directly from this
  [[https://stackoverflow.com/a/54251825][Stack Overflow thread]].

  Consider watching my [[https://protesilaos.com/codelog/2020-02-04-emacs-org-capture-intro/][primer on org-capture]] (2020-02-04) which shows all
  of the above in action.

+ Org agenda :: The =org-agenda= is not just a single interface.  It
  rather is your conduit to a set of utilities for reading timestamped
  tasks.  From there you can keep track of all the relevant entries you
  have inserted in the files declared as part of =org-agenda-files= list.

  Running =org-agenda= will present you with a list of possible options:
  the "dispatcher" as it called.  Here is a primer (there are many more
  functions documented in the manual):

  - From the dispatcher, the =a= is where you keep track of all the items
    that have a date assigned to them, be it =SCHEDULED= or =DEADLINE=.  To
    assign such a value to a heading use =C-c C-s= or =C-c C-d= respectively.
    Run those commands with a universal prefix (=C-u=) to remove the
    timestamp.  Hit =/= to filter this view to match particular tags.

  - In the dispatcher's menu, the =t= will list all your tasks, regardless
    of whether they have a date assigned to them.  You can then filter by
    keyword, regular expression, etc.  Check the top of the buffer for
    information on how to do that.

  - And the =n= in the dispatcher will offer you a combined view of the
    above.

  - Those granted, I prefer to just use the Diary and Calendar for my
    simple needs: [[#h:b4040bc0-7a2a-4f17-824d-42de621bd1b9][Calendar and Diary (and prot-diary.el)]].  Though this
    may change going forward, as I am starting to experiment with more
    advanced workflows, including the creation of bespoke "block agenda"
    views (watch my [[https://protesilaos.com/codelog/2021-12-09-emacs-org-block-agenda/][Demo of my custom Org block agenda]] (2021-12-09)).

+ Org export :: I do not have much to offer here, apart from the setup
  that handles consistent heading IDs and anchor tags (the latter
  concerns the HTML output).  Everything in that segment, minus some
  minor tweaks from my part, is copied from this detailed tutorial on
  [[https://writequit.org/articles/emacs-org-mode-generate-ids.html][Org header IDs]].  Basically, the problem is that exported HTML does not
  have reliable anchor tags for the various sections of the document.
  This fixes the issue (read the article for more).

Finally, note that I sometimes deliver simple presentations using Org.
Refer to [[#h:77d14350-978d-4820-ab7f-4641706c445a][Custom extensions for "focus mode" (prot-logos.el)]].

#+begin_src emacs-lisp
;;; Org-mode (personal information manager)
;; Pro tip: If you are reading the source code, use C-c '
;; (`org-edit-special') to put the code block in a dedicated buffer and
;; then activate `prot-outline-minor-mode-safe' to conveniently browse
;; this massive code block.
(prot-emacs-builtin-package 'org
  (setq org-directory (convert-standard-filename "~/Documents/org"))
  (setq org-imenu-depth 7)
;;;; general settings
  (setq org-adapt-indentation nil)      ; No, non, nein, όχι!
  (setq org-special-ctrl-a/e nil)
  (setq org-special-ctrl-k nil)
  (setq org-M-RET-may-split-line '((default . nil)))
  (setq org-hide-emphasis-markers t)
  (setq org-hide-macro-markers t)
  (setq org-hide-leading-stars nil)
  (setq org-cycle-separator-lines 0)
  (setq org-structure-template-alist    ; CHANGED in Org 9.3, Emacs 27.1
        '(("s" . "src")
          ("E" . "src emacs-lisp")
          ("e" . "example")
          ("q" . "quote")
          ("v" . "verse")
          ("V" . "verbatim")
          ("c" . "center")
          ("C" . "comment")))
  (setq org-catch-invisible-edits 'show)
  (setq org-return-follows-link nil)
  (setq org-loop-over-headlines-in-active-region 'start-level)
  (setq org-modules '(ol-info ol-eww))
  (setq org-use-sub-superscripts '{})
  (setq org-insert-heading-respect-content t)

;;;; refile, todo
  (setq org-refile-targets
        '((org-agenda-files . (:maxlevel . 2))
          (nil . (:maxlevel . 2))))
  (setq org-refile-use-outline-path t)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-use-cache t)
  (setq org-reverse-note-order nil)
  (setq org-todo-keywords
        '((sequence "TODO(t)" "MAYBE(m)" "WAIT(w@/!)" "|" "CANCEL(c@)" "DONE(d!)")))
  (setq org-todo-keyword-faces
        '(("WAIT" . '(bold org-todo))
          ("MAYBE" . '(bold shadow))
          ("CANCEL" . '(bold org-done))))
  (setq org-use-fast-todo-selection 'expert)
  (setq org-priority-faces
        '((?A . '(bold org-priority))
          (?B . org-priority)
          (?C . '(shadow org-priority))))
  (setq org-fontify-done-headline nil)
  (setq org-fontify-quote-and-verse-blocks t)
  (setq org-fontify-whole-heading-line nil)
  (setq org-fontify-whole-block-delimiter-line nil)
  (setq org-highlight-latex-and-related nil) ; other options affect elisp regexp in src blocks
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t)
  (setq org-track-ordered-property-with-tag t)
  (setq org-highest-priority ?A)
  (setq org-lowest-priority ?C)
  (setq org-default-priority ?A)

;;;; tags
  (setq org-tag-alist ; I don't really use those, but whatever
        '(("meeting")
          ("admin")
          ("emacs")
          ("modus")
          ("politics")
          ("economics")
          ("philosophy")
          ("book")
          ("essay")
          ("mail")
          ("purchase")
          ("hardware")
          ("software")
          ("website")))

;;;; log
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)
  (setq org-log-note-clock-out nil)
  (setq org-log-redeadline 'time)
  (setq org-log-reschedule 'time)
  (setq org-read-date-prefer-future 'time)

;;;; links
  (setq org-link-keep-stored-after-insertion nil)
  ;; TODO 2021-10-15 org-link-make-description-function

  ;; See my prot-pulse.el for what this does.  Basically it recentres
  ;; the window the way I like and pulse the line at point to make it
  ;; easier to make sense of the context.
  (add-hook 'org-follow-link-hook #'prot-pulse-recentre-top)

;;;; capture
  (setq org-capture-templates
        `(("b" "Basic task for future review" entry
           (file+headline "tasks.org" "Tasks to be reviewed")
           ,(concat "* %^{Title}\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":END:\n\n"
                    "%i%l")
           :empty-lines-after 1)
          ("c" "Clock in to a task" entry
           (file+headline "tasks.org" "Clocked tasks")
           ,(concat "* TODO %^{Title}\n"
                    "SCHEDULED: %T\n"
                    ":PROPERTIES:\n"
                    ":EFFORT: %^{Effort estimate in minutes|5|10|15|30|45|60|90|120}\n"
                    ":END:\n\n"
                    "%a\n")
           :prepend t
           :clock-in t
           :clock-keep t
           :immediate-finish t
           :empty-lines-after 1)
          ("m" "Memorandum of conversation" entry
           (file+headline "tasks.org" "Tasks to be reviewed")
           ,(concat "* Memorandum of conversation with %^{Person}\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":END:\n\n"
                    "%i%?")
           :empty-lines-after 1)
          ("t" "Task with a due date" entry
           (file+headline "tasks.org" "Tasks with a date")
           ,(concat "* TODO %^{Title} %^g\n"
                    "SCHEDULED: %^t\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":END:\n\n"
                    "%a\n%i%?")
           :empty-lines-after 1)
          ("e" "Email note" entry
           (file+headline "tasks.org" "Tasks to be reviewed")
           ,(concat "* MAYBE %:subject :mail:\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":END:\n\n"
                    "%a\n%i%?")
           :empty-lines-after 1)))

  (setq org-capture-templates-contexts
        '(("e" ((in-mode . "notmuch-search-mode")
                (in-mode . "notmuch-show-mode")
                (in-mode . "notmuch-tree-mode")))))

;;;; agenda
;;;;; Basic agenda setup
  (setq org-default-notes-file (thread-last org-directory (expand-file-name "notes.org")))
  (setq org-agenda-files `(,org-directory "~/Documents"))
  (setq org-agenda-span 'week)
  (setq org-agenda-start-on-weekday 1)  ; Monday
  (setq org-agenda-confirm-kill t)
  (setq org-agenda-show-all-dates t)
  (setq org-agenda-show-outline-path nil)
  (setq org-agenda-window-setup 'current-window)
  (setq org-agenda-skip-comment-trees t)
  (setq org-agenda-menu-show-matcher t)
  (setq org-agenda-menu-two-columns nil)
  (setq org-agenda-sticky nil)
  (setq org-agenda-custom-commands-contexts nil)
  (setq org-agenda-max-entries nil)
  (setq org-agenda-max-todos nil)
  (setq org-agenda-max-tags nil)
  (setq org-agenda-max-effort nil)

  ;; NOTE 2021-12-07: In my `prot-org.el' (see further below), I add
  ;; `org-agenda-to-appt' to various relevant hooks.
  ;;
  ;; Create reminders for tasks with a due date when this file is read.
  (run-at-time (* 60 5) nil #'org-agenda-to-appt)

;;;;; General agenda view options
  ;; NOTE 2021-12-07: Check further below my `org-agenda-custom-commands'
  (setq org-agenda-prefix-format
        '((agenda . " %i %-12:c%?-12t% s")
          (todo . " %i %-12:c")
          (tags . " %i %-12:c")
          (search . " %i %-12:c")))
  (setq org-agenda-sorting-strategy
        '(((agenda habit-down time-up priority-down category-keep)
           (todo priority-down category-keep)
           (tags priority-down category-keep)
           (search category-keep))))
  (setq org-agenda-breadcrumbs-separator "->")
  (setq org-agenda-todo-keyword-format "%-1s")
  (setq org-agenda-fontify-priorities 'cookies)
  (setq org-agenda-category-icon-alist nil)
  (setq org-agenda-remove-times-when-in-prefix nil)
  (setq org-agenda-remove-timeranges-from-blocks nil)
  (setq org-agenda-compact-blocks nil)
  (setq org-agenda-block-separator ?—)

;;;;; Agenda marks
  (setq org-agenda-bulk-mark-char "#")
  (setq org-agenda-persistent-marks nil)

;;;;; Agenda diary entries
  (setq org-agenda-insert-diary-strategy 'date-tree)
  (setq org-agenda-insert-diary-extract-time nil)
  (setq org-agenda-include-diary nil)

;;;;; Agenda follow mode
  (setq org-agenda-start-with-follow-mode nil)
  (setq org-agenda-follow-indirect t)

;;;;; Agenda multi-item tasks
  (setq org-agenda-dim-blocked-tasks t)
  (setq org-agenda-todo-list-sublevels t)

;;;;; Agenda filters and restricted views
  (setq org-agenda-persistent-filter nil)
  (setq org-agenda-restriction-lock-highlight-subtree t)

;;;;; Agenda items with deadline and scheduled timestamps
  (setq org-agenda-include-deadlines t)
  (setq org-deadline-warning-days 5)
  (setq org-agenda-skip-scheduled-if-done nil)
  (setq org-agenda-skip-scheduled-if-deadline-is-shown t)
  (setq org-agenda-skip-timestamp-if-deadline-is-shown t)
  (setq org-agenda-skip-deadline-if-done nil)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled 1)
  (setq org-agenda-skip-scheduled-delay-if-deadline nil)
  (setq org-agenda-skip-additional-timestamps-same-entry nil)
  (setq org-agenda-skip-timestamp-if-done nil)
  (setq org-agenda-search-headline-for-time nil)
  (setq org-scheduled-past-days 365)
  (setq org-deadline-past-days 365)
  (setq org-agenda-move-date-from-past-immediately-to-today t)
  (setq org-agenda-show-future-repeats t)
  (setq org-agenda-prefer-last-repeat nil)
  (setq org-agenda-timerange-leaders
        '("" "(%d/%d): "))
  (setq org-agenda-scheduled-leaders
        '("Scheduled: " "Sched.%2dx: "))
  (setq org-agenda-inactive-leader "[")
  (setq org-agenda-deadline-leaders
        '("Deadline:  " "In %3d d.: " "%2d d. ago: "))
  ;; Time grid
  (setq org-agenda-time-leading-zero t)
  (setq org-agenda-timegrid-use-ampm nil)
  (setq org-agenda-use-time-grid t)
  (setq org-agenda-show-current-time-in-grid t)
  (setq org-agenda-current-time-string
        (concat "Now " (make-string 70 ?-)))
  (setq org-agenda-time-grid
        '((daily today require-timed)
          (0600 0700 0800 0900 1000 1100
                1200 1300 1400 1500 1600
                1700 1800 1900 2000 2100)
          " ....." "-----------------"))
  (setq org-agenda-default-appointment-duration nil)

;;;;; Agenda global to-do list
  (setq org-agenda-todo-ignore-with-date t)
  (setq org-agenda-todo-ignore-timestamp t)
  (setq org-agenda-todo-ignore-scheduled t)
  (setq org-agenda-todo-ignore-deadlines t)
  (setq org-agenda-todo-ignore-time-comparison-use-seconds t)
  (setq org-agenda-tags-todo-honor-ignore-options nil)

;;;;; Agenda tagged items
  (setq org-agenda-show-inherited-tags t)
  (setq org-agenda-use-tag-inheritance
        '(todo search agenda))
  (setq org-agenda-hide-tags-regexp nil)
  (setq org-agenda-remove-tags nil)
  (setq org-agenda-tags-column -100)

;;;;; Agenda entry
  ;; NOTE: I do not use this right now.  Leaving everything to its
  ;; default value.
  (setq org-agenda-start-with-entry-text-mode nil)
  (setq org-agenda-entry-text-maxlines 5)
  (setq org-agenda-entry-text-exclude-regexps nil)
  (setq org-agenda-entry-text-leaders "    > ")

;;;;; Agenda logging and clocking
  ;; NOTE: I do not use these yet, though I plan to.  Leaving everything
  ;; to its default value for the time being.
  (setq org-agenda-log-mode-items '(closed clock))
  (setq org-agenda-clock-consistency-checks
        '((:max-duration "10:00" :min-duration 0 :max-gap "0:05" :gap-ok-around
                         ("4:00")
                         :default-face ; This should definitely be reviewed
                         ((:background "DarkRed")
                          (:foreground "white"))
                         :overlap-face nil :gap-face nil :no-end-time-face nil
                         :long-face nil :short-face nil)))
  (setq org-agenda-log-mode-add-notes t)
  (setq org-agenda-start-with-log-mode nil)
  (setq org-agenda-start-with-clockreport-mode nil)
  (setq org-agenda-clockreport-parameter-plist '(:link t :maxlevel 2))
  (setq org-agenda-search-view-always-boolean nil)
  (setq org-agenda-search-view-force-full-words nil)
  (setq org-agenda-search-view-max-outline-level 0)
  (setq org-agenda-search-headline-for-time t)
  (setq org-agenda-use-time-grid t)
  (setq org-agenda-cmp-user-defined nil)
  (setq org-agenda-sort-notime-is-late t) ; Org 9.4
  (setq org-agenda-sort-noeffort-is-high t) ; Org 9.4

;;;;; Agenda column view
  ;; NOTE I do not use these, but may need them in the future.
  (setq org-agenda-view-columns-initially nil)
  (setq org-agenda-columns-show-summaries t)
  (setq org-agenda-columns-compute-summary-properties t)
  (setq org-agenda-columns-add-appointments-to-effort-sum nil)
  (setq org-agenda-auto-exclude-function nil)
  (setq org-agenda-bulk-custom-functions nil)

;;;;; Agenda habits
  (require 'org-habit)
  (setq org-habit-graph-column 50)
  (setq org-habit-preceding-days 9)

;;;; code blocks
  (setq org-confirm-babel-evaluate nil)
  (setq org-src-window-setup 'current-window)
  (setq org-edit-src-persistent-message nil)
  (setq org-src-fontify-natively t)
  (setq org-src-preserve-indentation t)
  (setq org-src-tab-acts-natively t)
  (setq org-edit-src-content-indentation 0)

;;;; export
  (setq org-export-with-toc t)
  (setq org-export-headline-levels 8)
  (setq org-export-dispatch-use-expert-ui nil)
  (setq org-html-htmlize-output-type nil)
  (setq org-html-head-include-default-style nil)
  (setq org-html-head-include-scripts nil)
  (require 'ox-texinfo)
  (require 'ox-md)
  ;; FIXME: how to remove everything else?
  (setq org-export-backends '(html texinfo md))

;;;; IDs
  (setq org-id-link-to-org-use-id
        'create-if-interactive-and-no-custom-id)

  (let ((map global-map))
    (define-key map (kbd "C-c a") #'org-agenda)
    (define-key map (kbd "C-c c") #'org-capture)
    (define-key map (kbd "C-c l") #'org-store-link))
  (let ((map org-mode-map))
    (define-key map (kbd "C-'") nil)
    (define-key map (kbd "C-,") nil)
    (define-key map (kbd "<C-return>") nil)
    (define-key map (kbd "<C-S-return>") nil)
    (define-key map (kbd "C-M-S-<right>") nil)
    (define-key map (kbd "C-M-S-<left>") nil)
    (define-key map (kbd "C-c S-l") #'org-toggle-link-display)
    (define-key map (kbd "C-c C-S-l") #'org-insert-last-stored-link)))

(prot-emacs-builtin-package 'prot-org
  (setq org-agenda-format-date #'prot-org-agenda-format-date-aligned)

  ;; Check the variable `prot-org-custom-daily-agenda' in prot-org.el
  (setq org-agenda-custom-commands
        `(("A" "Daily agenda and top priority tasks"
           ,prot-org-custom-daily-agenda
           ((org-agenda-fontify-priorities nil)
            (org-agenda-dim-blocked-tasks nil)))
          ("P" "Plain text daily agenda and top priorities"
           ,prot-org-custom-daily-agenda
           ((org-agenda-with-colors nil)
            (org-agenda-prefix-format "%t %s")
            (org-agenda-current-time-string ,(car (last org-agenda-time-grid)))
            (org-agenda-fontify-priorities nil)
            (org-agenda-remove-tags t))
           ("agenda.txt"))))

  ;; I bind `org-agenda' to C-c a, so this one puts me straight into my
  ;; custom block agenda.
  (define-key global-map (kbd "C-c A") (lambda () (interactive) (org-agenda nil "A")))

  (add-to-list 'org-capture-templates
               '("j" "Music suggestion (jukebox)" entry
                 (file+headline "tasks.org" "Music suggestions")
                 #'prot-org-capture-jukebox
                 :empty-lines-after 1
                 :immediate-finish t)))
#+end_src

Here are my few extras for Org (from [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-org.el src emacs-lisp :tangle no

** Calendar and Diary (and prot-diary.el)
:PROPERTIES:
:CUSTOM_ID: h:b4040bc0-7a2a-4f17-824d-42de621bd1b9
:END:

Relevant information for what you are about to read in this section
(the list will be updated accordingly):

+ [[https://protesilaos.com/codelog/2021-04-14-emacs-diary-calendar/][Video of Emacs Diary and Calendar for tracking appointments]] (2021-04-14).
+ [[https://protesilaos.com/codelog/2021-04-15-emacs-diary-outline-minor-mode/][Make the Emacs Diary work as an Outline (outline-minor-mode)]] (2021-04-15).
+ [[https://www.youtube.com/watch?v=n8o66i08fzs][Video on using Hyperbole with the Emacs Diary]] by the Emacs Elements
  channel (Raoul Comninos) (2021-04-16).

Emacs provides a suite of tools for planning events or recording dates
of interest in your life.  These are part of the same workflow, but are
divided into several smaller libraries.  The two main ones are
=diary-lib.el= and =calendar.el=.  I extend them with =prot-diary.el=, which
is reproduced at the end of this section, after the package
configurations.

=diary-lib.el= defines everything that pertains to the =diary-file=
(defaults to =~/.emacs.d/diary=, which is what I want).  The Diary has a
two-fold purpose: (i) to store entries about calendar events, and (ii)
to display such events for the given day or range thereof.

In the first case, the Diary functions as a regular buffer that you may
edit freely.  This is where you can write one-off or recurring events
using various date and time formats expressed in natural language or as
Elisp forms (a sexp or "symbolic expression").

When it comes to single events for a given day, I prefer to input them
on a whole line using the ISO 8601 standard and a 24-hour clock, like
this: =2021-04-13 15:00 Description of event=.

For multiple events that are clustered on the same day, I write the date
on its own line and below it place a description of each event
optionally preceded by a timestamp.  Entries with no timestamp come
first, followed by those that are time sensitive.  This is just a matter
of personal style.

In this scenario of grouped events under a given date, each entry below
the date has to start with at least one empty space, otherwise the Diary
will try to interpret them as two distinct expressions (the exact number
of spaces is a matter of preference).  So the format looks like this
(use =C-x TAB= (=indent-rigidly=) to incrementally adjust the indentation of
the active region, or =C-u C-x TAB= to increase by four spaces):

#+begin_example
2021-04-13
    This event is not time sensitive
    06:30-09:00 Hiking
    10:00 Prepare sourdough bread
    11:00-13:00 Write stuff
#+end_example

The following is also possible, but looks too busy for no good reason:

#+begin_example
2021-04-13 This event is not time sensitive
2021-04-13 06:30-09:00 Hiking
2021-04-13 10:00 Prepare sourdough bread
2021-04-13 11:00-13:00 Write stuff
#+end_example

Though not required, you can separate events by an empty line.  Keeps
things easy to read.  Remember that lines that contain at least one
space are thought to belong to the closest date entry above them.  Which
means that for multiple events on a given day you can use something like
this, if you need to (here dots represent empty spaces):

#+begin_example
2021-04-13
    This event is not time sensitive
....
    06:30-09:00 Hiking
....
    10:00 Prepare sourdough bread
....
    11:00-13:00 Write stuff
#+end_example

Furthermore, it is possible to use nested levels of indentation or, in
my case, call =prot-simple-cite-region= and indent it accordingly (check
the source code: [[#h:ae48fe61-a3c3-4132-8986-785f9bfbeafb][Common custom functions (prot-simple.el)]]).  For
example:

#+begin_example
2021-04-13
    This event is not time sensitive
....
    06:30-09:00 Hiking
    +----[ Sample text ]
    | This is some random text
    | It relates to the above event
    +----
....
    10:00 Prepare sourdough bread
    11:00-13:00 Write stuff
#+end_example

Remember that these are mere stylistic considerations.  I generally
prefer to keep things simple, though I appreciate the flexibility of
adapting the view of my evolving needs.

I prefer to defer all formatting related decisions until after I have
typed in all the information.  My =prot-diary-align-timestamped-entries=
lets me align the negative space between an entry's timestamp and its
description.  Consider the following block and suppose that the region
starts from the line below the date and ends at the end of the line with
the last entry (demarcated by the =|= characters).

#+begin_example
2021-04-13
|This event is not time sensitive
06:30-09:00 Hiking
10:00 Prepare sourdough bread
11:00-13:00 Write stuff|

...becomes...

2021-04-13
    This event is not time sensitive
    06:30-09:00 Hiking
    10:00       Prepare sourdough bread
    11:00-13:00 Write stuff
#+end_example

For anniversaries or cyclic events, I rely on Elisp.  It is better to
read the Emacs manual on the technicalities as there are lots of
examples that should help you get started.  Just bear in mind that the
exact order for the =YEAR=, =MONTH=, =DATE= arguments depends on the value
assigned to the variable =calendar-date-style=.  As I already noted, I
follow the ISO style (evaluate this: =(format-time-string "%F")=).

The second use case of the Diary, namely, of showing the events it holds
is controlled by the variable =diary-display-function=.  On my setup it
should present the information in a read-only buffer that is internally
referred to as the "fancy" style.  To bring up that interface, you can
either use the Calendar as a starting point (more on that later) or call
a command directly, such as =prot-diary-display-entries=.  The resulting
buffer is fairly straightforward: there is a date header (or many
depending on the prefix numeric argument) and below that one or more
entries related to it.  Those retain the indentation of the underlying
Diary file, as described above.  Hit =RET= over an entry to visit the
editable version of the Diary.

Apart from displaying that buffer on demand, it is possible to get its
information emailed to you.  The built-in command for that is
=diary-mail-days=, however it has the downside of sending a mail even when
there are no events for the day[s] specified.  I do not see the utility
of such behaviour: what is the purpose of drawing attention to my email
client, only to waste my time with some "nothing to see here" message?
Whereas =prot-diary-mail-entries= only sends a message when that is the
right thing to do, i.e. when there is something that requires our
attention (for N days or =diary-mail-days=).  It also has the benefit of
not popping up the Diary display in another window as a side effect of
sending the email (check =prot-diary--mail-fn= for the technicalities).  I
set it up to automatically try to send me an email briefing each morning
when I launch Emacs.

Email briefings just offer an overview of events in the immediate
future.  We still need a mechanism to alert us some minutes in advance
of a time sensitive appointment.  This is where the =appt.el= library
comes in handy.  It already knows how to scan the Diary in search for
time expressions and produce reminders for them: all it needs is to be
activated with =(appt-activate 1)=.  Unlike email, this is a more
persistent method of producing notifications inside of Emacs in the form
of a pop-up window and a complementary modeline indicator with a
countdown to the event.  The default notification time is specified in
the variable =appt-message-warning-time=, though individual Diary entries
can declare their own time (in minutes), by holding some extra text as
defined in =appt-warning-time-regexp=.  Put that in a comment
(=diary-comment-start=) to disambiguate it from the entry's description.
For example, this Diary entry will work as expected with my
configurations: =2021-04-13 18:00 Some task ;; appt 5=.  The =;; appt 5=
part will not be shown in the Diary display, but will still activate the
reminder.  Nice and simple!

To recapitulate, the Diary is flexible enough to accommodate a variety
of preferences on how to organise one's life events.  The key to get
started is to learn how to edit the actual file, which is fairly easy.
It then is trivial to either display that information on demand or be
notified about it.

Let us now cover the other major component of this suite of tools: the
Calendar.  The main point of entry is =M-x calendar=.  It displays a
horizontal three-month view centred on the current month.  Moving in the
calendar is consistent with regular Emacs motions: =C-f= and =C-b= move one
day forward/backward, =C-n= and =C-p= go down and up one week, =C-a= and =C-e=
place the point at the beginning or end of the week, respectively.  Then
we have the equivalent of paragraph and page motions: =M-{= and =M-}= which
travel forward/backward a full month, with =C-v= and =M-v= moving to the
next and previous three-month set.  To merely scroll the horizontal
calendar strip, use =<= and =>= to do so in the given direction.  As always,
do not forget to type =C-h m= (=describe-mode=) in any major-mode buffer you
are unfamiliar with to get help for it: you will learn about those
motions and some more of them (and always check the manual as well).

The Calendar offers an overview of your Diary entries, as noted above,
and, optionally, of all holidays that you have opted in to.  For the
latter, check the variable =calendar-holidays=.  I set it to only a small
set of records largely for experimental purposes, as I am not interested
in either religious or secular special days.  Consider this, if you
will, an attempt at introducing the illusion of eventfulness in my
calendar.  I really don't care about any of this.

To mark Diary entries in the Calendar, use =m= (=diary-mark-entries=).  That
accepts a prefix argument (=C-u=) in case you wish to redraw those marks.
Here we should clarify that "marks" are Emacs faces by default, unless
you explicitly override them with characters.  I prefer faces, which
leave a more pleasant, less noisy impression.  Similarly, use =x=
(=calendar-mark-holidays=) to mark holidays.  Both of those tasks can be
performed automatically upon accessing the Calendar, by setting the
variables =calendar-mark-diary-entries-flag=, =calendar-mark-holidays-flag=
to non-nil values (which is what I do).

Events that should not appear in the Calendar when Diary entries are
marked must be preceded with a special character, which is configurable
by means of =diary-nonmarking-symbol=.  I personally have no use for this,
because if something is not worth being marked, then it is not pointless
to keep track of it in my day-to-day planner.

While in the Calendar, you can move the point over a marked day and type
=d= (=diary-view-entries=) to show the read-only variant of the Diary, as
outlined above.  Or pass a number to it to encompass the Nth days
(e.g. typing =7 d= will show Diary entries for seven days starting from
the current one).  If the mark pertains to a holiday, type =h= to get a
message in the echo area about it (=calendar-cursor-holidays=).

If you opt to use my settings, the best way to learn how to disambiguate
the two marks is to access the Calendar and hit =u= (=calendar-unmark=).
Follow it up with =m= to mark Diary entries and =x= to render holiday marks.

Other than viewing what happens on a given day or date range, you can
use the Calendar to record new entries in the Diary.  I group those
under the =i= prefix key: so type, =i= and then =C-h= to get help about all
possible keys that complete that sequence and references to the commands
they call.  Note that to insert a block event you need to hit =C-SPC= on
the starting date and then move point to the ending day at which you
should do =i b= (=diary-insert-block-entry=).

It is possible to use more faces than the ones which are provided by
default.  To do so, you need to specify a face argument to the various
Elisp expressions that can be written to the Diary.  For example, my
=prot-diary.el= (reproduced further below) has a bespoke face for
"administrative tasks", which can be assigned to the given expression
like this (new line and indentation are optional, as mentioned above,
otherwise keep everything on one line):

#+begin_example
 %%(diary-date t t 13 'prot-diary-calendar-administrative-mark)
     Some administrative monthly task
 %%(diary-anniversary 1900 4 13 'prot-diary-calendar-anniversary-mark)
     Some anniversary is %d years
#+end_example

The manual covers a lot of other potentially useful tasks you may
accomplish with those tools.  For example, it is possible to import an
iCalendar, convert from one calendar to another (e.g. Gregorian to
Chinese), get the phases of the moon, sunset and sunrise times in the
given geographic coordinates...  Evaluate this expression to start
reading the relevant Info nodes: =(info "(emacs) Calendar/Diary")=.

For the integration with =outline-minor-mode= that =prot-diary.el= provides,
refer to the relevant section (in short: you get header folding like in
Org for every line that starts with =;;;=, given my =diary-comment-start= is
=;;=): [[#h:a8e737b8-7c90-4c68-8814-acf2f637ffa1][Outline mode, outline minor mode (prot-outline.el)]].

Finally, note that I control the placement of those buffers in the
=display-buffer-alist= (read: [[#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][Window rules and basic tweaks]]).

#+begin_src emacs-lisp
;;; Calendar and Diary (and prot-diary.el)
(prot-emacs-builtin-package 'calendar
  (setq calendar-mark-diary-entries-flag t)
  (setq calendar-mark-holidays-flag t)
  (setq calendar-mode-line-format nil)
  (setq calendar-time-display-form
        '(24-hours ":" minutes
                   (when time-zone
                     (format "(%s)" time-zone))))
  (setq calendar-week-start-day 1)      ; Monday
  (setq calendar-date-style 'iso)
  (setq calendar-date-display-form calendar-iso-date-display-form)
  (setq calendar-time-zone-style 'numeric) ; Emacs 28.1

  (require 'solar)
  (setq calendar-latitude 35.17         ; Not my actual coordinates
        calendar-longitude 33.36)

  (require 'cal-dst)
  (setq calendar-standard-time-zone-name "+0200")
  (setq calendar-daylight-time-zone-name "+0300")

  (require 'diary-lib)
  (setq diary-mail-addr user-mail-address)
  (setq diary-date-forms diary-iso-date-forms)
  (setq diary-comment-start ";;")
  (setq diary-comment-end "")
  (setq diary-nonmarking-symbol "!")
  (setq diary-show-holidays-flag t)
  (setq diary-display-function #'diary-fancy-display) ; better than its alternative
  (setq diary-header-line-format nil)
  (setq diary-list-include-blanks nil)
  (setq diary-number-of-entries 2)
  (setq diary-mail-days 2)
  (setq diary-abbreviated-year-flag nil)

  (add-hook 'calendar-today-visible-hook #'calendar-mark-today)
  (add-hook 'diary-list-entries-hook 'diary-sort-entries t)
  (add-hook 'diary-mode-hook #'goto-address-mode) ; buttonise plain text links

  ;; Those presuppose (setq diary-display-function #'diary-fancy-display)
  (add-hook 'diary-list-entries-hook 'diary-include-other-diary-files)
  (add-hook 'diary-mark-entries-hook 'diary-mark-included-diary-files)

  ;; Prevent Org from interfering with my key bindings.
  (remove-hook 'calendar-mode-hook #'org--setup-calendar-bindings)

  (let ((map calendar-mode-map))
    (define-key map (kbd "s") #'calendar-sunrise-sunset)
    (define-key map (kbd "l") #'lunar-phases)
    (define-key map (kbd "i") nil) ; Org sets this, much to my chagrin (see `remove-hook' above)
    (define-key map (kbd "i a") #'diary-insert-anniversary-entry)
    (define-key map (kbd "i b") #'diary-insert-block-entry)
    (define-key map (kbd "i c") #'diary-insert-cyclic-entry)
    (define-key map (kbd "i d") #'diary-insert-entry) ; for current "day"
    (define-key map (kbd "i i") #'diary-insert-entry) ; most common action, easier to type
    (define-key map (kbd "i m") #'diary-insert-monthly-entry)
    (define-key map (kbd "i w") #'diary-insert-weekly-entry)
    (define-key map (kbd "i y") #'diary-insert-yearly-entry)
    (define-key map (kbd "M-n") #'calendar-forward-month)
    (define-key map (kbd "M-p") #'calendar-backward-month)))

(prot-emacs-builtin-package 'appt
  (setq appt-display-diary nil)
  (setq appt-disp-window-function #'appt-disp-window)
  (setq appt-display-mode-line t)
  (setq appt-display-interval 3)
  (setq appt-audible nil)
  (setq appt-warning-time-regexp "appt \\([0-9]+\\)")
  (setq appt-message-warning-time 6)

  (run-at-time 10 nil #'appt-activate 1))

(prot-emacs-builtin-package 'prot-diary
  ;; The idea is to get a reminder via email when I launch Emacs in the
  ;; morning and this file is evaluated.  Obviously this is not a super
  ;; sophisticated approach, though I do not need one.
  (let ((time (string-to-number (format-time-string "%H"))))
    (when (and (> time 4) (< time 9))
      (run-at-time (* 60 5) nil #'prot-diary-mail-entries)))

  (require 'holidays)
  (setq calendar-holidays (append holiday-solar-holidays prot-diary-local-holidays))

  (with-eval-after-load 'prot-outline
    (add-hook 'diary-mode-hook #'prot-outline-minor-mode-safe))

  (let ((map diary-mode-map))
    (define-key map (kbd "<M-return>") #'prot-diary-newline-indent)
    (define-key map (kbd "M-n") #'prot-diary-heading-next)
    (define-key map (kbd "M-p") #'prot-diary-heading-previous)
    (define-key map (kbd "C-c C-a") #'prot-diary-align-timestamped-entries))
  (let ((map global-map))
    (define-key map (kbd "C-c d c") #'calendar)
    (define-key map (kbd "C-c d d") #'prot-diary-display-entries)
    (define-key map (kbd "C-c d e") #'prot-diary-edit-diary)
    (define-key map (kbd "C-c d i") #'prot-diary-insert-entry)
    (define-key map (kbd "C-c d m") #'prot-diary-mail-entries)))
#+end_src

These are the contents of the =prot-diary.el= library (find the source
code in [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]] (as with all my Elisp code)):

#+include: prot-lisp/prot-diary.el src emacs-lisp :tangle no

** Email settings
:PROPERTIES:
:CUSTOM_ID: h:5ad80664-3163-4d9d-be65-462637d77903
:END:

Once you delve into the technical details, email is hard as it consists
of arcane specs and protocols.  Combined with Emacs' open-endedness as
well as the wealth of free software command-line programs on offer,
there are seemingly infinite ways to set things up.  The toolset for my
current setup consists of the following:

+ The external =mbsync= program to periodically synchronise my remote
  email server and my local mail directories.  This allows me to keep a
  copy of my correspondence, while it removes the burden of updating
  mail sources from the client.  The latter benefit is particularly
  important to avoid slowing down Emacs.

+ The Notmuch package which includes the CLI program and the Emacs
  library that implements a Mail User Agent.  Notmuch is a mail indexer
  that can search through the database using a strictly tags-only
  workflow.  I was using Gnus in the past (between early 2020 and May
  2021), but ultimately decided to upgrade my workflow by going with the
  more flexible approach of Notmuch (I had also used Mu4e before, which
  is closer in spirit to Notmuch and is a good choice overall---in the
  source code of my dotfiles, from where you can find this document,
  there is the =prot-mu4e-deprecated-conf.el= file in case you need it;
  same for =prot-gnus-deprecated-conf.org=).

+ The built-in capabilities to compose and send email.

+ Other extensions to integrate email composition with encryption tools,
  Dired, Org, contact-completion (EBDB)...

*This is a mega section that encompasses all of the aforementioned.*
Please study it carefully.

*** Client-agnostic email settings (and prot-mail.el)
:PROPERTIES:
:CUSTOM_ID: h:a82766be-daab-4925-b23a-1c5ffd47e599
:END:

Before configuring any mail user agent, we need to establish the
absolute essentials: who we are, where our authentication credentials
are stored, and whether encryption is to be supported.  We must also
define how message composition should work.  This is what the following
configurations are about.

+ The =mail-user-agent= and =message-mail-user-agent= concern the default
  email composition buffer, called with =C-x m= or any other facility that
  falls back to the =compose-mail= function.  The default is =message-mode=.

  - When notmuch is in use, it will insert a special "Fcc" header whose
    task is to copy the outgoing message to the appropriate maildir path
    (this part is done in [[#h:a196812e-1644-4536-84ba-687366867def][the Notmuch section]]).

+ The value of =message-citation-line-format= is expanded into something
  like /"On 2020-02-19, 13:54 +0200, NAME <EMAIL> wrote:"/.  To learn
  about all the date-related specifiers, it is better to read the
  documentation with =M-x describe-variable RET format-time-string RET=.

+ The =mm-encode= and =mml-sec= are meant to come into effect when
  encrypting and signing an outgoing message, such as with =C-c C-m C-e=
  (=mml-secure-message-sign-encrypt=).  The optional guided key selection
  will ask for confirmation on who to encrypt to.  It presents a list
  with the available keys.  Items are marked with =m= and then the mail
  can be sent with the standard commands (e.g. =C-c C-c=).  I used that
  setup for a while, but ultimately decided that the extra steps did not
  make any difference to my workflow, as I always double-check before
  sending out an email.

+ The =gnus-dired= library can be used independently of Gnus (and should
  thus be refactored as "message-dired.el" or something).  It provides
  glue code that integrates Dired buffers with message composition, so
  that one can attach either the file at point or the marked ones with
  =C-c C-m C-a= (=gnus-dired-attach=).

#+begin_src emacs-lisp
;;; Client-agnostic email settings (and prot-mail.el)
(prot-emacs-builtin-package 'auth-source
  (setq auth-sources '("~/.authinfo.gpg"))
  (setq user-full-name "Protesilaos Stavrou")
  (setq user-mail-address "public@protesilaos.com"))

(prot-emacs-builtin-package 'mm-encode
  (setq mm-encrypt-option nil) ; use 'guided if you need more control
  (setq mm-sign-option nil))   ; same

(prot-emacs-builtin-package 'mml-sec
  (setq mml-secure-openpgp-encrypt-to-self t)
  (setq mml-secure-openpgp-sign-with-sender t)
  (setq mml-secure-smime-encrypt-to-self t)
  (setq mml-secure-smime-sign-with-sender t))

(prot-emacs-builtin-package 'message
  (setq mail-user-agent 'message-user-agent)
  (setq mail-header-separator (purecopy "*****"))
  (setq message-elide-ellipsis ">\n> [... %l lines elided]\n>\n>") ; NOTE 2021-07-13: experimental
  (setq compose-mail-user-agent-warnings nil)
  (setq message-mail-user-agent t)      ; use `mail-user-agent'
  (setq mail-signature "Protesilaos Stavrou\nhttps://protesilaos.com\n")
  (setq message-signature "Protesilaos Stavrou\nhttps://protesilaos.com\n")
  (setq message-citation-line-format "On %Y-%m-%d, %R %z, %f wrote:\n")
  (setq message-citation-line-function
        'message-insert-formatted-citation-line)
  (setq message-confirm-send nil)
  (setq message-kill-buffer-on-exit t)
  (setq message-wide-reply-confirm-recipients t)
  (add-to-list 'mm-body-charset-encoding-alist '(utf-8 . base64))

  (add-hook 'message-setup-hook #'message-sort-headers))

(prot-emacs-builtin-package 'gnus-dired ; does not require `gnus'
  (add-hook 'dired-mode-hook #'gnus-dired-mode))

(prot-emacs-builtin-package 'prot-mail
  ;; NOTE 2021-05-14: This is a generic indicator for new mail in the
  ;; maildir.  As I now use notmuch (see relevant section in this
  ;; document) I have an alternative approach in prot-notmuch.el.
  (setq prot-mail-maildir-path-regexp "~/.mail/*/Inbox/new/") ; shell regexp
  (setq prot-mail-mode-line-indicator-commands
        '(notmuch-refresh-this-buffer))
  ;; mode line indicator with the number of new mails
  (prot-mail-mail-indicator -1))
#+end_src

And here is =prot-mail.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-mail.el src emacs-lisp :tangle no

**** Sample of authinfo.gpg
:PROPERTIES:
:CUSTOM_ID: h:8d0bd754-8a31-431b-b112-f541cc0144ac
:END:

Below is a sample with the contents of my =authinfo.gpg=.  This is read,
inter alia, by =notmuch= and =smtpmail= to be able to both fetch and send
messages from the given account.  By default, one can use a generic
=authinfo= file though I consider that reckless: I strongly encourage you
to *encrypt this file* if you add your login credentials there.  Do it
from inside =dired= with =: e= while the point is over the file.  Emacs can
decrypt all encrypted files automatically.

#+begin_example
machine prv port 993 login MAIL password SECRET
machine inf port 993 login MAIL password SECRET
machine pub port 993 login MAIL password SECRET

machine mail.gandi.net port 465 login MAIL password SECRET
machine mail.gandi.net port 465 login MAIL password SECRET
machine mail.gandi.net port 465 login MAIL password SECRET
#+end_example

Refer to your email provider's documentation in order to determine the
port number and server address you need to use for sending and receiving
messages.  The =MAIL= is either your email address or some username for
logging into the account.

Note that the terms I use above for =prv=, =inf=, and =pub= are just arbitrary
names for the given =MAIL= and =SECRET= combination.  This allows me to
reference each name in the various package configurations in this
document, and share them publicly without worrying about leaking
sensitive data.

Which brings us to the point of actually retrieving those values.  The
=prot-mail-auth-get-field= is designed to return a field from the authinfo
file (this function is defined in my =prot-mail.el=, which is reproduced
at the end of [[#h:a82766be-daab-4925-b23a-1c5ffd47e599][Client-agnostic email settings (and prot-mail.el)]]).  You
will find this function used elsewhere in this document.  For example,
to get the username and password for host =inf= we do:

#+begin_example emacs-lisp
(prot-mail-auth-get-field "inf" :user)   ; login name
(prot-mail-auth-get-field "inf" :secret) ; password
#+end_example

**** .mbsyncrc
:PROPERTIES:
:CUSTOM_ID: h:88a605b8-d5b5-486f-87c9-0c80b423ae36
:END:

I already noted in the introduction to [[#h:5ad80664-3163-4d9d-be65-462637d77903][Email settings]] that my emails are
synced locally using the =mbsync= executable.  This program is part of a
package that, depending on your operating system, is called "isync".
Read the [[https://wiki.archlinux.org/index.php/Isync][Arch Wiki entry on mbsync]].

My =~/.mbsyncrc= is furnished below.  Note that the =awk= call reads from
the =~/.authinfo.gpg= (see [[#h:8d0bd754-8a31-431b-b112-f541cc0144ac][Sample of authinfo.gpg]]).

#+include: ../../mbsync/.mbsyncrc src conf :tangle no

*** Notmuch (mail indexer and mail user agent (MUA))
:PROPERTIES:
:CUSTOM_ID: h:a196812e-1644-4536-84ba-687366867def
:END:

Also watch the video of what you are about to read in the following
paragraphs: [[https://protesilaos.com/codelog/2021-05-15-emacs-notmuch/][Demo of the Emacs front-end to Notmuch]] (2021-05-15).


At its core, Notmuch is a command-line program that maintains an index
of a maildir directory structure and is capable to search through it
using a tag-based method.  Notmuch is both minimalist and powerful:

1. its clearly delimited role as a mail indexer allows it to be used in
   a variety of setups that involve different tools on how to handle
   email traffic;

2. while its tag-centric design lifts the inherent restrictions of
   complex filesystem paths on where a file must be stored, as messages
   can be grouped together dynamically depending on the search criteria.

In terms of overall setup, I use Notmuch together with =mbsync= to
synchronise my maildir with the IMAP server (consult my [[#h:88a605b8-d5b5-486f-87c9-0c80b423ae36][.mbsyncrc]]).
While I send messages with Emacs' own facility which relies on the
=sendmail= program (refer to [[#h:2d793cf8-83f5-4830-b73d-78385d9b96dd][Sending email (SMTP)]]).  The latter may change
in the future, as I weigh the pros and cons of programs like =msmtp=,
though this is low on my list of priorities.  As for the actual
composition of emails, it is done by Emacs' =message.el= library
([[#h:a82766be-daab-4925-b23a-1c5ffd47e599][Client-agnostic email settings (and prot-mail.el)]]).

Tagging is integral to the Notmuch experience, because it allows you to
cope with evolving circumstances.  It is best to consider this by means
of an example.  Suppose that you are working on some project: (1) there
is an email in your private account from a close friend that contains
valuable information but which is part of an otherwise long thread that
is not pertinent in its entirety to the task at hand, (2) there is
another message from a mailing list you do not actively participate in
and this message lives in your "throwaway" account that you use only for
mailing lists and the like, and (3) there is yet another mail from some
client or employer that is specific to the project and which is kept in
your designated "professional" inbox.  Lets say that those correspond to
"private@example.tld", "lists@example.tld", "work@example.tld".  In a
folder-based approach, it is hard to combine those otherwise unrelated
files.  Whereas with tags, say, =+project=, we can get everything into
focus with a simple search for =tag:project=.

While we will be using the Emacs interface to Notmuch, it is important
to spend some time reading the man pages for the CLI tools.  Some
examples for searching:

#+begin_example
$ notmuch search from:prot*
$ notmuch search from:protesilaos tag:todo
$ notmuch search from:protesilaos or from:socrates
$ notmuch search 'from:"/(info|public)@protesilaos.com/"'
$ notmuch search 'from:"/(info|public)@protesilaos.com/"' date:yesterday..today
$ notmuch search '(from:"*@protesilaos.com*" not to:"*@protesilaos.com*")' date:today
$ notmuch search from:"*@protesilaos.com*" date:today..08:00
$ notmuch search body:recrudescence
$ notmuch search path:inf/Inbox/** date:2021-05
#+end_example

There is no need to develop expertise in that syntax at the outset.
Just learn the basics and let the rest grow organically through regular
usage.  Though do read the man pages as they include important
information such as what "stemming" is and how it affects your search
results.

Now let's focus on the Emacs side of things, starting with the
"notmuch-hello" buffer (it runs =notmuch-hello-mode=).  What exactly shows
up here depends on =notmuch-hello-sections=.  I like to keep it clean.  At
any rate, from here we can switch to results from saved searches or
tags, or perform a new search:

+ Type =j= to invoke =notmuch-jump-search=: it will produce a prompt for a
  key binding that corresponds to one of your saved searches (controlled
  by the variable =notmuch-saved-searches=).

+ With =t= for =notmuch-search-by-tag= you get minibuffer completion against
  all known tags.

+ Hit =s= to call =notmuch-search= which lets you type a query such as one
  of the aforementioned examples.  In the "notmuch-hello" buffer I keep
  a list of recent searches, which can be helpful to re-use at a later
  point, though we can always benefit from minibuffer history
  navigation, such as =M-n= and =M-p= while at the =notmuch-search= prompt.

+ Same principle for =z= (=notmuch-tree=) only it differs from the above
  search in the overall presentation where it visualises each thread
  using indentation and arrows to show what belongs where.  It also
  reduces the subject line to the first entry in each thread, making it
  easier to follow the results.

All of those will put you in a buffer that runs =notmuch-search-mode=.  As
always, you should use =C-h m= (=describe-mode=) to learn about everything
related to the current major mode (as well as all active minor modes).

To further limit the results to an arbitrary list of search criteria,
use =l= (=notmuch-search-filter=) and then supply whatever terms are needed.
Or use =t=, which is here bound to =notmuch-search-filter-by-tag= to filter
directly by tag using completion.  For example, I can start from the
"notmuch-hello" buffer with =notmuch-search-by-tag=, select "todo", and
then use =l= or =t= to further narrow to, say, a "replied" tag or
=date:today=.

Filtering of search results is the best way to narrow the list to
relevant matches.  You can try supplying just a search term without any
keywords and you are likely to get what you are looking for.  For
example, I was in a search that included results from the emacs-devel
and bug-gnu-emacs mailing lists and had several unread threads, though I
only wanted to read about "group-function".  So I just hit =l=
(=notmuch-search-filter=) and then typed in that query.  Same principle if
you wish to exclude something, such as with =not tag:flag=.

The Notmuch presentation is compact when it comes to longer threads as
it reduces them to a single line.  We can still get a sense of context
by viewing the total count of messages in the thread: this is controlled
by the variable =notmuch-search-result-format=.  While I like this as a
default, there are cases where we need to visualise the email exchanges:
=notmuch-tree-from-unthreaded-current-query= can do just that and is bound
to =Z= in =notmuch-search-mode-map=.  A similar variant is =U= for
=notmuch-unthreaded-from-search-current-query=, as it expands the view
without adding the tree indicators and without de-duplicating subject
lines across the threads.  Go back to the standard search view with =S=
(=notmuch-search-from-tree-current-query=).

All those changes in presentation happen in new buffers: you do not lose
anything, unless you explicitly kill those buffers.  For the sake of
convenience, Notmuch provides the =notmuch-bury-or-kill-this-buffer=
command, bound to =q= in all those views.  Read its doc string to know
when it kills and when it buries the buffer.  Of course, you may always
use commands like =previous-buffer= as well as minibuffer completion and
=M-x ibuffer= or whatever else you normally use.  The point is that you
can easily switch views to get the job done.

Speaking of multiple buffers, Notmuch provides two commands to refresh
those: (i) =notmuch-refresh-this-buffer=, which is bound by default to the
usual =g= key as well as ===, and (ii) =notmuch-refresh-all-buffers= which is
assigned to =M-g=.  My =prot-notmuch-refresh-buffer= is a wrapper of those
two and is mapped to =g=: when called with a =C-u= prefix argument, it
refreshes all buffers, else it operates on the current one.  There is
also =G= (=notmuch-poll-and-refresh-this-buffer=) which runs =notmuch new=
externally and then refreshes the buffer---personally I don't need this
as mbsync automatically does that every few minutes.

To read a thread, hit =RET= (=notmuch-search-show-thread=) with point over
it in any those search/tree views.  That puts you in =notmuch-show-mode=
(did I tell you about =C-h m=?).  Notmuch organises all messages in the
thread as headings, where the first line with the summary of the message
uses a special face (a background colour, though that depends on the
theme).  With point over the heading's line =RET= expands or contracts the
body of the message.  The =n= and =p= keys move between expanded messages in
the thread, while =N= and =P= always go to the next and previous items,
respectively.  An Imenu index is also available, so you can jump to any
heading using minibuffer completion (with =M-x imenu= or some third-party
extension like the =consult-imenu= that I use).

When you compose an email, such as by replying with =r= or =R=, you are
taken to a buffer that leverages functionality provided by the built-in
=message.el=.  As always, run =C-h m= to get a sense of how things work and
what commands you may call: =C-c C-c= dispatches the email, =C-c C-a=
prompts for an attachment, =C-c C-m C-e= encrypts and signs, =C-c C-m C-a=
from a Dired buffer attaches the file at point or any marked ones (refer
to [[#h:a82766be-daab-4925-b23a-1c5ffd47e599][Client-agnostic email settings (and prot-mail.el)]]).

For searching to be productive, we must apply tags in accordance with a
defined method of organising our workflow (more about my approach
further below).  Too many over-specialised or poorly considered tags
will likely make things more difficult, while too few will probably
prevent you from finding what you need.  How you go about it is up to
you.  Notmuch is just a tool: don't believe in the hype of magical
exominds or second brains that do the work on your behalf---maximise the
potential of the one mind you have and the rest will follow from there.

Tag addition or removal is denoted by a plus or minus prefix to the name
of the tag.  The =k= binding exists in all relevant mode maps: it offers a
shortcut to the "keys" (tags) that can be used to mark a give entry.
That command will prompt for a choice among =notmuch-tagging-keys=.  For
example =k d= will do =+del -inbox=, based on what I currently have.  Invert
the meaning of those terms by prefixing the command with a =C-u= argument.

To freely tag all items in the current view (search, tree, show) use =*=.
That gives you a completion prompt where multiple terms can be supplied,
each delimited by a space (internally this is =completing-read-multiple=
and the space is governed by a let-bound =crm-separator=).  Combine that
with the aforementioned methods for limiting the view to a given subset
for maximum effect.

Other ways to perform tagging operations involve the =+= and =-= keys.  They
also use =completing-read-multiple=.  What those commands offer, beside
the minibuffer interface, is the ability to operate on the entries
encompassed by the active region, where point and mark delimit the lines
to be affected.  There are cases where marking a region is faster than
narrowing the view with new search criteria, so use whatever makes sense
at the moment.

Remember the governing principle of Notmuch: it does not touch your
mail.  All those tags are specific to the Notmuch database (with the
exception of some basic tags that are understood by the IMAP server and
can be optionally affected by Notmuch ([[#h:79803e19-1150-49a6-a3df-1cffe3d0cbc5][.notmuch-config]] has the
=synchronize_flags=true= directive).

As Notmuch is not a traditional mail client, it has neither opinions nor
capabilities on how one handles their maildir.  It does not move files
around nor does it have its own deletion and anti-spam mechanisms.  It
is up to the user to provide those.  While this may seem needlessly
limited at first, it is consistent with the precise function that
Notmuch performs in the broader email toolkit.  To actually delete mail,
we can tag it accordingly (e.g. "del") and then run this command either
manually or from a script with some cron job or systemd timer:

#+begin_example
notmuch search --output=files --format=text0 tag:del | xargs -r0 rm
#+end_example

I actually prefer the manual method: mark items with =+del= and perform
their removal from the disk whenever it is expedient.  This has the
upside of offering me the chance to review the messages, in case I have
mislabelled some item: I have deleted legitimate mail before, so it is
not a bad idea to be extra careful.

I have no pressing need to define commands for moving my mail files
between different directories: I did not do that even while I was using
Gnus.  Though I might eventually do it just for the sake of
completeness.  As such, consider the following package configurations a
work-in-progress, though they already offer all I need to get things
done.

With regard to the use of tags for day-to-day usage, I like to employ
the =tag:inbox and tag:unread= search as well as =tag:inbox= for practically
everything that is unsorted or of general interest.  Then I have
specialised tags like "list" for mailing lists which should not belong
in the inbox and "todo" for messages that require some further action
(those can always be complemented by other tags for greater precision
such as =+list +emacs=).  To keep things in check, a "post-new" script
outside the Emacs setup performs initial tagging on new mail.  For
example, my sent messages are marked as =-unread= while new mailing list
traffic goes to its right place with tags like =-inbox +list= (refer to
the sections on [[#h:79803e19-1150-49a6-a3df-1cffe3d0cbc5][.notmuch-config]] and [[#h:70d60d41-cb63-4950-bbd9-9157c4d186dc][notmuch post-new rules]]).  Those that
I manually mark as =+todo= can optionally be combined with =org-capture= to
record a task that may appear in the Org agenda: call the =org-capture=
command while viewing such a message and Org will create a direct link
back to it: the glue code is found in [[#h:a7580136-cf32-44e8-81f6-590dbdd7f8f9][the section on ol-notmuch.el]] while
my =org-capture-templates= and their =org-capture-templates-contexts= are
defined in [[#h:4e8347de-415e-4804-b383-d61499e05ca1][Org-mode (personal information manager)]]).

Unlike most Emacs packages, I install =notmuch= from my distro's repos.
This is because (i) the CLI program is independent of Emacs, and (ii)
=notmuch.el= is bundled up together with the command-line tool because the
two are developed by the same group of people.  All good!  There is also
this note in =M-x find-library RET notmuch RET=:

#+begin_quote
Note for MELPA users (and others tracking the development version
of notmuch-emacs):

This emacs package needs a fairly closely matched version of the
notmuch program. If you use the MELPA version of notmuch.el (as
opposed to MELPA stable), you should be prepared to track the
master development branch (i.e. build from git) for the notmuch
program as well. Upgrading notmuch-emacs too far beyond the notmuch
program can CAUSE YOUR EMAIL TO STOP WORKING.

TL;DR: notmuch-emacs from MELPA and notmuch from distro packages is
NOT SUPPORTED.
#+end_quote

Finally, my =prot-notmuch.el= contains various commands and some minor
stylistic extras including a mode line indicator that shows a count of
all items matching the search terms =tag:unread and tag:inbox= (can be
configured by the variable =prot-notmuch-mode-line-search-args=).

#+begin_src emacs-lisp
;;; Notmuch (mail indexer and mail user agent (MUA))
;; I install notmuch from the distro's repos because the CLI program is
;; not dependent on Emacs.  Though the package also includes notmuch.el
;; which is what we use here (they are maintained by the same people).
(add-to-list 'load-path "/usr/share/emacs/site-lisp/")
(prot-emacs-builtin-package 'notmuch

;;; Account settings
  (setq notmuch-identities
        (let ((identities))
          (dolist (m `(,(prot-mail-auth-get-field "prv" :user)
                       ,(prot-mail-auth-get-field "inf" :user)
                       ,(prot-mail-auth-get-field "pub" :user)))
            (push (format "%s <%s>" user-full-name m) identities))
          identities))
  (setq notmuch-fcc-dirs
        `((,(prot-mail-auth-get-field "prv" :user) . "prv/Sent")
          (,(prot-mail-auth-get-field "inf" :user) . "inf/Sent")
          (,(prot-mail-auth-get-field "pub" :user) . "pub/Sent")))

;;; General UI
  (setq notmuch-show-logo nil)
  (setq notmuch-column-control t)
  (setq notmuch-hello-auto-refresh t)
  (setq notmuch-hello-recent-searches-max 20)
  (setq notmuch-hello-thousands-separator "")
  ;; ;; See my variant of it in `prot-notmuch' below.
  ;; (setq notmuch-hello-sections '(notmuch-hello-insert-saved-searches))
  (setq notmuch-show-all-tags-list nil)

;;; Search
  (setq notmuch-search-oldest-first nil)
  (setq notmuch-search-result-format
        '(("date" . "%12s  ")
          ("count" . "%-7s  ")
          ("authors" . "%-20s  ")
          ("subject" . "%-80s  ")
          ("tags" . "(%s)")))
  (setq notmuch-tree-result-format
        '(("date" . "%12s  ")
          ("authors" . "%-20s  ")
          ((("tree" . "%s")
            ("subject" . "%s"))
           . " %-80s  ")
          ("tags" . "(%s)")))
  (setq notmuch-search-line-faces
        '(("unread" . notmuch-search-unread-face)
          ("flag" . notmuch-search-flagged-face)))
  (setq notmuch-show-empty-saved-searches t)
  (setq notmuch-saved-searches
        `(( :name "inbox"
            :query "tag:inbox"
            :sort-order newest-first
            :key ,(kbd "i"))
          ( :name "unread (inbox)"
            :query "tag:unread and tag:inbox"
            :sort-order newest-first
            :key ,(kbd "u"))
          ( :name "unread all"
            :query "tag:unread not tag:archived"
            :sort-order newest-first
            :key ,(kbd "U"))
          ( :name "references"
            :query "tag:ref not tag:archived"
            :sort-order newest-first
            :key ,(kbd "r"))
          ( :name "todo"
            :query "tag:todo not tag:archived"
            :sort-order newest-first
            :key ,(kbd "t"))
          ( :name "mailing lists"
            :query "tag:list not tag:archived"
            :sort-order newest-first
            :key ,(kbd "m"))
          ;; Emacs
          ( :name "emacs-devel"
            :query "(from:emacs-devel@gnu.org or to:emacs-devel@gnu.org) not tag:archived"
            :sort-order newest-first
            :key ,(kbd "e d"))
          ( :name "emacs-orgmode"
            :query "(from:emacs-orgmode@gnu.org or to:emacs-orgmode@gnu.org) not tag:archived"
            :sort-order newest-first
            :key ,(kbd "e o"))
          ( :name "emacs-bugs"
            :query "'to:\"/*@debbugs.gnu.org*/\"' not tag:archived"
            :sort-order newest-first :key ,(kbd "e b"))
          ( :name "emacs-humanities"
            :query "(from:emacs-humanities@gnu.org or to:emacs-humanities@gnu.org) not tag:archived"
            :sort-order newest-first :key ,(kbd "e h"))
          ( :name "emacs-elpher"
            :query "(from:~michel-slm/elpher@lists.sr.ht or to:~michel-slm/elpher@lists.sr.ht) not tag:archived"
            :sort-order newest-first :key ,(kbd "e e"))
          ;; CLI tools
          ( :name "notmuch"
            :query "(from:notmuch@notmuchmail.org or to:notmuch@notmuchmail.org) not tag:archived"
            :sort-order newest-first
            :key ,(kbd "cn"))))

;;; Tags
  (setq notmuch-archive-tags '("-inbox" "+archived"))
  (setq notmuch-message-replied-tags '("+replied"))
  (setq notmuch-message-forwarded-tags '("+forwarded"))
  (setq notmuch-show-mark-read-tags '("-unread"))
  (setq notmuch-draft-tags '("+draft"))
  (setq notmuch-draft-folder "drafts")
  (setq notmuch-draft-save-plaintext 'ask)
  ;; ;; NOTE 2021-06-18: See an updated version in the `prot-notmuch'
  ;; ;; section below.
  ;; (setq notmuch-tagging-keys
  ;;       `((,(kbd "a") notmuch-archive-tags "Archive (remove from inbox)")
  ;;         (,(kbd "c") ("+archived" "-inbox" "-list" "-todo" "-ref" "-unread") "Complete and archive")
  ;;         (,(kbd "d") ("+del" "-inbox" "-archived" "-unread") "Mark for deletion")
  ;;         (,(kbd "f") ("+flag" "-unread") "Flag as important")
  ;;         ;; (,(kbd "r") notmuch-show-mark-read-tags "Mark as read")
  ;;         (,(kbd "r") ("+ref" "-unread") "Reference for the future")
  ;;         (,(kbd "s") ("+spam" "+del" "-inbox" "-unread") "Mark as spam")
  ;;         (,(kbd "t") ("+todo" "-unread") "To-do")
  ;;         (,(kbd "u") ("+unread") "Mark as unread")))
  (setq notmuch-tag-formats
        '(("unread" (propertize tag 'face 'notmuch-tag-unread))
          ("flag" (propertize tag 'face 'notmuch-tag-flagged))))
  (setq notmuch-tag-deleted-formats
        '(("unread" (notmuch-apply-face bare-tag `notmuch-tag-deleted))
          (".*" (notmuch-apply-face tag `notmuch-tag-deleted))))

;;; Email composition
  (setq notmuch-mua-compose-in 'current-window)
  (setq notmuch-mua-hidden-headers nil) ; TODO 2021-05-12: Review hidden headers
  (setq notmuch-address-command nil)    ; FIXME 2021-05-13: Make it work with EBDB
  (setq notmuch-always-prompt-for-sender t)
  (setq notmuch-mua-cite-function 'message-cite-original-without-signature)
  (setq notmuch-mua-reply-insert-header-p-function 'notmuch-show-reply-insert-header-p-never)
  (setq notmuch-mua-user-agent-function #'notmuch-mua-user-agent-full)
  (setq notmuch-maildir-use-notmuch-insert t)
  (setq notmuch-crypto-process-mime t)
  (setq notmuch-crypto-get-keys-asynchronously t)
  (setq notmuch-mua-attachment-regexp   ; see `notmuch-mua-send-hook'
        (concat "\\b\\(attache\?ment\\|attached\\|attach\\|"
                "pi[èe]ce\s+jointe?\\|"
                "συνημμ[εέ]νο\\|επισυν[αά]πτω\\)\\b"))

;;; Reading messages
  (setq notmuch-show-relative-dates t)
  (setq notmuch-show-all-multipart/alternative-parts nil)
  (setq notmuch-show-indent-messages-width 0)
  (setq notmuch-show-indent-multipart nil)
  (setq notmuch-show-part-button-default-action 'notmuch-show-save-part)
  (setq notmuch-show-text/html-blocked-images ".") ; block everything
  (setq notmuch-wash-citation-lines-prefix 6)
  (setq notmuch-wash-citation-lines-suffix 6)
  (setq notmuch-wash-wrap-lines-length 100)
  (setq notmuch-unthreaded-show-out nil)
  (setq notmuch-message-headers '("To" "Cc" "Subject" "Date"))
  (setq notmuch-message-headers-visible t)

;;; Hooks and key bindings
  (add-hook 'notmuch-mua-send-hook #'notmuch-mua-attachment-check)
  (remove-hook 'notmuch-show-hook #'notmuch-show-turn-on-visual-line-mode)
  (add-hook 'notmuch-show-hook (lambda () (setq-local header-line-format nil)))

  (let ((map global-map))
    (define-key map (kbd "C-c m") #'notmuch)
    (define-key map (kbd "C-x m") #'notmuch-mua-new-mail)) ; override `compose-mail'
  (define-key notmuch-search-mode-map (kbd "/") #'notmuch-search-filter) ; alias for l
  (define-key notmuch-hello-mode-map (kbd "C-<tab>") nil))

(prot-emacs-builtin-package 'prot-notmuch
  ;; Those are for the actions that are available after pressing 'k'
  ;; (`notmuch-tag-jump').  For direct actions, refer to the key
  ;; bindings below.
  (setq notmuch-tagging-keys
        `((,(kbd "a") notmuch-archive-tags "Archive (remove from inbox)")
          (,(kbd "c") prot-notmuch-mark-complete-tags "Complete and archive")
          (,(kbd "d") prot-notmuch-mark-delete-tags "Mark for deletion")
          (,(kbd "f") prot-notmuch-mark-flag-tags "Flag as important")
          (,(kbd "s") prot-notmuch-mark-spam-tags "Mark as spam")
          (,(kbd "t") prot-notmuch-mark-todo-tags "To-do")
          (,(kbd "x") prot-notmuch-mark-reference-tags "Reference for the future")
          (,(kbd "r") ("-unread") "Mark as read")
          (,(kbd "u") ("+unread") "Mark as unread")))

  (setq prot-notmuch-search-field-width 100)
  (setq notmuch-hello-sections '(prot-notmuch-hello-insert-saved-searches
                                 ;; prot-notmuch-hello-insert-recent-searches
                                 ))

  (add-to-list 'notmuch-tag-formats
               '("encrypted" (propertize tag 'face 'prot-notmuch-encrypted-tag)))
  (add-to-list 'notmuch-tag-formats
               '("sent" (propertize tag 'face 'prot-notmuch-sent-tag)))
  (add-to-list 'notmuch-tag-formats
               '("ref" (propertize tag 'face 'prot-notmuch-ref-tag)))
  (add-to-list 'notmuch-tag-formats
               '("todo" (propertize tag 'face 'prot-notmuch-todo-tag)))
  (add-to-list 'notmuch-tag-formats
               '("spam" (propertize tag 'face 'prot-notmuch-spam-tag)))

  ;; NOTE 2021-05-14: I have an alternative method of finding new mail
  ;; in a maildir tree by using the find command.  It is somewhat
  ;; simplistic, though it worked just fine: see prot-mail.el.  I prefer
  ;; this implementation instead, as it leverages notmuch and so I can
  ;; pass arbitrary search terms to it.
  (setq prot-notmuch-mode-line-count-args "tag:unread and tag:inbox")
  (setq prot-notmuch-mode-line-indicator-commands
        '(notmuch notmuch-refresh-this-buffer))
  ;; Mode line indicator with the number of new mails.
  (prot-notmuch-mail-indicator 1)

  (add-hook 'notmuch-hello-mode-hook #'prot-notmuch-widget-field-face-remap)

  (let ((map notmuch-search-mode-map))
    (define-key map (kbd "a") nil) ; the default is too easy to hit accidentally
    (define-key map (kbd "A") #'notmuch-search-archive-thread)
    (define-key map (kbd "D") #'prot-notmuch-search-delete-thread)
    (define-key map (kbd "T") #'prot-notmuch-search-todo-thread)
    (define-key map (kbd "X") #'prot-notmuch-search-reference-thread)
    (define-key map (kbd "C") #'prot-notmuch-search-complete-thread)
    (define-key map (kbd "S") #'prot-notmuch-search-spam-thread)
    (define-key map (kbd "g") #'prot-notmuch-refresh-buffer))
  (let ((map notmuch-show-mode-map))
    (define-key map (kbd "a") nil) ; the default is too easy to hit accidentally
    (define-key map (kbd "A") #'notmuch-show-archive-message-then-next-or-next-thread)
    (define-key map (kbd "D") #'prot-notmuch-show-delete-message)
    (define-key map (kbd "T") #'prot-notmuch-show-todo-message)
    (define-key map (kbd "X") #'prot-notmuch-show-reference-message)
    (define-key map (kbd "C") #'prot-notmuch-show-complete-message)
    (define-key map (kbd "S") #'prot-notmuch-show-spam-message)))
#+end_src

And here is =prot-notmuch.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-notmuch.el src emacs-lisp :tangle no

**** .notmuch-config
:PROPERTIES:
:CUSTOM_ID: h:79803e19-1150-49a6-a3df-1cffe3d0cbc5
:END:

What follows is my =~/.notmuch-config=.  The =tags=new= configuration is
what enables the use of initial tagging, as explained in the upstream
documentation (basically you want to tag some mail right after a
=notmuch new= such as, for example, to remove mailist list messages from
the inbox---see [[#h:70d60d41-cb63-4950-bbd9-9157c4d186dc][notmuch post-new rules]]).

The Emacs configs: [[#h:a196812e-1644-4536-84ba-687366867def][Notmuch (mail indexer and mail user agent (MUA))]].

#+include: ../../notmuch/.notmuch-config src conf :tangle no

**** notmuch post-new rules
:PROPERTIES:
:CUSTOM_ID: h:70d60d41-cb63-4950-bbd9-9157c4d186dc
:END:

And here are the rules that apply after running =notmuch new=.  Its file
system path is =$maildir/.notmuch/hooks/post-new= where =$maildir= is the
database path specified in =.notmuch-config= (see [[#h:79803e19-1150-49a6-a3df-1cffe3d0cbc5][.notmuch-config]]).
Remember that this file needs to be an executable.

The Emacs configs: [[#h:a196812e-1644-4536-84ba-687366867def][Notmuch (mail indexer and mail user agent (MUA))]].

#+include: ../../notmuch/.mail/.notmuch/hooks/post-new src conf :tangle no

**** Org+Notmuch integration (ol-notmuch.el)
:PROPERTIES:
:CUSTOM_ID: h:a7580136-cf32-44e8-81f6-590dbdd7f8f9
:END:

The =ol-notmuch.el= is part of the =org-contrib= package which can be found
in the NonGNU ELPA (that archive is configured out-of-the-box for
Emacs28, same as with GNU ELPA).  However, that package contains
approximately one zillion things I do not need, so I prefer to copy the
file here and handle it on its own.

#+begin_src emacs-lisp
;;; ol-notmuch.el --- Links to notmuch messages

;; Copyright (C) 2010-2014  Matthieu Lemerre

;; Author: Matthieu Lemerre <racin@free.fr>
;; Keywords: outlines, hypermedia, calendar, wp
;; Homepage: https://orgmode.org

;; This file is not part of GNU Emacs.

;; This file is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; This file implements links to notmuch messages and "searches". A
;; search is a query to be performed by notmuch; it is the equivalent
;; to folders in other mail clients. Similarly, mails are referred to
;; by a query, so both a link can refer to several mails.

;; Links have one the following form
;; notmuch:<search terms>
;; notmuch-search:<search terms>.

;; The first form open the queries in notmuch-show mode, whereas the
;; second link open it in notmuch-search mode. Note that queries are
;; performed at the time the link is opened, and the result may be
;; different from when the link was stored.

;;; Code:

(require 'ol)

;; customisable notmuch open functions
(defcustom org-notmuch-open-function
  'org-notmuch-follow-link
  "Function used to follow notmuch links.

Should accept a notmuch search string as the sole argument."
  :group 'org-notmuch
  :version "24.4"
  :package-version '(Org . "8.0")
  :type 'function)

(defcustom org-notmuch-search-open-function
  'org-notmuch-search-follow-link
  "Function used to follow notmuch-search links.
Should accept a notmuch search string as the sole argument."
  :group 'org-notmuch
  :version "24.4"
  :package-version '(Org . "8.0")
  :type 'function)

(make-obsolete-variable 'org-notmuch-search-open-function nil "9.3")



;; Install the link type
(org-link-set-parameters "notmuch"
			 :follow #'org-notmuch-open
			 :store #'org-notmuch-store-link)

(defun org-notmuch-store-link ()
  "Store a link to a notmuch search or message."
  (when (memq major-mode '(notmuch-show-mode notmuch-tree-mode))
    (let* ((message-id (notmuch-show-get-message-id t))
	   (subject (notmuch-show-get-subject))
	   (to (notmuch-show-get-to))
	   (from (notmuch-show-get-from))
	   (date (org-trim (notmuch-show-get-date)))
	   desc link)
      (org-link-store-props :type "notmuch" :from from :to to :date date
       			    :subject subject :message-id message-id)
      (setq desc (org-link-email-description))
      (setq link (concat "notmuch:id:" message-id))
      (org-link-add-props :link link :description desc)
      link)))

(defun org-notmuch-open (path _)
  "Follow a notmuch message link specified by PATH."
  (funcall org-notmuch-open-function path))

(defun org-notmuch-follow-link (search)
  "Follow a notmuch link to SEARCH.

Can link to more than one message, if so all matching messages are shown."
  (require 'notmuch)
  (notmuch-show search))



(org-link-set-parameters "notmuch-search"
			 :follow #'org-notmuch-search-open
			 :store #'org-notmuch-search-store-link)

(defun org-notmuch-search-store-link ()
  "Store a link to a notmuch search or message."
  (when (eq major-mode 'notmuch-search-mode)
    (let ((link (concat "notmuch-search:" notmuch-search-query-string))
	  (desc (concat "Notmuch search: " notmuch-search-query-string)))
      (org-link-store-props :type "notmuch-search"
			    :link link
			    :description desc)
      link)))

(defun org-notmuch-search-open (path _)
  "Follow a notmuch message link specified by PATH."
  (message "%s" path)
  (org-notmuch-search-follow-link path))

(defun org-notmuch-search-follow-link (search)
  "Follow a notmuch link by displaying SEARCH in notmuch-search mode."
  (require 'notmuch)
  (notmuch-search search))



(org-link-set-parameters "notmuch-tree"
			 :follow #'org-notmuch-tree-open
			 :store #'org-notmuch-tree-store-link)

(defun org-notmuch-tree-store-link ()
  "Store a link to a notmuch search or message."
  (when (eq major-mode 'notmuch-tree-mode)
    (let ((link (concat "notmuch-tree:" (notmuch-tree-get-query)))
	  (desc (concat "Notmuch tree: " (notmuch-tree-get-query))))
      (org-link-store-props :type "notmuch-tree"
			    :link link
			    :description desc)
      link)))

(defun org-notmuch-tree-open (path _)
  "Follow a notmuch message link specified by PATH."
  (message "%s" path)
  (org-notmuch-tree-follow-link path))

(defun org-notmuch-tree-follow-link (search)
  "Follow a notmuch link by displaying SEARCH in notmuch-tree mode."
  (require 'notmuch)
  (notmuch-tree search))

(provide 'ol-notmuch)

;;; ol-notmuch.el ends here
#+end_src

And now make the thing work:

#+begin_src emacs-lisp
(require 'ol-notmuch)
#+end_src

*** Sending email (SMTP)
:PROPERTIES:
:CUSTOM_ID: h:2d793cf8-83f5-4830-b73d-78385d9b96dd
:END:

These are the base settings for the SMTP functionality.  Passwords and
other critical information are stored in =~/.authinfo.gpg=, as
demonstrated in [[#h:a82766be-daab-4925-b23a-1c5ffd47e599][the base email settings]].  What follows is just a
mirroring of the contents of that file.

#+begin_src emacs-lisp
;;; Sending email (SMTP)
(prot-emacs-builtin-package 'smtpmail
  (setq smtpmail-default-smtp-server "mail.gandi.net")
  (setq smtpmail-smtp-server "mail.gandi.net")
  (setq smtpmail-stream-type 'ssl)
  (setq smtpmail-smtp-service 465)
  (setq smtpmail-queue-mail nil))

(prot-emacs-builtin-package 'sendmail
  (setq send-mail-function 'smtpmail-send-it))
#+end_src

*** EBDB (mail contacts)
:PROPERTIES:
:CUSTOM_ID: h:d386e14b-dcf7-46a2-851f-867cd84c6cae
:END:

EBDB is a contacts' manager by Eric Abrahamsen that integrates with Mail
User Agents inside of Emacs.  I used to use it as part of my Gnus setup
but as of 2021-05-13 my plan is to make it work with Notmuch as I have
switched to it ([[#h:a196812e-1644-4536-84ba-687366867def][Notmuch (mail indexer and mail user agent (MUA))]]).

What I need from it is to perform the task of storing every address that
I exchange messages with.  When I send someone a message, their email
should be saved automatically.  While if I merely read an item, say, on
the emacs-devel mailing list, I prefer to only update existing records
else do nothing.

One could set everything to automatically update in all contexts, though
I find that such an approach will either create too many false positives
that will distract you from the immediate task of handling your
correspondence, or they will simply contribute to the creation of a
database that contains a lot of largely useless information.  Save only
what matters---ignore the rest.

While "ignore the rest" can mean to simply pass it over in silence, EBBD
actually provides a mechanism to permanently exclude individual
addresses or domain names from ever being recorded.  Those are stored in
the file specified by the variable =ebdb-permanent-ignores-file=: you can
edit it manually, adding one address per line with no attached name or
angled brackets, or a domain name that starts with the =@= sign.  No
regexp notation is accepted.  For example:

#+begin_example
@debbugs.gnu.org
help-debbugs@gnu.org
@reply.github.com
#+end_example

EBDB binds some common commands to the semicolon (=;=) prefix key inside
Gnus' summary and article buffers.  For example, =; := will update all
records that are found in the message at point, while =; s= will scan
(called "snarf") the body of the message for names and email addresses
in an attempt to create records of any findings.  As always, append =C-h=
to the prefix key to get help about all key bindings that complete the
sequence and what commands they call.

The =ebdb-mua-pop-up= controls whether a window with relevant contact
information should be displayed automatically.  Perhaps it is good to
have some extra feedback on what we know or what has been collected thus
far, though I prefer not to see anything by default (it can still be
displayed with the various commands under the =;= prefix key).  Its
informative nature aside, this window can be used to further edit
entries.  With point over a field, type =e= to edit it or =C-k= to remove it
(I bind =D= to delete).  The latter command behaves differently when the
point is before the record's main field, typically the name, where it
will prompt to delete the whole entry altogether.  For more about that
specific major mode and its associated buffers, use =C-h m= (which invokes
=describe-mode=).

To view all of your contacts, or just those matching a pattern (or
string), use =M-x ebdb=, which will prompt for a search.  Input an empty
query if you prefer to view everything in the database.  While in the
=*EBDB*= buffer, you gain access to commands for operating on the records.
Same principle as with the aforementioned =ebdb-mua-pop-up=: =c= to create a
new entry, =e= to edit the field at point, =i= to insert a new datum to the
current record, =C-k= (or my preferred =D=) to delete...  Again, =C-h m= is
your friend.

Apart from gathering data and operating on it, EBDB can auto-complete
email addresses in the message composition buffer: hit TAB in a "To:",
"Cc:" or equivalent header and then use the completion framework's
interaction model to retrieve what you want.

Finally, note that this package is fairly comprehensive as it defines
lots of options and commands: make sure to read its official manual.

#+begin_src emacs-lisp
;;; EBDB (mail contacts)
(prot-emacs-elpa-package 'ebdb
  (require 'ebdb-message)
  (require 'ebdb-notmuch) ; FIXME 2021-05-13: does not activate the corfu-mode UI
  (setq ebdb-sources (locate-user-emacs-file "ebdb"))
  (setq ebdb-permanent-ignores-file (locate-user-emacs-file "ebdb-permanent-ignores"))

  (setq ebdb-mua-pop-up nil)
  (setq ebdb-default-window-size 0.25)
  (setq ebdb-mua-default-formatter ebdb-default-multiline-formatter)

  (setq ebdb-mua-auto-update-p 'existing)
  (setq ebdb-mua-reader-update-p 'existing)
  (setq ebdb-mua-sender-update-p 'create)
  (setq ebdb-message-auto-update-p 'create)

  (setq ebdb-message-try-all-headers t)
  (setq ebdb-message-headers
        '((sender "From" "Resent-From" "Reply-To" "Sender")
          (recipients "Resent-To" "Resent-Cc" "Resent-CC" "To" "Cc" "CC" "Bcc" "BCC")))
  (setq ebdb-message-all-addresses t)

  (setq ebdb-complete-mail 'capf)
  (setq ebdb-mail-avoid-redundancy t)
  (setq ebdb-completion-display-record nil)
  (setq ebdb-complete-mail-allow-cycling nil)

  (setq ebdb-record-self "ace719a4-61f8-4bee-a1ca-2f07e2292305")
  (setq ebdb-user-name-address-re 'self) ; match the above
  (setq ebdb-save-on-exit t)

  (with-eval-after-load 'prot-mail ; check my `prot-mail.el'
    (add-hook 'message-setup-hook #'prot-mail-ebdb-message-setup))

  (let ((map ebdb-mode-map))
    (define-key map (kbd "D") #'ebdb-delete-field-or-record)
    (define-key map (kbd "M") #'ebdb-mail) ; disables `ebdb-mail-each'
    (define-key map (kbd "m") #'ebdb-toggle-record-mark)
    (define-key map (kbd "t") #'ebdb-toggle-all-record-marks)
    (define-key map (kbd "T") #'ebdb-toggle-records-format) ; disables `ebdb-toggle-all-records-format'
    (define-key map (kbd "U") #'ebdb-unmark-all-records)))
#+end_src

** Rcirc (IRC client)
:PROPERTIES:
:CUSTOM_ID: h:4d2f596a-6fc5-4179-a361-c29f77a5ba11
:END:

The first time I used IRC in earnest was at EmacsConf 2021.  The event
lasted two days (I also delivered [[https://emacsconf.org/2021/talks/freedom][a presentation]]).  For the first day I
tried the =erc= package that is built into Emacs, while for the second I
opted for =rcirc=, another built-in option.

Overall, Rcirc feels more straightforward to me as a regular user.
Whereas ERC seems to have too many options and a larger code base for
technicalities I do not need to know about for the purposes of my casual
usage of IRC.

To get started, run =M-x irc= and confirm your choice at the prompts.  The
defaults for the server and the connection port should be fine.  In my
case, those steps are skipped because of the values specified in the
=rcirc-server-alist=.  Note the presence of =prot-mail-auth-get-field=.
This is a function that queries my =~/.authinfo.gpg= file to retrieve
encrypted information stored there (see [[#h:8d0bd754-8a31-431b-b112-f541cc0144ac][Sample of authinfo.gpg]]).  I use
this method to (i) automate the process of logging in while (ii) not
divulging sensitive data (also see the mega-section on [[#h:5ad80664-3163-4d9d-be65-462637d77903][Email settings]]).

IRC is fairly easy to use: you just type your message at the command
prompt and everyone in the channel can see it.  Some things I learnt:

+ Join a channel like =#emacs= by typing at the prompt =/join #emacs=.
+ Leave a channel with =/leave #vim= 😉.
+ To quit IRC do =/quit=, or optionally =/quit Going for a brisk walk=.
+ You can mention another user in the channel just by including their
  nick in your message, like =Hello protesilaos=.  When replying to
  someone, do it like this =protesilaos: My reply here=.
+ Start a private channel with, say, =protesilaos= by running the command
  =/msg protesilaos My message here=.  Then use the channel like any
  other.

There probably are more commands and other tricks we can employ.  I
expect to familiarise myself with them over time.

The following configuration is straightforward and the doc string of
every variable is clear on what it is supposed to do.

#+begin_src emacs-lisp
(prot-emacs-builtin-package 'rcirc
  (setq rcirc-server-alist
        `(("irc.libera.chat"
           :channels ("#emacs" "#org-mode" "#rcirc")
           :port 6697 :encryption tls
           :password ,(prot-mail-auth-get-field "libera" :secret))))

  (setq rcirc-prompt "%t> ") ; Read the docs or use (customize-set-variable 'rcirc-prompt "%t> ")

  (setq rcirc-default-nick "protesilaos"
        rcirc-default-user-name rcirc-default-nick
        rcirc-default-full-name "Protesilaos Stavrou")

  ;; ;; NOTE 2021-11-28: demo from the days of EmacsConf 2021.  I don't
  ;; ;; actually need this.
  ;; (setq rcirc-bright-nicks '("bandali" "sachac" "zaeph"))

  ;; NOTE 2021-11-28: Is there a canonical way to disable this?
  (setq rcirc-timeout-seconds most-positive-fixnum)

  (rcirc-track-minor-mode 1)

  (define-key global-map (kbd "C-c i") #'irc))
#+end_src

** Bongo music or media manager (and prot-bongo.el)
:PROPERTIES:
:CUSTOM_ID: h:758afe0d-bc7c-4afc-9c6b-b5e569901591
:END:

Bongo is a buffer oriented media manager.  It provides an interface to
external players, such as VLC or MPV.  Those are known as "back-ends"
(=prot-bongo-enabled-backends= sets up my preferred ones).  A "library"
buffer contains the media collection, which consists of music or video
files, or even links to online streams.  While a "playlist" buffer holds
the items that wait in the queue to be played by the back-end program.
We normally use the Library to browse our multimedia collection and to
pick the items we wish to add to the playlist.  In my case, the Library
is just a Dired buffer, so I also benefit from everything this powerful
tool provides (for configurations and commentary, check [[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][Dired (directory
editor, file manager)]]).

I mostly use Bongo for my local Music collection, but also as an
interface to the various video or audio streams I access via their RSS
feed (the latter is done through the integration with Elfeed---as such,
consult [[#h:0cd8ddab-55d1-40df-b3db-1234850792ba][Elfeed feed reader, prot-elfeed.el and prot-elfeed-bongo.el]]).

My music directories inside =~/Music= are, in principle, organised in file
system paths that follow the pattern =Artist/Album/Tracks=.  Each track
inside of them is named in the style of =Artist - Album - Title=.  As part
of this collection comes from physical discs, I never bothered writing
metadata for all them and, consequently, do not rely on it to either
play back or organise my files.  The directory structure and its
concomitant naming conventions are sufficient and, in my opinion, more
precise and easier to predict.  My methodology aside, Bongo will read
the media's file name and interpret each hyphen as a field delimiter
that it can then use to better present the information in the playlist
queue.

I prefer this manual approach to organising my music collection over all
metadata-centric alternatives.  Reading metadata requires more than just
looking at a plain text name: it is opaque or at least not immediately
obvious.  Besides, how many times have you bought an album that has one
track with a guest author and that one track gets auto-filtered in some
random place because of its unique meta datum for the "artist" field?
So you need to supply a track "artist", then an "album artist" to avoid
the pains of unpredictability...  This is the kind of busy work I want
to eschew by organising my files in a way that I understand intuitively.
As for whether Bongo can handle metadata, I do not know.

My way of listening to music is straightforward: load up a directory or
directory tree, randomise the playback order, and let it play in the
background.  To ease this workflow, I make my =~/Music= directory a valid
Bongo library.  As already noted in the introduction, this practically
means that I can access it with =dired=, while still benefiting from the
Bongo-specific extensions (the technical implementation is handled by my
comprehensive =prot-bongo.el= library, which is produced after the
following package configurations).

Two main uses of the Dired+Bongo combination:

+ Enqueue items for immediate playback :: Mark some directories or files
  the way you always do with Dired, and hit a key to insert them to the
  Bongo playlist (the command is =prot-bongo-dired-insert=).  This will do
  a number of things, specifically, (i) enqueue those Dired marks to the
  playlist buffer, (ii) perform playback randomisation where
  appropriate, (iii) mark this inserted group by bespoke section
  delimiters for easier future retrieval, and (iv) start playing an item
  unless one is already playing.  When there are no marked items in the
  Dired buffer, the file/directory at point will be used instead.

+ Add items to plain playlist files :: Add the absolute filesystem path
  of marked items (typically directories) to either an existing /playlist
  file/ or a new one that is created on demand.  This is done using
  minibuffer completion (check =prot-bongo-dired-make-playlist-file=).
  Those files can at any time be inserted in a Bongo /playlist buffer/ to
  start playing their contents, following the same conditional patterns
  of behaviour described in the previous point (see, in particular,
  =prot-bongo-playlist-insert-playlist-file=).  Put simply, you have a
  "rock" /playlist file/ that includes file paths to "~/Music/Scorpions"
  and "~/Music/Queen", so inserting that file plays all songs that are
  found in those two directories (files are found recursively, so don't
  worry if you have multiple albums inside each directory).

Now a few words about my custom delimiters that the likes of
=prot-bongo-dired-insert= will add to the Bongo playlist buffer:

+ The "section delimiters" (=prot-bongo-playlist-section-delimiter=)
  demarcate sets of inserted media.  For example, if you mark three
  items in Dired and proceed to enqueue them, then the section delimiter
  goes after those three.  Such delimiters provide visual feedback, but
  can also be used to either navigate between them and/or remove all of
  their contents in one go (with =prot-bongo-playlist-kill-section=).

+ Then there is my concept of "headings" that complements those section
  delimiters (=prot-bongo-playlist-heading-delimiter=).  Headings are
  comments in the Bongo playlist buffer that contain the name of the
  directory or file that includes the tracks directly below them.  Other
  than being informative, they function as anchors for navigation
  (e.g. with =prot-bongo-playlist-heading-next=), while they double as
  pointers in an =M-x imenu= index (by virtue of =prot-bongo-imenu-setup=).
  So we can use key bindings to go to the next or previous heading or
  employ minibuffer completion to jump directly to the heading of
  interest.  The beauty of this is that we can then use the built-in
  Imenu, or some of its third-party extensions, to navigate to a heading
  using minibuffer completion.  For more on the latter, refer to the
  mega-section on [[#h:98d3abcc-f34e-4029-aabc-740f0b6421f8][Completion framework and extras]].  It covers everything
  about the minibuffer, Consult, Embark, and more.

For the video demo of some of the aforementioned, you may want to watch
the recording on [[https://protesilaos.com/codelog/2020-08-06-emacs-bongo-extras/][Bongo media manager and my extras]] (2020-08-06).  Though
note that it showcases code that is considerably older than what I
currently have with =prot-bongo.el= (as of 2021-01-18).

By default, all the Bongo buffers have a prominent header that provides
some basic information about the program.  As I have no use for that, I
run the function =prot-bongo-remove-headers=: it takes care of clearing
the buffers while setting them up.  The idea for this is derived from
the [[https://github.com/Koekelas/dotfiles/blob/master/emacs.org][Emacs configuration file of Nicolas De Jaeghere]].

Finally, note that I combine Bongo with Elfeed to keep track of video or
audio streams that I follow.  The code, shared as =prot-elfeed-bongo.el=,
is included in the section on [[#h:0cd8ddab-55d1-40df-b3db-1234850792ba][Elfeed (RSS/Atom feed reader)]].  Thanks to
Madhavan Krishnan who helped me flesh out this project by sharing code
and ideas in a private exchange (disclosed with permission).

Also watch: [[https://protesilaos.com/codelog/2020-09-11-emacs-elfeed-bongo/][Manage podcasts in Emacs with Elfeed and Bongo]] (2020-09-11),
though please bear in my that my current code is not exactly what was
demonstrated back then (as of 2021-01-18).

#+begin_src emacs-lisp
;;; Bongo music or media manager (and prot-bongo.el)
(prot-emacs-elpa-package 'bongo
  (setq bongo-default-directory "~/Music/")
  (setq bongo-prefer-library-buffers nil)
  (setq bongo-insert-whole-directory-trees t)
  (setq bongo-logo nil)
  (setq bongo-display-track-icons nil)
  (setq bongo-display-track-lengths nil)
  (setq bongo-display-header-icons nil)
  (setq bongo-display-playback-mode-indicator t)
  (setq bongo-display-inline-playback-progress nil) ; t slows down the playlist buffer
  (setq bongo-join-inserted-tracks nil)
  (setq bongo-field-separator (propertize " · " 'face 'shadow))
  (setq bongo-mark-played-tracks t)
  (setq bongo-vlc-program-name "cvlc")
  (bongo-mode-line-indicator-mode -1)
  (bongo-header-line-mode -1)
  (let ((map global-map))
    (define-key map (kbd "C-c b") #'bongo)
    (define-key map (kbd "<C-XF86AudioPlay>") #'bongo-pause/resume)
    (define-key map (kbd "<C-XF86AudioNext>") #'bongo-next)
    (define-key map (kbd "<C-XF86AudioPrev>") #'bongo-previous)
    (define-key map (kbd "<C-M-XF86AudioPlay>") #'bongo-play-random)
    (define-key map (kbd "<M-XF86AudioPlay>") #'bongo-show)
    (define-key map (kbd "<S-XF86AudioNext>") #'bongo-seek-forward-10)
    (define-key map (kbd "<S-XF86AudioPrev>") #'bongo-seek-backward-10)
    ;; Same as above for the pgtk build of Emacs 29.
    (define-key map (kbd "C-<269025044>") #'bongo-pause/resume)
    (define-key map (kbd "C-<269025047>") #'bongo-next)
    (define-key map (kbd "C-<269025046>") #'bongo-previous)
    (define-key map (kbd "C-M-<269025044>") #'bongo-play-random)
    (define-key map (kbd "M-<269025044>") #'bongo-show)
    (define-key map (kbd "S-<269025047>") #'bongo-seek-forward-10)
    (define-key map (kbd "S-<269025046>") #'bongo-seek-backward-10))
  (let ((map bongo-playlist-mode-map))
    (define-key map (kbd "n") #'bongo-next-object)
    (define-key map (kbd "p") #'bongo-previous-object)
    (define-key map (kbd "R") #'bongo-rename-line)
    (define-key map (kbd "j") #'bongo-dired-line)       ; Jump to dir of file at point
    (define-key map (kbd "J") #'dired-jump)             ; Jump to library buffer
    (define-key map (kbd "I") #'bongo-insert-special)))

(with-eval-after-load 'bongo
  (prot-emacs-builtin-package 'prot-bongo
    (setq prot-bongo-enabled-backends '(mpv vlc))
    (setq prot-bongo-playlist-section-delimiter (make-string 30 ?*))
    (setq prot-bongo-playlist-heading-delimiter "§")
    (setq prot-bongo-playlist-directory
          (concat
           (file-name-as-directory bongo-default-directory)
           (file-name-as-directory "playlists")))
    ;; Those set up a few extras: read each function's doc string.  Pass
    ;; an argument to undo their effects.
    (prot-bongo-enabled-backends)
    (prot-bongo-remove-headers)
    (prot-bongo-imenu-setup)
    (add-hook 'dired-mode-hook #'prot-bongo-dired-library-enable)
    (add-hook 'wdired-mode-hook #'prot-bongo-dired-library-disable)
    (add-hook 'prot-bongo-playlist-change-track-hook #'prot-bongo-playlist-recenter)
    (let ((map bongo-playlist-mode-map))
      (define-key map (kbd "C-c C-n") #'prot-bongo-playlist-heading-next)
      (define-key map (kbd "C-c C-p") #'prot-bongo-playlist-heading-previous)
      (define-key map (kbd "M-n") #'prot-bongo-playlist-section-next)
      (define-key map (kbd "M-p") #'prot-bongo-playlist-section-previous)
      (define-key map (kbd "M-h") #'prot-bongo-playlist-mark-section)
      (define-key map (kbd "M-d") #'prot-bongo-playlist-kill-section)
      (define-key map (kbd "g") #'prot-bongo-playlist-reset)
      (define-key map (kbd "D") #'prot-bongo-playlist-terminate)
      (define-key map (kbd "r") #'prot-bongo-playlist-random-toggle)
      (define-key map (kbd "i") #'prot-bongo-playlist-insert-playlist-file))
    (let ((map bongo-dired-library-mode-map))
      (define-key map (kbd "<C-return>") #'prot-bongo-dired-insert)
      (define-key map (kbd "C-c SPC") #'prot-bongo-dired-insert)
      (define-key map (kbd "C-c +") #'prot-bongo-dired-make-playlist-file))))
#+end_src

Here is my =prot-bongo.el= library (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-bongo.el src emacs-lisp :tangle no

** Elfeed feed reader, prot-elfeed.el and prot-elfeed-bongo.el
:PROPERTIES:
:CUSTOM_ID: h:0cd8ddab-55d1-40df-b3db-1234850792ba
:END:

This is a standalone feed reader by Christopher Wellons that comes with
good defaults and is very well designed overall.  It treats the stream
of updates as a flat list that can be narrowed incrementally using an
efficient tagging system.

In terms of feed format specifications, i.e. Atom vs RSS, things should
just work without any kind of configuration from your side (a huge plus
compared to, say, Gnus' =nnrss= backend that only supports the latter).

Elfeed stores feed sources in a single list that associates a valid URL
to one or more tags.  These are then written to a database.  The Elisp
part users should care about looks like this:

#+begin_example
(setq elfeed-feeds
      '(("https://www.archlinux.org/feeds/news/" linux distro)
        ("https://planet.emacslife.com/atom.xml" emacs community)
        ("https://www.ecb.europa.eu/rss/press.html" economics eu)
        ("http://feed.pippa.io/public/shows/teamhuman" podcast culture)
        ("https://www.youtube.com/feeds/videos.xml?channel_id=UC0uTPqBCFIpZxlz_Lv1tk_g" personal video)
        ("https://protesilaos.com/codelog.xml" personal)))
#+end_example

I keep the actual list in a GPG-encrypted file (defined in the variable
=prot-elfeed-feeds-file= which is part of my =prot-elfeed.el= library that
is reproduced after the following package configurations).  Emacs can
transparently decrypt and read gpg-protected files, making it a great
way to safely store sensitive data while still keeping everything
perfectly functional.

A good tagging system for your feeds will offer a strong foundation for
catching up with the news.  I generally use 2-3 tags per feed, while I
make sure that conceptually similar items will share at least one tag.
My tags are not particularly sophisticated, though they are not random
either: for example, I have a particular "EU" entry for all
institutions, bodies, agencies, etc. of the European Union and then I
have other more general ones, such as "politics" and "economics".  So,
in this case, the European Central Bank gets tagged with =eu=, =economics=,
while the European Parliament is =eu=, =politics=.

The user interface consists of two distinct types of buffers:

1. The =*elfeed-search*= buffer that holds the list with all the news
   items.
2. The individual item entries.

By default, hitting =s= (=elfeed-search-live-filter=) in the search buffer
will place the point inside the minibuffer, where you can then edit the
applicable filters.  The [[https://github.com/skeeto/elfeed][Elfeed README]] offers a detailed explanation of
how to apply such filters.  The ones I use the most:

+ Prepend a =+= to the name of a tag to only show items that include that
  tag.  With =-= show items that do not include it.
+ Type in a regular string with the equals sign in front of it, say
  "=TITLE", to show feeds whose name contains it.

Other common cases are regular expressions and date ranges, though I
have found that I never use those.  Probably because the tagging system
is sufficiently powerful for my particular needs.

My only inconvenience with =elfeed-search-live-filter= is that it does not
support completion out-of-the-box.  Instead it expects full user input,
which ins understandable given the types of searches it can conduct.
Since I only need this facility to filter by tag, I rebind =s= to my
=prot-elfeed-search-tag-filter=.  While =S-s= (shift and s) can still be
used to access the original command, whenever we need more precise
control over the search filters.

The MPV-related functions require the external =mpv= program.  They will
play a video in a new app window at a resolution that matches the
current setup's display width or, in the case of an enclosure
(presumably a podcast), play just the audio file without popping up a
new app window.  The process runs in a dedicated buffer, so it can be
terminated by killing the buffer.  In the future I might make this
cleaner, so that it understands input from, e.g., =playerctl=, though it
is not a priority as the current simplistic design is "good enough" for
my case.

For an older, albeit still relevant, demonstration of what I have here,
watch [[https://protesilaos.com/codelog/2020-06-09-emacs-elfeed-demo/][my Elfeed video]] (2020-06-09).

As I also am a user of Bongo, and because Emacs lets one handle things
with precision, there are a few functions here that are meant to make
the Elfeed search buffer a bongo-aware media library, from where we can
enqueue online multimedia sources (video links, or podcast enclosures).
The key is to not interfere with the primary Bongo playlist and library
tandem, which is dedicated to my local music collection, but to maintain
a separate playlist which can be controlled independently.  The entirety
of my =prot-elfeed-bongo.el= is shared after =prot-elfeed.el= below the
following package configurations (for my other extensions, refer to
[[#h:758afe0d-bc7c-4afc-9c6b-b5e569901591][Bongo music or media manager (and prot-bongo.el)]]).

The placement of my custom buffers for Elfeed's multimedia output is
controlled by =display-buffer-alist= (see [[#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][Window rules and basic tweaks]]).

I benefited in this particular Elfeed+Bongo workflow from an email
exchange I had with Madhavan Krishnan: we shared code and ideas that
helped establish the modalities of interaction between Elfeed and Bongo
(this information is made public with permission).  Video demo with
older code: [[https://protesilaos.com/codelog/2020-09-11-emacs-elfeed-bongo/][Manage podcasts in Emacs with Elfeed and Bongo]] (2020-09-11).

Also see: [[#h:aa64c61e-49b5-41b0-b1fe-10bbe3be661f][Sample configuration for MPV (Elfeed+Bongo extension)]].

#+begin_src emacs-lisp
;;; Elfeed feed reader, prot-elfeed.el and prot-elfeed-bongo.el
(prot-emacs-elpa-package 'elfeed
  (setq elfeed-use-curl t)
  (setq elfeed-curl-max-connections 10)
  (setq elfeed-db-directory (concat user-emacs-directory "elfeed/"))
  (setq elfeed-enclosure-default-dir "~/Downloads/")
  (setq elfeed-search-filter "@4-months-ago +unread")
  (setq elfeed-sort-order 'descending)
  (setq elfeed-search-clipboard-type 'CLIPBOARD)
  (setq elfeed-search-title-max-width 100)
  (setq elfeed-search-title-min-width 30)
  (setq elfeed-search-trailing-width 25)
  (setq elfeed-show-truncate-long-urls t)
  (setq elfeed-show-unique-buffers t)
  (setq elfeed-search-date-format '("%F %R" 16 :left))

  ;; Make sure to also check the section on shr and eww for how I handle
  ;; `shr-width' there.
  (add-hook 'elfeed-show-mode-hook
            (lambda () (setq-local shr-width (current-fill-column))))

  (prot-emacs-builtin-package 'prot-elfeed-bongo)

  (define-key global-map (kbd "C-c e") #'elfeed)
  (let ((map elfeed-search-mode-map))
    (define-key map (kbd "w") #'elfeed-search-yank)
    (define-key map (kbd "g") #'elfeed-update)
    (define-key map (kbd "G") #'elfeed-search-update--force)
    (define-key map (kbd "b") #'prot-elfeed-bongo-insert-item)
    (define-key map (kbd "h") #'prot-elfeed-bongo-switch-to-playlist)) ; "hop" mnemonic
  (let ((map elfeed-show-mode-map))
    (define-key map (kbd "w") #'elfeed-show-yank)
    (define-key map (kbd "b") #'prot-elfeed-bongo-insert-item)))

(with-eval-after-load 'elfeed
  (prot-emacs-builtin-package 'prot-elfeed
    (setq prot-elfeed-tag-faces t)
    (prot-elfeed-fontify-tags)
    (add-hook 'elfeed-search-mode-hook #'prot-elfeed-load-feeds)

    (let ((map elfeed-search-mode-map))
      (define-key map (kbd "s") #'prot-elfeed-search-tag-filter)
      (define-key map (kbd "o") #'prot-elfeed-search-open-other-window)
      (define-key map (kbd "q") #'prot-elfeed-kill-buffer-close-window-dwim)
      (define-key map (kbd "v") #'prot-elfeed-mpv-dwim)
      (define-key map (kbd "+") #'prot-elfeed-toggle-tag))
    (let ((map elfeed-show-mode-map))
      (define-key map (kbd "a") #'prot-elfeed-show-archive-entry)
      (define-key map (kbd "e") #'prot-elfeed-show-eww)
      (define-key map (kbd "q") #'prot-elfeed-kill-buffer-close-window-dwim)
      (define-key map (kbd "v") #'prot-elfeed-mpv-dwim)
      (define-key map (kbd "+") #'prot-elfeed-toggle-tag))))
#+end_src

This is =prot-elfeed.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-elfeed.el src emacs-lisp :tangle no

And here is =prot-elfeed-bongo.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-elfeed-bongo.el src emacs-lisp :tangle no

*** Sample configuration for MPV (Elfeed+Bongo extension)
:PROPERTIES:
:CUSTOM_ID: h:aa64c61e-49b5-41b0-b1fe-10bbe3be661f
:END:

In the previous section I configure Elfeed to integrate with the Bongo
media manager.  The external =mpv= executable is used to play back audio
and video links.  Instead of passing command-line arguments to control
the settings of the player, I just add the following to my local
configuration files, specifically =~/.config/mpv/mpv.conf=:

#+begin_example conf
hwdec=auto-safe
ytdl-format="bestvideo[height<=?1080]+bestaudio/best"
#+end_example

** Proced (process monitor, similar to `top')
:PROPERTIES:
:CUSTOM_ID: h:6b56ce11-c84c-4b6d-98c7-bc3eefbe9325
:END:

This is a built-in tool that allows you to monitor running processes
and act on them accordingly.  These are the basic settings I have
right now: it works fine.

My =prot-proced.el= (reproduced after the package configurations) simply
adds some extra colours to the otherwise plain buffer.  Makes it easier
to keep track of the information on display.

#+begin_src emacs-lisp
;;; Proced (process monitor, similar to `top')
(prot-emacs-builtin-package 'proced
  (setq proced-auto-update-flag t)
  (setq proced-auto-update-interval 5)
  (setq proced-descend t)
  (setq proced-filter 'user))

(prot-emacs-builtin-package 'prot-proced
  (prot-proced-extra-keywords 1))
#+end_src

Here is =prot-proced.el= (from [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-proced.el src emacs-lisp :tangle no

** Pass interface (password-store)
:PROPERTIES:
:CUSTOM_ID: h:1d2bf0d0-4806-4e04-a320-7d6538ef2e78
:END:

The external =pass= program, aka "password-store", is a password manager
that uses GPG and standard UNIX tools to handle passwords.  Encrypted
files are stored in a plain directory structure.  Very simple, very
nice: now all data is available with a variety of interfaces, such as
standard CLI, a =dmenu= interface, a graphical front-end like =qtpass=, etc.

The package below provides an Emacs interface to some of the most common
actions, in the form of a list of candidates that can be narrowed down
using completion methods (study [[#h:98d3abcc-f34e-4029-aabc-740f0b6421f8][Completion framework and extras]]).  I use
it to quickly store a password to the kill ring.

#+begin_src emacs-lisp
;;; Pass interface (password-store)
(prot-emacs-elpa-package 'password-store
  (setq password-store-time-before-clipboard-restore 30)
  ;; Mnemonic is the root of the "code" word (κώδικας).  But also to add
  ;; the password to the kill-ring.  Other options are already taken.
  (define-key global-map (kbd "C-c k") #'password-store-copy))
#+end_src

And this one adds a major mode for browsing the =pass= keychain.  Call
it with =M-x pass=.  There is a helpful section at the top with key
bindings and their functions.

#+begin_src emacs-lisp
(prot-emacs-elpa-package 'pass)
#+end_src

** Simple HTML Renderer (shr), Emacs Web Wowser (eww), Elpher, and prot-eww.el
:PROPERTIES:
:CUSTOM_ID: h:524bc702-ff55-4ed9-9a38-26d30d64591d
:END:

TODO 2021-09-08: This section needs to be expanded to cover the
integration with the built-in =bookmark.el= framework as well as the
third-party =elpher= package (Elpher is an Internet browser for the Gopher
and Gemini protocols).


The following code block encompasses libraries that power Emacs' web
browsing experience.

+ =browse-url= determines what Emacs should do when the user follows a
  link to the Internet.  For my purposes, I configure it to open the web
  page inside of Emacs, while I let the Desktop Environment's default
  graphical browser be declared as a secondary option.  Put simply, when
  I click on a URL, I go to an EWW or Elpher buffer.  If the page is
  part of the World Wide Web (=https?= protocol) I can opt to open it in
  the GUI browser via =eww-browse-with-external-browser=, which is bound
  to =&= in =eww-mode-map=.  That is only ever needed for websites that do
  not work well in a text-centric interface.  For pages that implement
  the Gopher or Gemini protocols, there is no need whatsoever to open
  them externally as they are plain text anyway.

+ =shr= is the "Simple HTML Renderer", which basically means to interpret
  the underlying code of a web page and show it in the way it is
  intended for the end user.  Unlike graphical web browsers, =shr=
  capabilities are limited, because it does not use style sheets (CSS)
  and more demanding resources (javascript, embedded multimedia, etc.).

+ =eww= is what we use to browse the Web.  It effectively is the front-end
  to =shr=, adding on top of it the layer of interactivity that is
  expected of a basic browser, such as to keep a history of visited
  pages, handle bookmarks, navigate through links, and the like.  As
  always, remember to read the manual of EWW, such as by evaluating this
  form: =(info "(eww) Top")=.  It is short and should give you an idea of
  what its features are.

+ =prot-eww= adds commands that align EWW with my expectations and make it
  do what I want to achieve in a primarily text-based web browsing
  experience.  It also provides the layer of integration between EWW and
  Elpher, making the resulting browsing experience consistent as one
  follows links that are implemented in the relevant protocols.

My configurations for =browse-url= and =shr= are straightforward and are
meant to keep things simple.  I want EWW to behave like the rest of
Emacs, which means that it should not try to introduce random colours
from web pages, nor use its own fonts.  Both intefere with the
consistency I seek in my computing environment (and why I use Emacs to
begin with).

For =eww=, I repurpose some of its key bindings that I never plan to use,
such as the toggle for proportional fonts, while I move around a few
others.  Just to make things easier for me.

As for =prot-eww=, it includes functionality that makes EWW good enough
for my day-to-day needs.

In particular:

+ It includes an unconditional internal mechanism that renames EWW
  buffers based on the rendered web page's title or, when that is not
  available, the URL.  This ensures that I can maintain multiple buffers
  without getting lost in the noise of what would otherwise be an
  awkward naming scheme in the form of =*eww*=, =*eww<2>*= and so on.  Now
  it looks like =*Emacs - ArchWiki # eww*=, with a possible number
  identifier added only for duplicate entries.

+ The variable =prot-eww-visited-history= records the URL of every
  rendered page.  This is then used by =prot-eww-browse-dwim= (more
  below).  To keep things in check, =prot-eww-visited-history= is
  implemented as a minibuffer history which is ultimately limited to the
  value of =history-length= (read: [[#h:2733674b-51f9-494e-b34d-e8842ac4ef96][Minibuffer history (savehist-mode)]]).
  Remember that each command can have its own history and this is common
  in a lot of my extras.

+ The =prot-eww-browse-dwim= is my main point of entry to EWW.  When I
  call it from a random place inside of Emacs, it just offers a prompt
  that asks for a URL or search terms with which to query DuckDuckGo.
  In addition, it reads through a history of such inputs, so that =M-p=,
  =M-n= can quickly give me something I tried before.  Plus it supports
  completion (check the mega-section [[#h:98d3abcc-f34e-4029-aabc-740f0b6421f8][Completion framework and extras]]).
  When this command is called from inside an EWW buffer it retains the
  aforementioned functionality, but its prompt is pre-populated with the
  URL of the current page.  This is particularly useful for editing the
  path directly, such as to go from =https://protesilaos.com/contact= to
  =https://protesilaos.com=.  When called with a universal prefix argument
  (=C-u=), it opens a new EWW buffer instead of using the last one.

+ =prot-eww-search-engine= offers selection among the custom search
  commands I define, such as to query Wikipedia directly or search for a
  bug number in the Emacs issue tracker.  Those search engine commands
  can be invoked on their own, while each of them has its own minibuffer
  history (so if you searched for "elephant" in Wikipedia, you will not
  get that for the Arch Wiki).

+ =prot-eww-bookmark-page= does what its name suggests though, unlike the
  built-in equivalent, it first asks for how to name the bookmarked
  entry before storing it in the relevant memory compartment.

+ =prot-eww-visit-bookmark= prompts with completion to visit an entry in
  EWW's bookmark list.  A =C-u= prefix means to open it in a new EWW
  buffer.

+ =prot-eww-visit-url-on-page= traverses the entire web page to construct
  a list of all links and their anchor text.  The list can be narrowed
  with completion.  Selecting a item with visit its corresponding web
  page.

+ =prot-eww-jump-to-url-on-page= is similar to the above, with the major
  difference that it only stores buffer positions and jumps to them.
  This makes it ideal for generating an ad-hoc index of "points of
  interest" in the current buffer with the help of Embark's ability to
  collect a list of candidates into a bespoke buffer (make sure to check
  [[#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984][Extended minibuffer actions and more (embark.el and prot-embark.el)]]).
  Of course, it can be used on its own to jump around the web page.
  Upon jumping, the line will pulse momentarily to help keep a sense of
  context (also read: [[#h:6bbc41d6-da7c-4301-84c6-c5887c29283f][prot-pulse.el (highlight cursor position)]]).

+ =prot-eww-find-feed= inspects the source code of the current web page
  and produces an =occur= buffer with links that represent RSS or Atom
  feeds.  This command is quite useful for retrieving the feed of a
  website whose designers failed to provide a user-facing link for it
  (which is the norm nowadays).  I read feeds on a daily basis: it is
  the best way to keep track of updates to web pages (read section
  [[#h:0cd8ddab-55d1-40df-b3db-1234850792ba][Elfeed feed reader, prot-elfeed.el and prot-elfeed-bongo.el]]).

+ =prot-eww-readable= is a more opinionated take on the built-in option.
  It specifies a narrower =shr-width=, specifically at the 72 character
  limit which is my =current-fill-column=.  Furthermore, it reduces images
  to a maximum of 0.35 of the window's width/height.  This is not always
  a good approach, though it works most of the time for the kind of
  content I am interested in: text-heavy articles.

+ =prot-eww-download-html= downloads the current web page as an =.html=
  file.  It asks for a name to give to it, defaulting to the title of
  the page, and it also prepends the current date and time.  To ensure
  that the file name is easily accessible with Unix tools, all
  punctuation marks and spaces are removed or replaced with hyphens.  So
  if the page is titled ="GNU Emacs manual | My ‘cool’ “website”!?"= the
  saved file will be processed and stored as a filesystem path like
  =~/Downloads/eww/20210324_185035--gnu-emacs-manual-my-cool-website.html=.
  I find that this is superior to the generic =eww-download= which neither
  asks for a name, nor adds a date and file type extension.  Where
  =eww-download= still excels is for downloading the link at point, when
  that is not an HTML file (e.g. a pdf or zip archive).

+ =prot-eww-open-in-other-window= is meant to open the link at point in a
  new buffer and in another window.  It complements the default =M-RET=
  (=eww-open-in-new-buffer=) which re-uses the same window.

Some final tips:

+ =g= reloads the web page by fetching it anew over the network, while its
  =C-u g= counterpart re-renders what has already been downloaded.  The
  latter is useful when, for example, you have a new window
  configuration and wish to fit the EWW buffer's contents in the window.

+ As already noted above, several commands that open an EWW buffer
  accept a =C-u= prefix to put their contents in a new buffer rather than
  re-use the existing one.  With =M-RET= over a link in an EWW buffer, you
  can do the same.

+ When point is over an image, the =shr-image-map= gets activated.  This
  allows you to run commands such as =image-increase-size=, bound to =+=,
  and =image-decrease-size= on =-=.  This means that you can always view an
  image at an appropriate size, regardless of whether its initial
  dimensions were affected by =shr-max-image-proportion= and the size of
  the window holding the EWW buffer.

Also watch [[https://protesilaos.com/codelog/2021-03-25-emacs-eww/][EWW and my extras]] (2021-03-25) for a video demonstration of
some of the above.

#+begin_src emacs-lisp
;;; Simple HTML Renderer (shr), Emacs Web Wowser (eww), Elpher, and prot-eww.el
(prot-emacs-builtin-package 'browse-url
  (setq browse-url-browser-function 'eww-browse-url)
  (setq browse-url-secondary-browser-function 'browse-url-default-browser))

(prot-emacs-builtin-package 'shr
  (setq shr-use-colors nil)             ; t is bad for accessibility
  (setq shr-use-fonts nil)              ; t is not for me
  (setq shr-max-image-proportion 0.6)
  (setq shr-image-animate nil)          ; No GIFs, thank you!
  (setq shr-width nil)                  ; check `prot-eww-readable'
  (setq shr-discard-aria-hidden t)
  (setq shr-cookie-policy nil))

(prot-emacs-builtin-package 'url-cookie
  (setq url-cookie-untrusted-urls '(".*")))

(prot-emacs-builtin-package 'eww
  (setq eww-restore-desktop t)
  (setq eww-desktop-remove-duplicates t)
  (setq eww-header-line-format nil)
  (setq eww-search-prefix "https://duckduckgo.com/html/?q=")
  (setq eww-download-directory (expand-file-name "~/Documents/eww-downloads"))
  (setq eww-suggest-uris
        '(eww-links-at-point
          thing-at-point-url-at-point))
  (setq eww-bookmarks-directory (locate-user-emacs-file "eww-bookmarks/"))
  (setq eww-history-limit 150)
  (setq eww-use-external-browser-for-content-type
        "\\`\\(video/\\|audio\\)") ; On GNU/Linux check your mimeapps.list
  (setq eww-browse-url-new-window-is-tab nil)
  (setq eww-form-checkbox-selected-symbol "[X]")
  (setq eww-form-checkbox-symbol "[ ]")
  ;; NOTE `eww-retrieve-command' is for Emacs28.  I tried the following
  ;; two values.  The first would not render properly some plain text
  ;; pages, such as by messing up the spacing between paragraphs.  The
  ;; second is more reliable but feels slower.  So I just use the
  ;; default (nil), though I find wget to be a bit faster.  In that case
  ;; one could live with the occasional errors by using `eww-download'
  ;; on the offending page, but I prefer consistency.
  ;;
  ;; '("wget" "--quiet" "--output-document=-")
  ;; '("chromium" "--headless" "--dump-dom")
  (setq eww-retrieve-command nil)

  (define-key eww-link-keymap (kbd "v") nil) ; stop overriding `eww-view-source'
  (define-key eww-mode-map (kbd "L") #'eww-list-bookmarks)
  (define-key dired-mode-map (kbd "E") #'eww-open-file) ; to render local HTML files
  (define-key eww-buffers-mode-map (kbd "d") #'eww-bookmark-kill)   ; it actually deletes
  (define-key eww-bookmark-mode-map (kbd "d") #'eww-bookmark-kill)) ; same

(prot-emacs-elpa-package 'elpher)    ; NOTE 2021-07-24: work-in-progress

(prot-emacs-builtin-package 'prot-eww
  (setq prot-eww-save-history-file
        (locate-user-emacs-file "prot-eww-visited-history"))
  (setq prot-eww-save-visited-history t)
  (setq prot-eww-bookmark-link nil)

  (add-hook 'prot-eww-history-mode-hook #'hl-line-mode)

  (define-prefix-command 'prot-eww-map)
  (define-key global-map (kbd "C-c w") 'prot-eww-map)
  (let ((map prot-eww-map))
    (define-key map (kbd "b") #'prot-eww-visit-bookmark)
    (define-key map (kbd "e") #'prot-eww-browse-dwim)
    (define-key map (kbd "s") #'prot-eww-search-engine))
  (let ((map eww-mode-map))
    (define-key map (kbd "B") #'prot-eww-bookmark-page)
    (define-key map (kbd "D") #'prot-eww-download-html)
    (define-key map (kbd "F") #'prot-eww-find-feed)
    (define-key map (kbd "H") #'prot-eww-list-history)
    (define-key map (kbd "b") #'prot-eww-visit-bookmark)
    (define-key map (kbd "e") #'prot-eww-browse-dwim)
    (define-key map (kbd "o") #'prot-eww-open-in-other-window)
    (define-key map (kbd "E") #'prot-eww-visit-url-on-page)
    (define-key map (kbd "J") #'prot-eww-jump-to-url-on-page)
    (define-key map (kbd "R") #'prot-eww-readable)
    (define-key map (kbd "Q") #'prot-eww-quit)))
#+end_src

And here is =prot-eww.el= in its entirety.  It is available as a file in
[[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]] (same for all my Emacs libraries):

#+include: prot-lisp/prot-eww.el src emacs-lisp :tangle no

** Extensions for PDFs (pdf-tools)
:PROPERTIES:
:CUSTOM_ID: h:02894c1d-a739-48e7-9116-3c27a6505485
:END:

The =pdf-tools= package builds on top of the external libraries, =poppler=
and =imagemagick= (if Emacs is compiled with support for it) to deliver a
series of minor modes for reading and interacting with PDF files from
inside of Emacs.  As it depends on those external files, it requires
extra steps to make it work properly.  Those are documented at length in
its README and vary depending on your operating system.

All you need to start reading PDFs is to put the =pdf-loader-install=
function in your configurations, which loads the tools once you open an
appropriate file, such as through =dired= or with =find-file=.  Once inside
the resulting buffer, do =C-h m= (=describe-mode=) to learn about the key
bindings and the commands they call.  The basics:

| Key   | Effect            |
|-------+-------------------|
| +     | Enlarge (zoom in) |
| -     | Shrink (zoom out) |
| 0     | Reset zoom        |
| C-n   | Next line         |
| C-p   | Previous line     |
| SPC   | Scroll down       |
| S-SPC | Scroll up         |

To determine which minor modes out of the entire suite are activated,
you need to configure the variable =pdf-tools-enabled-modes=.  I reduce it
only a subset of what is available by default because I do not need all
the extras.  That granted, there are at least two minor modes that users
may find helpful: =pdf-annot-minor-mode= which provides annotation
capabilities and =pdf-sync-minor-mode= which syncs the PDF with its
corresponding TeX file when you are running some setup that compiles the
latter to the former.

The value proposition of =pdf-tools= is that it works with =isearch= and
=occur= so you can easily (i) search through the file and (ii) produce a
buffer of locations with matching queries.  As is the norm with
=pdf-tools=, those facilities are implemented as minor modes:
=pdf-isearch-minor-mode=, =pdf-occur-global-minor-mode= (this also works
with =ibuffer= and =dired=).

Another helpful integration is with Emacs' =outline-mode= and =imenu= by
means of =pdf-outline-minor-mode=.  Simply hit =o= while viewing a PDF to
produce an outline of the document and then, optionally, =M-x imenu= to
navigate it using minibuffer completion (though for the latter task you
may prefer something like =consult-outline=, which is part of the Consult
package: [[#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb][Enhanced minibuffer commands (consult.el and prot-consult.el)]]).

Finally, I have some tweaks to change the backdrop of the buffer so that
it is distinct from the page's background while using my light Modus
Operandi theme ([[#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6][Modus themes (my highly accessible themes)]]).  Plus, I
make it automatically adapt to the =modus-themes-toggle= command, so that
the PDF switches to a dark theme when it has to.  Those are documented
in the manual of the themes.  If you are using them, evaluate this form:
=(info "(modus-themes) Backdrop for pdf-tools (DIY)")=.

#+begin_src emacs-lisp
;;; Extensions for PDFs (pdf-tools)
(prot-emacs-elpa-package 'pdf-tools
  (setq pdf-tools-enabled-modes         ; simplified from the defaults
        '(pdf-history-minor-mode
          pdf-isearch-minor-mode
          pdf-links-minor-mode
          pdf-outline-minor-mode
          pdf-misc-size-indication-minor-mode
          pdf-occur-global-minor-mode))
  (setq pdf-view-display-size 'fit-height)
  (setq pdf-view-continuous t)
  (setq pdf-view-use-dedicated-register nil)
  (setq pdf-view-max-image-width 1080)
  (setq pdf-outline-imenu-use-flat-menus t)

  (pdf-loader-install)

  ;; Those functions and hooks are adapted from the manual of my
  ;; modus-themes.  The idea is to (i) add a backdrop that is distinct
  ;; from the background of the PDF's page and (ii) make pdf-tools adapt
  ;; to theme switching via, e.g., `modus-themes-toggle'.
  (defun prot/pdf-tools-backdrop ()
    (face-remap-add-relative
     'default
     `(:background ,(modus-themes-color 'bg-alt))))

  (defun prot/pdf-tools-midnight-mode-toggle ()
    (when (derived-mode-p 'pdf-view-mode)
      (if (eq (car custom-enabled-themes) 'modus-vivendi)
          (pdf-view-midnight-minor-mode 1)
        (pdf-view-midnight-minor-mode -1))
      (prot/pdf-tools-backdrop)))

  (add-hook 'pdf-tools-enabled-hook #'prot/pdf-tools-midnight-mode-toggle)
  (add-hook 'modus-themes-after-load-theme-hook #'prot/pdf-tools-midnight-mode-toggle))
#+end_src

* General interface and interactions
:PROPERTIES:
:CUSTOM_ID: h:b6bd2eea-8269-4029-b446-ee340c12ebc3
:END:

This section contains configurations for all aspects of the Emacs user
interface, as well lots of small or self-contained tweaks that cover a
wide range of built-in libraries.

** Go to last change
:PROPERTIES:
:CUSTOM_ID: h:ac889a76-1092-449e-a184-9092093f3103
:END:

I could not find any built-in method of /reliably/ moving back to the
last change.  Using the mark ring is always an option, but does not fill
the exact same niche.

The =C-z= binding is [[#h:ae48fe61-a3c3-4132-8986-785f9bfbeafb][disabled elsewhere in this document]].  It minimises
the Emacs GUI by default.  A complete waste of an extremely valuable key
binding!

#+begin_src emacs-lisp
;;; Go to last change
(prot-emacs-elpa-package 'goto-last-change
  (define-key global-map (kbd "C-z") #'goto-last-change))
#+end_src

** Mode line
:PROPERTIES:
:CUSTOM_ID: h:39f57b0d-300a-4310-9ba8-8c388fa72e1d
:END:

The mode line is an integral part of the Emacs interface.  While there
are lots of third party packages that style it in a variety of ways, I
find the default to be "good enough".

In the code snippet right below I reshuffle some of the mode line
indicators.  Nothing too fancy.  The =mode-line-defining-kbd-macro= is
tweaked to use a more appropriate string for its indicator and to apply
colours that are designed specifically for the mode line (the default
uses the generic font-lock warning face).

Note that in [[#h:77d14350-978d-4820-ab7f-4641706c445a][Custom extensions for "focus mode" (prot-logos.el)]] I
provide a snippet that optionally toggles the visibility of the modeline
while entering a bespoke "focus mode" for writing/reading.

#+begin_src emacs-lisp
;;; Mode line
(setq mode-line-percent-position '(-3 "%p"))
(setq mode-line-position-column-line-format '(" %l,%c")) ; Emacs 28
(setq mode-line-defining-kbd-macro
      (propertize " Macro" 'face 'mode-line-emphasis))

;; Thanks to Daniel Mendler for this!  It removes the square brackets
;; that denote recursive edits in the modeline.  I do not need them
;; because I am using Daniel's `recursion-indicator':
;; <https://github.com/minad/recursion-indicator>.
(setq-default mode-line-modes
              (seq-filter (lambda (s)
                            (not (and (stringp s)
                                      (string-match-p
                                       "^\\(%\\[\\|%\\]\\)$" s))))
                          mode-line-modes))

(setq mode-line-compact nil)            ; Emacs 28
(setq-default mode-line-format
              '("%e"
                mode-line-front-space
                mode-line-mule-info
                mode-line-client
                mode-line-modified
                mode-line-remote
                mode-line-frame-identification
                mode-line-buffer-identification
                "  "
                mode-line-position
                mode-line-modes
                "  "
                (vc-mode vc-mode)
                "  "
                mode-line-misc-info
                mode-line-end-spaces))
#+end_src

In the following sub-sections I provide customisations for some tools
that place information on the mode line.  Again, nothing flamboyant.

*** Moody.el (simple mode line configuration utility)
:PROPERTIES:
:CUSTOM_ID: h:c07b9dfc-14a2-41a6-9310-53539dec8684
:END:

=moody.el= is a lightweight library that adds some flair to the mode line
without complicating things.  It is developed by Jonas Bernoulli.  I
have been using it on and off to make sure that it works well with my
themes (see [[#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6][Modus themes (my highly accessible themes)]]).

My fairly minor tweaks in =prot-moody.el= (reproduced further below) align
Moody with my [[#h:e03b6415-a18f-4058-b9b0-5721d38c6c50][Font configurations (prot-fonts.el)]].  What I basically
want is to make the mode line gracefully adapt to changes in font size.

#+begin_src emacs-lisp
;;; Moody.el (simple mode line configuration utility)
(prot-emacs-elpa-package 'moody)

(prot-emacs-builtin-package 'prot-moody
  ;; Adjust this and then evaluate `prot-moody-set-height'.  Not all
  ;; fonts work equally well with the same value.
  (setq prot-moody-font-height-multiplier 1.35)

  ;; Also check the Modus themes' `modus-themes-mode-line' which can set
  ;; the styles specifically for Moody.
  (prot-moody-set-height -1))
#+end_src

Here are my tweaks (from [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-moody.el src emacs-lisp :tangle no

*** Hide modeline "lighters" (minions.el)
:PROPERTIES:
:CUSTOM_ID: h:b31005e3-c475-4be9-87fd-85b404550d8c
:END:

This package by Jonas Bernoulli neatly wraps up all minor mode
"lighters" and hides them behind a single character.  The "lighter" is
the text that identifies the minor mode on the mode line.  Having a
few of them is usually okay, but a lot of them do not scale well.

#+begin_src emacs-lisp
;;; Hide modeline "lighters" (minions.el)
(prot-emacs-elpa-package 'minions
  (setq minions-mode-line-lighter ";")
  ;; NOTE: This will be expanded whenever I find a mode that should not
  ;; be hidden
  (setq minions-prominent-modes
        (list 'defining-kbd-macro
              'flymake-mode
              'prot-simple-monocle))
  (minions-mode 1))
#+end_src

*** Mode line recursion indicators
:PROPERTIES:
:CUSTOM_ID: h:bb707bec-bcaf-44d0-bb82-1ed6bb0cb33b
:END:

This utility by Daniel Mendler provides a couple of indicators for
denoting minibuffer recursion.  They offer a reminder that we are in the
midst of a recursive editing session when we should, perhaps, not be in
one.  I consider =recursion-indicator= complementary to what is already
built into Emacs in the form of =minibuffer-depth-indicate-mode= which
shows the level of recursion at the current minibuffer prompt (refer to
[[#h:c110e399-3f43-4555-8427-b1afe44c0779][Minibuffer configurations and my extras (mct.el)]]).

#+begin_src emacs-lisp
;;; Mode line recursion indicators
(prot-emacs-elpa-package 'recursion-indicator
  (setq recursion-indicator-general "&")
  (setq recursion-indicator-minibuffer "@")
  (recursion-indicator-mode 1))
#+end_src

*** COMMENT Battery status
:PROPERTIES:
:CUSTOM_ID: h:3a759294-ab03-40cb-bb08-94275d76fc53
:END:

Emacs offers a built-in library for presenting information about the
status of the laptop's battery.  Using it allows me to eliminate my
reliance on the system panel and thus keep Emacs in full screen view
without any interruptions.

The default update interval is set to a single minute (in seconds),
which is generally fine though I find that a slightly higher value works
just as well.  As for the format, it is designed to show a
context-dependent, single character indicator about the current status,
as well as the battery's overall percentage.

Variable =battery-mode-line-limit= will hide the indicator if the value is
above the declared threshold.  95 basically means "full" for me.  I use
that instead of a 100 because sometimes the battery only ever fills up
to a lower threshold, meaning that the indicator remains present at all
times.

#+begin_src emacs-lisp
;;; Battery status
(prot-emacs-builtin-package 'battery
  (setq battery-mode-line-format " [%b%p%%]")
  (setq battery-mode-line-limit 95)
  (setq battery-update-interval 180)
  (setq battery-load-low 20)
  (setq battery-load-critical 10)
  (add-hook 'after-init-hook #'display-battery-mode))
#+end_src

*** Display current time (and =world-clock=)
:PROPERTIES:
:CUSTOM_ID: h:da14ac1d-a06f-4531-b6c3-0414e8c98102
:END:

I normally use Emacs in fullscreen view.  No system panels, no window
decorations, no icons and blinking indicators.  Nothing to distract me.
While I really like this immersive experience, sometimes I need to take
a look at the time...  Thankfully Emacs offers a convenient, built-in
way of displaying such information in the mode line: just enable
=display-time-mode=.

The =display-time-format= can be configured to show the current date and
time in all the various formats we would expect, using a string of
specifiers (find the docs with =C-h v format-time-string=).  Setting its
value to =nil= means that the information on display will be the combined
result of =display-time-24hr-format= and =display-time-day-and-date=.  I
prefer to just write a string directly, keeping those two inactive.

The =display-time-mode= can output more than just the current time.  It
also shows the load average and an email indicator.  I do not need the
load average as it adds too much noise.  As for the mail indicator, I
used it for a while, but eventually decided to use my own approach which
also shows the number of new emails (refer to the [[#h:5ad80664-3163-4d9d-be65-462637d77903][Email settings]] and
search, in particular, for either the old =prot-mail-mail-indicator= or
the newer =prot-notmuch-mail-indicator=).

Since the inception of =prot-tab.el= which creates a status line that
replaces mode lines, I enable the clock and mail indicator only when the
status line is enabled (see [[#h:63ad472f-c9c2-40ad-9675-1dc529487788][Tabs for window layouts]]).

Lastly, I use the =world-clock= command (for Emacs28+) when I need to get
an overview of the current time in various parts of the planet.

#+begin_src emacs-lisp
;;; Display current time
(prot-emacs-builtin-package 'time
  (setq display-time-format "%a %e %b, %H:%M")
  ;;;; Covered by `display-time-format'
  ;; (setq display-time-24hr-format t)
  ;; (setq display-time-day-and-date t)
  (setq display-time-interval 60)
  (setq display-time-default-load-average nil)
  ;; NOTE 2021-04-19: For all those, I have implemented a custom
  ;; solution that also shows the number of new items.  Refer to my
  ;; email settings, specifically `prot-mail-mail-indicator'.
  ;;
  ;; NOTE 2021-05-16: Or better check `prot-notmuch-mail-indicator'.
  (setq display-time-mail-directory nil)
  (setq display-time-mail-function nil)
  (setq display-time-use-mail-icon nil)
  (setq display-time-mail-string nil)
  (setq display-time-mail-face nil)

;;; World clock
  (setq zoneinfo-style-world-list
        '(("America/Los_Angeles" "Los Angeles")
          ("America/Chicago" "Chicago")
          ("Brazil/Acre" "Rio Branco")
          ("America/New_York" "New York")
          ("Brazil/East" "Brasília")
          ("Europe/Lisbon" "Lisbon")
          ("Europe/Brussels" "Brussels")
          ("Europe/Athens" "Athens")
          ("Asia/Tehran" "Tehran")
          ("Asia/Tbilisi" "Tbilisi")
          ("Asia/Yekaterinburg" "Yekaterinburg")
          ("Asia/Shanghai" "Shanghai")
          ("Asia/Tokyo" "Tokyo")
          ("Asia/Vladivostok" "Vladivostok")))

  ;; All of the following variables are for Emacs 28
  (setq world-clock-list t)
  (setq world-clock-time-format "%R %z  %A %d %B")
  (setq world-clock-buffer-name "*world-clock*") ; Placement handled by `display-buffer-alist'
  (setq world-clock-timer-enable t)
  (setq world-clock-timer-second 60)

  ;; ;; NOTE 2021-10-04: Check `prot-tab-status-line'.
  ;; (add-hook 'after-init-hook #'display-time-mode)
  )
#+end_src

*** COMMENT Name of current form (which-function-mode)
:PROPERTIES:
:CUSTOM_ID: h:3f2c2d04-01c0-4c35-9a4f-a0cb00bb3062
:END:

The built-in =which-function-mode= is a global minor-mode that shows the
name of the form at point.  In programming modes that is the current
function or, in the case of Elisp, the top-level form.  In Org it is the
title of the current section.  In diffs it is the heading of the present
hunk (to get useful headings for Elisp and Org diffs, read my blog
[[https://protesilaos.com/codelog/2021-01-26-git-diff-hunk-elisp-org/][Informative diff hunks for Emacs Lisp and Org]] (2021-01-26)).

To control the buffers in which this mode is active, we write them as a
list for =which-func-modes=.  A value of =t= signifies every mode, which I
do not consider a good default for a global minor mode.

#+begin_src emacs-lisp
;;; Name of current form (which-function-mode)
(prot-emacs-builtin-package 'which-func
  (setq which-func-unknown "")
  (setq which-func-format     ; NOTE 2021-07-28: removes square brackets
        `((:propertize which-func-current
		               local-map ,which-func-keymap
		               face which-func
		               mouse-face mode-line-highlight
		               help-echo "mouse-1: go to beginning\n\
mouse-2: toggle rest visibility\n\
mouse-3: go to end")))
  (setq which-func-modes
        ;; '( emacs-lisp-mode org-mode markdown-mode diff-mode)
        '( emacs-lisp-mode diff-mode))

  (which-function-mode 1))
#+end_src

*** Keycast mode
:PROPERTIES:
:CUSTOM_ID: h:e8e51a73-e583-4250-ac26-15627cd93932
:END:

Once enabled, this package uses the mode line to show the keys being
pressed and the command they call.  It is quite useful for screen
casting.

The placement of the indicator is controlled by =keycast-window-predicate=
which I set to the current window.  The =moody.el= library offers that
specific piece of functionality (though [[#h:c07b9dfc-14a2-41a6-9310-53539dec8684][I also configure Moody]] for its
primary purpose of styling the mode line).

The tweaks to the =keycast-substitute-alist= prevent the display of
self-inserting characters and some other commands that are not
particularly useful while screen casting.  Now the indicator will only
show commands, which looks cleaner.  I got the idea and original piece
of Elisp from the [[https://github.com/aadcg/dotfiles][dotfiles of André Alexandre Gomes]] and then added a few
tweaks of my own.

#+begin_src emacs-lisp
;;; Keycast mode
(prot-emacs-elpa-package 'keycast
  ;; Those are for `keycast-mode'
  (setq keycast-window-predicate 'moody-window-active-p) ; assumes `moody.el'
  (setq keycast-separator-width 1)
  (setq keycast-remove-tail-elements nil)

  (dolist (input '(self-insert-command
                   org-self-insert-command))
    (add-to-list 'keycast-substitute-alist `(,input "." "Typing…")))

  (dolist (event '(mouse-event-p
                   mouse-movement-p
                   mwheel-scroll))
    (add-to-list 'keycast-substitute-alist `(,event nil)))

  ;; Those are for the `keycast-log-mode'
  (setq keycast-log-format "%-20K%C\n")
  (setq keycast-log-frame-alist
        '((minibuffer . nil)))
  (setq keycast-log-newest-first t)

  ;; Specify `keycast-insert-after' buffer identification.  This make it
  ;; possible to seamlessly toggle `prot-moody-set-height' without
  ;; disrupting keycast.
  (with-eval-after-load 'prot-moody
    (add-hook 'prot-moody-set-height-hook #'prot-moody-keycast-insert-after)))
#+end_src

** Window divider mode
:PROPERTIES:
:CUSTOM_ID: h:6fb900e3-49db-4bc3-8a9e-cd88e020f15b
:END:

This is a built-in mode that can draw both vertical and horizontal
borders.  It can be particularly helpful when used with windows that do
not have a modeline, such as what happens when I enable my custom
=prot-tab-status-line= on Emacs28, which moves all the relevant
information to the tab bar (in effect, it creates a universal status
line---see [[#h:63ad472f-c9c2-40ad-9675-1dc529487788][Tabs for window layouts (tab-bar.el and prot-tab.el)]]).

#+begin_src emacs-lisp
;;; Window divider mode
(setq window-divider-default-right-width 1)
(setq window-divider-default-bottom-width 1)
(setq window-divider-default-places 'right-only)
#+end_src

** Fringe mode
:PROPERTIES:
:CUSTOM_ID: h:26a4fac6-33e2-4f6c-8589-9463df8525c9
:END:

The fringes are areas to the right and left side of an Emacs frame.
They can be used to show status-related or contextual feedback such as
line truncation indicators, continuation lines, code linting markers,
etc.

The default fringe width (=nil=) is 8 pixels on either side, which I
approve of.  It is possible to set the value of the =fringe-mode= to
something like ='(10 . 5)= which applies the varied width to the left and
right side respectively.  Otherwise, we can use a single integer that
controls both sides.

The use of =setq-default= is necessary, otherwise these values become
buffer-local.

#+begin_src emacs-lisp
;;; Fringe mode
(prot-emacs-builtin-package 'fringe
  (fringe-mode nil)
  (setq-default fringes-outside-margins nil)
  (setq-default indicate-buffer-boundaries nil)
  (setq-default indicate-empty-lines nil)
  (setq-default overflow-newline-into-fringe t))
#+end_src

** Color tools (ct.el)
:PROPERTIES:
:CUSTOM_ID: h:755d055b-ef80-4f63-af08-ce9e931de30c
:END:

The =ct.el= library by Github user "neeasade" provides various utilities
for testing colour values across several spaces.  The developer also has
an interesting article on the matter: [[https://notes.neeasade.net/color-spaces.html][Reasoning about Colors]].  I may
need some of those tools while developing my Modus themes.

#+begin_src emacs-lisp
;;; Color tools (ct.el)
(prot-emacs-elpa-package 'ct)
#+end_src

** Rainbow mode for colour previewing (rainbow-mode.el)
:PROPERTIES:
:CUSTOM_ID: h:9061c694-5f45-46b0-a878-6bcfb018e18d
:END:

The following package reads a colour value, such as hexadecimal RGB,
and sets the background for the value in that colour.  Quite useful
when reviewing my themes (=rainbow-mode= is activated manually).

#+begin_src emacs-lisp
;;; Rainbow mode for colour previewing (rainbow-mode.el)
(prot-emacs-elpa-package 'rainbow-mode
  (setq rainbow-ansi-colors nil)
  (setq rainbow-x-colors nil))
#+end_src

** Depth-based code colourisation (prism.el)
:PROPERTIES:
:CUSTOM_ID: h:6478350b-b89b-406e-9b08-2dc9e93cc5b4
:END:

Adam Porter's (aka alphapapa) =prism.el= colourises programming code based
on the level of depth, rather than targeting syntactic constructs like
keywords, strings, variables.  This can be useful when working with
highly-nested and/or unfamiliar code.  It has two modes that are
intended for specific types of programming languages:

1. =prism-mode= is good for Lisp and languages that look like C (I only
   code in Elisp);
2. =prism-whitespace-mode= is for languages that are more sensitive to
   indentation.

The degree of colouration for each level of depth is configurable, as
are the colours to be used.  Consult Prism's documentation for the
technicalities.

My =prot-prism.el= (reproduced after the following configurations)
provides a few extras that help me set the desired style of colouration.
It provides an alist of palette presets.  Those can be applied through
minibuffer completion with the command =prot-prism-set-colors=.  All the
presets are designed to extract colour values from the active Modus
theme ([[#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6][Modus themes (my highly accessible themes)]]).  Those range from a
minimalist style of drawing only four colours, to a more expansive
sixteen-colour gamout.

The =prot-prism-set-colors= command also takes care to activate the
appropriate Prism mode for languages whose major mode is declared as
"indentation-sensitive".  Those are added as a list to the variable
=prot-prism-negative-space-sensitive-modes=.

To disable the effect, just do =M-x prot-prism-disable=.

#+begin_src emacs-lisp
;;; Depth-based code colourisation (prism.el)
(prot-emacs-elpa-package 'prism
  (setq prism-comments t))

(prot-emacs-builtin-package 'prot-prism
  (setq prot-prism-negative-space-sensitive-modes
        '(sh-mode yaml-mode))

  (setq prot-prism-presets-function #'prot-prism--colors))
#+end_src

Here are my tweaks (from [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-prism.el src emacs-lisp :tangle no

** Line numbers and relevant indicators (prot-sideline.el)
:PROPERTIES:
:CUSTOM_ID: h:cb76fcee-e304-4b86-a764-6c3c6775da51
:END:

=prot-sideline.el= (reproduced after the package configurations) is a set
of simplete-minded features:

1. It bundles up together three distinct visual elements as part of a
   common minor mode: =prot-sideline-mode=.  Its constituents are current
   line highlighting (=hl-line-mode=), diff indicators (=diff-hl-mode=), and
   line numbers (=display-line-numbers-mode=).  Line numbers and line
   highlighting are built into Emacs.

2. A simple toggle for =whitespace-mode=, which I only ever use to double
   check some area's indentation or to confirm that no newline is
   missing at the end of the file.

Note that the =diff-hl= package offers some more features other than the
obvious colour-coded highlighting of changes, such as the ability to
move between diff hunks (with =C-x v [= and =C-x v ]=) or to revert the
current hunk (=C-x v n=).  Those can come in handy (check my comprehensive
extensions in [[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][Version control framework (vc.el and prot-vc.el)]]).

#+begin_src emacs-lisp
;;; Line numbers and relevant indicators (prot-sideline.el)
(prot-emacs-builtin-package 'prot-sideline
  (require 'display-line-numbers)
  ;; Set absolute line numbers.  A value of "relative" is also useful.
  (setq display-line-numbers-type t)
  ;; Those two variables were introduced in Emacs 27.1
  (setq display-line-numbers-major-tick 0)
  (setq display-line-numbers-minor-tick 0)
  ;; Use absolute numbers in narrowed buffers
  (setq-default display-line-numbers-widen t)

  (prot-emacs-elpa-package 'diff-hl
    (setq diff-hl-draw-borders nil)
    (setq diff-hl-side 'left))

  (require 'hl-line)
  (setq hl-line-sticky-flag nil)
  (setq hl-line-overlay-priority -50) ; emacs28

  (require 'whitespace)

  (let ((map global-map))
    (define-key map (kbd "<f6>") #'prot-sideline-negative-space-toggle)
    (define-key map (kbd "<f7>") #'prot-sideline-mode)
    (define-key map (kbd "C-c z") #'delete-trailing-whitespace)))
#+end_src

This is =prot-sideline.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-sideline.el src emacs-lisp :tangle no

** Outline mode, outline minor mode, and extras (prot-outline.el)
:PROPERTIES:
:CUSTOM_ID: h:a8e737b8-7c90-4c68-8814-acf2f637ffa1
:END:

The =outline.el= library defines a major mode (=outline-mode=) that is
similar to =org-mode= in that it consists of headings which can be
expanded or contracted individually or as a group (actually Outline
predates Org).  The major mode is meant to work with plain text files,
or be leveraged by other packages that need to have some structure and
the accompanying benefits of outline folding.  In practice, however, I
never found a dedicated use for it that would justify it over the more
featureful Org.

Where =outline.el= truly shines, in my experience, is in the minor mode it
defines (=outline-minor-mode=), which provides the familiar structured,
heading-folding facilities in other major modes, like =emacs-lisp-mode= or
any arbitrary mode, like =diff-mode= and the =diary=.

Also read:

+ [[#h:b4040bc0-7a2a-4f17-824d-42de621bd1b9][Calendar and Diary (and prot-diary.el)]].
+ [[#h:2ff46d23-09d5-4d92-b0af-2339dc19719f][Diff-mode (and prot-diff.el extensions)]].

With some careful tweaks you can continue to work on your code while
also benefitting from a more effective means of organising and reviewing
what you have.

In practice, to make an outline for Elisp buffers, you need to start a
comment line /without leading spaces/ and make it at least three comment
delimiters long (=;;;=) followed by a space and then the text of the
heading, such as =;;; Code:=.  That is considered a heading level 1.
Every extra delimiter will increase heading levels accordingly.  The
buffer-local variable =outline-regexp= determines what constitutes a
heading for this purpose.

Now on to my custom library, =prot-outline.el= which builds on those
concepts:

+ Provide several new commands and minor extras for working with
  outlines.

+ Define a =prot-outline-minor-mode-safe= command that checks whether the
  current buffer's major mode is not a member of a blocklist.  The idea
  is to not run =outline-minor-mode= with major modes that already provide
  its functionality: =org-mode=, =outline-mode=, =markdown-mode=.

Watch my [[https://protesilaos.com/codelog/2020-07-20-emacs-outline-imenu/][video demo of outline-minor-mode and imenu]] (2020-07-20), though
note that it was recorded long before I wrote =prot-outline.el=.  In
particular, older versions of my code would establish bindings for
=imenu.el=.  This was done via bespoke entry and exit hooks and was
intended to complement the standard Imenu headings with those of the
Outline.  This is no longer needed because =consult-outline= does exactly
that ([[#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb][Enhanced minibuffer commands (consult.el and prot-consult.el)]]).  A
quick reminder of why this matters: you can navigate the outline using
minibuffer completion, which is my favourite way to browse a file.  You
can, in the same spirit, use Embark to produce a buffer with the
completion candidates, i.e. the headings, or a subset you have narrowed
to, and navigate therefrom.  It really is an efficient workflow:
[[#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984][Extended minibuffer actions and more (embark.el and prot-embark.el)]].

#+begin_src emacs-lisp
;;; Outline mode, outline minor mode, and extras (prot-outline.el)
(prot-emacs-builtin-package 'outline
  (setq outline-minor-mode-highlight 'override) ; emacs28
  (setq outline-minor-mode-cycle t)             ; emacs28
  (let ((map outline-minor-mode-map))
    ;; ;; NOTE 2021-07-25: Those two are already defined (emacs28).
    ;; (define-key map (kbd "TAB") #'outline-cycle)
    ;; (define-key map (kbd "<backtab>") #'outline-cycle-buffer) ; S-TAB
    (define-key map (kbd "C-c C-n") #'outline-next-visible-heading)
    (define-key map (kbd "C-c C-p") #'outline-previous-visible-heading)
    (define-key map (kbd "C-c C-f") #'outline-forward-same-level)
    (define-key map (kbd "C-c C-b") #'outline-backward-same-level)
    (define-key map (kbd "C-c C-a") #'outline-show-all)
    (define-key map (kbd "C-c C-o") #'outline-hide-other)
    (define-key map (kbd "C-c C-u") #'outline-up-heading)))

(prot-emacs-builtin-package 'prot-outline
  (let ((map outline-minor-mode-map))
    (define-key map (kbd "C-c C-v") #'prot-outline-move-major-heading-down)
    (define-key map (kbd "M-<down>") #'prot-outline-move-major-heading-down)
    (define-key map (kbd "C-c M-v") #'prot-outline-move-major-heading-up)
    (define-key map (kbd "M-<up>") #'prot-outline-move-major-heading-up)
    (define-key map (kbd "C-x n s") #'prot-outline-narrow-to-subtree))
  (define-key global-map (kbd "<f10>") #'prot-outline-minor-mode-safe))
#+end_src

These are the contents of the =prot-outline.el= library (find the file in
[[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]] (as with all my Elisp code)):

#+include: prot-lisp/prot-outline.el src emacs-lisp :tangle no

** Cursor and mouse settings
:PROPERTIES:
:CUSTOM_ID: h:a75d07c3-22a8-4e0f-aa88-1e2e1579d820
:END:
*** Cursor appearance and tweaks (prot-cursor.el)
:PROPERTIES:
:CUSTOM_ID: h:cf9086c1-1b33-4127-a716-de94259e14a0
:END:

=prot-cursor.el= defines a set of presets that control the overall style
of the cursor.  There presuppose the =blink-cursor-mode=.  The properties
we pass to those presets mirror those we can pass for the various
built-in variables for the cursor.  Check the =prot-cursor.el= code, which
is reproduced right after the following package configurations.

#+begin_src emacs-lisp
;;; Cursor appearance and tweaks (prot-cursor.el)
(prot-emacs-builtin-package 'prot-cursor
  (setq prot-cursor-presets
        '((bar . ( :cursor-type (bar . 2)
                   :cursor-no-selected hollow
                   :blinks 10
                   :blink-interval 0.5
                   :blink-delay 0.2))

          (box . ( :cursor-type box
                   :cursor-no-selected hollow
                   :blinks 10
                   :blink-interval 0.5
                   :blink-delay 0.2))

          (underscore . ( :cursor-type (hbar . 3)
                          :cursor-no-selected hollow
                          :blinks 50
                          :blink-interval 0.2
                          :blink-delay 0.2))))
  (setq prot-cursor-last-state-file
        (locate-user-emacs-file "prot-cursor-last-state"))

  (prot-cursor-restore-last-preset)

  ;; Sets my style on startup.
  (if prot-cursor--recovered-preset
      (prot-cursor-set-cursor prot-cursor--recovered-preset)
    (prot-cursor-set-cursor 'underscore))

  ;; The other side of `prot-cursor-restore-last-preset'.
  (add-hook 'kill-emacs-hook #'prot-cursor-store-last-preset)

  ;; We have to use the "point" mnemonic, because C-c c is for
  ;; `org-capture'.
  (define-key global-map (kbd "C-c p") #'prot-cursor-set-cursor))
#+end_src

This is =prot-cursor.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-cursor.el src emacs-lisp :tangle no

*** Mouse wheel behaviour
:PROPERTIES:
:CUSTOM_ID: h:02572210-eb26-4941-8f7c-666a0314877b
:END:

The value of =mouse-wheel-scroll-amount= means the following:

+ By default scroll by one line.
+ Hold down Shift to do so by five lines.
+ Hold down Meta to scroll half a screen.
+ Hold down Control to adjust the size of the text.  This was added in
  Emacs 27.

The other options in short:

+ Hide mouse pointer while typing.
+ Enable mouse scroll.
+ Faster wheel movement means faster scroll.
+ Scroll window under mouse pointer regardless of whether it is the
  current one or not.

Note that if we enable =mouse-drag-copy-region= we automatically place the
mouse selection to the kill ring.  This is the same behaviour as
terminal emulators that place the selection to the clipboard (or the
primary selection).  I choose not to use this here.

=tear-off-window= places the current window in a new frame.  On my generic
mouse, =<mouse-3>= is the right click.  Normally I call that command with
=M-x=, though it does not hurt to rely on the mouse from time to time.

#+begin_src emacs-lisp
;;; Mouse wheel behaviour
(prot-emacs-builtin-package 'mouse
  ;; In Emacs 27+, use Control + mouse wheel to scale text.
  (setq mouse-wheel-scroll-amount
        '(1
          ((shift) . 5)
          ((meta) . 0.5)
          ((control) . text-scale)))
  (setq mouse-drag-copy-region nil)
  (setq make-pointer-invisible t)
  (setq mouse-wheel-progressive-speed t)
  (setq mouse-wheel-follow-mouse t)
  (add-hook 'after-init-hook #'mouse-wheel-mode)
  (define-key global-map (kbd "C-M-<mouse-3>") #'tear-off-window))
#+end_src

*** Scrolling behaviour
:PROPERTIES:
:CUSTOM_ID: h:0c44b318-813a-4f4a-b596-75df4a86476b
:END:

By default, page scrolling should keep the point at the same visual
position, rather than force it to the top or bottom of the viewport.
This eliminates the friction of guessing where the point has warped to.

As for per-line scrolling, I dislike the default behaviour of visually
re-centring the point: it is too aggressive as a standard mode of
interaction.  With the following the point will stay at the top/bottom
of the screen while moving in that direction (use =C-l= to reposition it).

The =next-screen-context-lines= ensures that when moving by screenfulls
(with either =C-v= or =M-v=) we do not get any continuation lines from the
previous screen.  I find this more intuitive.

#+begin_src emacs-lisp
;;; Scrolling behaviour
(setq-default scroll-preserve-screen-position t)
(setq-default scroll-conservatively 1) ; affects `scroll-step'
(setq-default scroll-margin 0)
(setq-default next-screen-context-lines 0)
#+end_src

*** Delete selection
:PROPERTIES:
:CUSTOM_ID: h:d53b7b54-924a-443b-955a-3c5b222e3a90
:END:

This is a very helpful mode.  It kills the marked region when inserting
directly to it.  It also has checks to ensure that yanking over a
selected region will not insert itself when =mouse-drag-copy-region= is in
effect (see the section on the [[#h:02572210-eb26-4941-8f7c-666a0314877b][mouse wheel behaviour]]).

#+begin_src emacs-lisp
;;; Delete selection
(prot-emacs-builtin-package 'delsel
  (add-hook 'after-init-hook #'delete-selection-mode))
#+end_src

*Pro tip*: On Emacs 27.1 or higher you can create a rectangular region by
holding down Ctrl and Meta while dragging the mouse with the left click
pressed.

*** Tooltips (tooltip-mode)
:PROPERTIES:
:CUSTOM_ID: h:9f492949-70fb-4fba-a0ea-569d4a240be8
:END:

These settings control how tool tips are to be handled when hovering the
mouse over an actionable item:

+ I just want to make sure that the GTK theme is /not used/ for those: I
  prefer the generic display which follows my current theme's styles.
+ The delay is slightly reduced for the initial pop-up, while it has
  been increased for immediate pop-ups thereafter.

#+begin_src emacs-lisp
;;; Tooltips (tooltip-mode)
(prot-emacs-builtin-package 'tooltip
  (setq tooltip-delay 0.5)
  (setq tooltip-short-delay 0.5)
  (setq x-gtk-use-system-tooltips nil)
  (setq tooltip-frame-parameters
        '((name . "tooltip")
          (internal-border-width . 6)
          (border-width . 0)
          (no-special-glyphs . t)))
  (add-hook 'after-init-hook #'tooltip-mode))
#+end_src

** Dired-like list for registers (rlist)
:PROPERTIES:
:CUSTOM_ID: h:aad79917-cd80-491b-9020-db27867ab132
:END:

This package by Sévère Durand implements a Dired-like interface for the
purpose of deleting an entry from the list.  I feel this is the one
major feature that is missing from the registers' toolkit: it provides
you with the means to remain in control of the data you accumulate in
those compartments, so nothing ever gets out of hand.

Note that this is a fairly new project (as of 2021-02-05), so things are
likely to change over the near term.

#+begin_src emacs-lisp
;;; Dired-like list for registers (rlist)
;; Project repo: <https://gitlab.com/mmemmew/rlist>.  This is one of the
;; packages I handle manually via git, at least until it becomes
;; available through an ELPA.
;;
;; `prot-emacs-manual-package' is defined in my init.el
(prot-emacs-manual-package 'rlist
  (setq rlist-expert t)
  (setq rlist-verbose t)
  (let ((map global-map))
    (define-key map (kbd "C-x r <backspace>") #'rlist-list-registers)
    (define-key map (kbd "C-x r <delete>") #'rlist-list-registers)))
#+end_src

** Conveniences and minor extras
:PROPERTIES:
:CUSTOM_ID: h:271c9122-280b-424e-98f0-af9e4f09bbdb
:END:
*** Automatic time stamps for files (time-stamp.el)
:PROPERTIES:
:CUSTOM_ID: h:24c2ac42-a537-4658-8a08-9aebb0de1a73
:END:

The built-in =time-stamp.el= provides the means to automatically update a
predefined header with the time its file was last edited/saved.  This
is, in my experience, particularly useful for packages that have a
stable version but also need to disambiguate their latest tagged release
from their current development state.

By default, this is done by checking the first eight lines of the file
for the =Time-stamp: <>= entry.  Though that is configurable.  To properly
utilise this library, you need to implement file-local variables.  Those
should control the exact format of the time stamp.  For examples, this
is what I have in my =modus-themes.el=:

#+begin_example
;; Local Variables:
;; time-stamp-start: "Last-Modified:[ \t]+\\\\?[\"<]"
;; time-stamp-end: "\\\\?[\">]"
;; time-stamp-format: "%Y-%02m-%02d %02H:%02M:%02S %5z"
;; End:
#+end_example

Check =M-x find-library RET time-stamp RET= for all variables you may want
to control.

All we do here is enable the package and add a hook to insert a time
stamp upon save, where relevant.  It works seamlessly.

#+begin_src emacs-lisp
;;; Automatic time stamps for files (time-stamp.el)
(prot-emacs-builtin-package 'time-stamp
  (add-hook 'before-save-hook #'time-stamp))
#+end_src

*** Auto revert mode
:PROPERTIES:
:CUSTOM_ID: h:7a8422e6-86d1-40f3-add4-0a1c826e44a3
:END:

This mode ensures that the buffer is updated whenever the file changes.
A change can happen externally or by some other tool inside of Emacs
(e.g. kill a Magit diff).

#+begin_src emacs-lisp
;;; Auto revert mode
(prot-emacs-builtin-package 'autorevert
  (setq auto-revert-verbose t)
  (add-hook 'after-init-hook #'global-auto-revert-mode))
#+end_src

*** Preserve contents of system clipboard
:PROPERTIES:
:CUSTOM_ID: h:9eae0d2a-eef1-4b14-b883-39094be4de71
:END:

Say you copied a link from your web browser, then switched to Emacs to
paste it somewhere.  Before you do that, you notice something you want
to kill.  Doing that will place the last kill to the clipboard, thus
overriding the thing you copied earlier.  We can have a kill ring
solution to this with the following:

#+begin_src emacs-lisp
;;; Preserve contents of system clipboard
(setq save-interprogram-paste-before-kill t)
#+end_src

Now the contents of the clipboard are stored in the kill ring and can
be retrieved from there (e.g. with =M-y=).

*** Newline characters for file ending
:PROPERTIES:
:CUSTOM_ID: h:c0f0a2c1-1920-4bcf-8eb4-45f80cf1b874
:END:

For some major modes, such as =diff-mode=, a final newline is of paramount
importance.  Without it you cannot, for instance, apply a patch cleanly.
As such, the =mode-require-final-newline= will add a newline character
when visiting or saving a buffer of relevance.

#+begin_src emacs-lisp
;;; Newline characters for file ending
(setq mode-require-final-newline 'visit-save)
#+end_src

*** Zap characters
:PROPERTIES:
:CUSTOM_ID: h:5f6ffe61-f0cc-41ad-9d2f-46ad181c3a00
:END:

There are two kinds of "zap" functionality:

+ =zap-up-to-char= will delete everything from point up to the character
  you provide it with.  Think of how you may want to remove a file name
  but keep its file type extension, so =M-x zap-up-to-char RET .= will do
  just that.
+ =zap-to-char=, which is bound to =M-z= by default, will delete the target
  character as well.

I bind the former to =M-z= as I use it more often and leave its
counterpart on =M-Z= (=M-S-z=).

#+begin_src emacs-lisp
;;; Zap characters
(let ((map global-map))
  (define-key map (kbd "M-z") #'zap-up-to-char)
  (define-key map (kbd "M-Z") #'zap-to-char)) ; M-S-z
#+end_src

*** Package lists
:PROPERTIES:
:CUSTOM_ID: h:0d36996d-c12d-42e6-a388-b67c548c4a4b
:END:

With this I just want to enable line highlighting when browsing the list
of packages.  I generally use =hl-line-mode= on all interfaces where the
current line is more important than the exact column of the point.

#+begin_src emacs-lisp
;;; Package lists
(prot-emacs-builtin-package 'package
  ;; All variables are for Emacs 28+
  (setq package-name-column-width 40)
  (setq package-version-column-width 14)
  (setq package-status-column-width 12)
  (setq package-archive-column-width 8)
  (add-hook 'package-menu-mode-hook #'hl-line-mode))
#+end_src

* Language settings for prose and code
:PROPERTIES:
:CUSTOM_ID: h:8fc1f9ca-f5ae-407a-b721-aab414ca657b
:END:

This section is all about configurations and/or packages that deal with
natural or programming language enhancements.

** Support for various major modes
:PROPERTIES:
:CUSTOM_ID: h:485bb253-208a-4a0a-99e3-ae1a205e3b7b
:END:

These provide syntax highlighting and additional features for
environments that are not already supported by Emacs.

*** Plain text (text-mode with prot-text.el)
:PROPERTIES:
:CUSTOM_ID: h:a04db751-9675-4f31-befc-0b48671c4b3b
:END:

My =prot-text.el= (copied verbatim further below) is meant to provide a
set of extensions for the built-in =text-mode.el=.  Currently there is
only one command:

+ =prot-text-insert-heading= lets you add a heading delimiter to the line
  at point.  The length of the delimiter is equal to that of the line.
  By default, the delimiter consists of hyphens, but with a =C-u= prefix
  argument those are substituted for equals signs.

I used to have another two in this file, which have now (2021-04-13)
been moved to =prot-simple.el=.  Those are =prot-simple-cite-region= and
=prot-simple-insert-undercaret=.

Refer to the source code in [[#h:ae48fe61-a3c3-4132-8986-785f9bfbeafb][Common custom functions (prot-simple.el)]].

#+begin_src emacs-lisp
;;; Plain text (text-mode with prot-text.el)
(prot-emacs-builtin-package 'text-mode)

(prot-emacs-builtin-package 'prot-text
  (add-to-list 'auto-mode-alist '("\\(README\\|CHANGELOG\\|COPYING\\|LICENSE\\)$" . text-mode))
  (define-key text-mode-map (kbd "<M-return>") #'prot-text-insert-heading)
  (define-key org-mode-map (kbd "<M-return>") #'org-meta-return) ; don't override M-RET here
  (define-key org-mode-map (kbd "M-;") nil))
#+end_src

This is =prot-text.el= (find the file in [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]] (as with all my
Elisp code)):

#+include: prot-lisp/prot-text.el src emacs-lisp :tangle no

*** Markdown (markdown-mode)
:PROPERTIES:
:CUSTOM_ID: h:7e0416c0-3acc-4748-9eca-4dd4da11d79b
:END:

I edit lots of Markdown files.  This makes things easier.

#+begin_src emacs-lisp
;;; Markdown (markdown-mode)
(prot-emacs-elpa-package 'markdown-mode
  (add-to-list 'auto-mode-alist '("\\.md$" . markdown-mode))
  (setq markdown-fontify-code-blocks-natively t))
;; Allows for fenced block focus with C-c ' (same as Org blocks).
(prot-emacs-elpa-package 'edit-indirect)
#+end_src

*** YAML (yaml-mode)
:PROPERTIES:
:CUSTOM_ID: h:c6a1aa30-4850-40b4-9764-302d98ba95fc
:END:

This adds support for YAML files.

#+begin_src emacs-lisp
;;; YAML (yaml-mode)
(prot-emacs-elpa-package 'yaml-mode
  (add-to-list 'auto-mode-alist '("\\.ya?ml$" . yaml-mode)))
#+end_src

*** CSS (css-mode)
:PROPERTIES:
:CUSTOM_ID: h:ec10bfe6-5340-481c-9de2-3e346868241b
:END:

This is the built-in mode for working with CSS and SCSS.  I just want it
to not apply previews to colour references.  If I ever need that, there
is =rainbow-mode= (see [[#h:9061c694-5f45-46b0-a878-6bcfb018e18d][relevant section]]).

#+begin_src emacs-lisp
;;; CSS (css-mode)
(prot-emacs-builtin-package 'css-mode
  (add-to-list 'auto-mode-alist '("\\.css$" . css-mode))
  (add-to-list 'auto-mode-alist '("\\.scss$" . scss-mode))
  (setq css-fontify-colors nil))
#+end_src

*** Shell scripts (sh-mode)
:PROPERTIES:
:CUSTOM_ID: h:fee2b8ff-80d6-4669-904c-c8ee64c9719c
:END:

=sh-mode.el= is another built-in mode that targets shell scripts.  I
think it works well out-of-the-box, even though it provides lots of
configuration options to further control its behaviour.

All I want here is to enable =sh-mode= in various files that are not
obvious shell scripts, like Arch Linux's package recipes.  As such, the
value assigned to =auto-mode-alist= will be expanded each time I
identify such a file.

#+begin_src emacs-lisp
;;; Shell scripts (sh-mode)
(prot-emacs-builtin-package 'sh-script
  (add-to-list 'auto-mode-alist '("PKGBUILD" . sh-mode)))
#+end_src

** Paragraphs and fill-mode (prot-fill.el)
:PROPERTIES:
:CUSTOM_ID: h:1ae84fae-efc1-4bcc-9542-55b4ab8391a3
:END:

The =prot-fill.el= library (reproduced below) is a tiny wrapper around
some Emacs settings and modes that are scrattered around several files,
which control (i) how paragraphs or comments in programming modes should
be wrapped to a given column count, and (ii) what constitutes a
sentence.  I put them all together here to make things easier to track.

+ With regard to paragraphs, I find that a double space is the best way
  to delimit sentences in source form, where a monospaced typeface is
  customary.  There is no worry that this will be shown on a website or
  rendered version of a document, because processors know how to handle
  spacing.  We do this to make phrases easier to tell apart, but also to
  render unambiguous commands like =forward-sentence=.

+ =prot-fill-fill-mode= sets my desired default column width for all
  buffers, while it applies another value for programming modes (in case
  there is a need to control the two cases separately).  Those values
  are stored in the variables =prot-fill-default-column= and
  =prot-fill-prog-mode-column= respectively.  My minor mode also enables
  =auto-fill-mode= in =text-mode= and =prog-mode= buffers through the
  appropriate hooks.  Disabling =prot-fill-fill-mode= will remove all
  those customisations.

Note that [[#h:ae48fe61-a3c3-4132-8986-785f9bfbeafb][Common custom functions (prot-simple.el)]] contains some
commands related to auto-fill.  Besides, you can always do it manually
for the current paragraph or the active region with =M-x fill-paragraph=,
bound by default to =M-q=.

#+begin_src emacs-lisp
;;; Paragraphs and fill-mode (prot-fill.el)
(prot-emacs-builtin-package 'prot-fill
  (setq prot-fill-default-column 72)
  (setq prot-fill-prog-mode-column 72)  ; Set this to another value if you want
  ;; Those variables come from various sources, though they feel part of the
  ;; same conceptual framework.
  (setq sentence-end-double-space t)
  (setq sentence-end-without-period nil)
  (setq colon-double-space nil)
  (setq use-hard-newlines nil)
  (setq adaptive-fill-mode t)
  (prot-fill-fill-mode 1)
  (add-hook 'after-init-hook #'column-number-mode))
#+end_src

These are the contents of =prot-fill.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-fill.el src emacs-lisp :tangle no

** Comments (newcomment.el and prot-comment.el)
:PROPERTIES:
:CUSTOM_ID: h:fa56241c-6840-4a39-8f59-18460d37fc69
:END:

The built-in =newcomment.el= library offers several useful commands for
working with comments in source code.  While my =prot-comment.el=
(reproduced after the package configurations) adds some simple extras.

The intent of my configurations here is straightforward: re-configure
key bindings to make the most common action easier to access and then
arrange the rest in a meaningful way, while also setting up the
appropriate variables.

The most common action is the command =prot-comment-comment-dwim= which is
bound to =C-;=.  Note that =C-;= is normally occupied by some =flyspell=
command (disabled in [[#h:3f1b2856-c6b7-418a-9d7d-464bd1ebe69c][Flyspell and prot-spell.el (spell check)]]).  Compare
that keybinding to the one I have for the much more specialised
=prot-comment-timestamp-keyword=: =C-x C-;=.  What those commands do is
documented in their docstrings, so please check the code below.

#+begin_src emacs-lisp
;;; Comments (newcomment.el and prot-comment.el)
(prot-emacs-builtin-package 'newcomment
  (setq comment-empty-lines t)
  (setq comment-fill-column nil)
  (setq comment-multi-line t)
  (setq comment-style 'multi-line)
  (let ((map global-map))
    (define-key map (kbd "C-:") #'comment-kill)         ; C-S-;
    (define-key map (kbd "M-;") #'comment-indent)))

(prot-emacs-builtin-package 'prot-comment
  (setq prot-comment-comment-keywords
        '("TODO" "NOTE" "XXX" "REVIEW" "FIXME"))
  (setq prot-comment-timestamp-format-concise "%F")
  (setq prot-comment-timestamp-format-verbose "%F %T %z")
  (let ((map global-map))
    (define-key map (kbd "C-;") #'prot-comment-comment-dwim)
    (define-key map (kbd "C-x C-;") #'prot-comment-timestamp-keyword)))
#+end_src

And here is =prot-comment.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-comment.el src emacs-lisp :tangle no

** Configure 'electric' behaviour
:PROPERTIES:
:CUSTOM_ID: h:ed95ef3e-75e6-4e53-b3bc-4aee540fe3d9
:END:

Emacs labels as "electric" any behaviour that involves contextual
auto-insertion of characters.  while the idea is neat, I generally
dislike it because of its false positives.  This is a summary of my
settings:

+ If =electric-pair-mode= is enabled (which I might do manually), insert
  quotes and brackets in pairs.  Only do so if there is no alphabetic
  character after the cursor.
+ The cryptic numbers in the pairs set, correspond to curly single and
  double quotes and these =«»=.  The contents of this set are always
  inserted in pairs, regardless of major mode.  To get those numbers,
  evaluate =(string-to-char CHAR)= where CHAR is the one you are
  interested in.  For example, get the literal tab's character with
  =(string-to-char "\t")=.
+ While inputting a pair, inserting the closing character will just skip
  over the existing one, rather than add a new one.  So typing =(= will
  insert =()= and then typing =)= will just be the same as moving forward
  one character =C-f=.
+ Do not skip over whitespace when operating on pairs.  Combined with
  the above point, this means that a new character will be inserted,
  rather than be skipped over.  I find this better, because it prevents
  the point from jumping forward, plus it allows for more natural
  editing.
+ The whitespace characters are space (=\s=), tab (=\t=), and newline (=\n=).
+ The rest concern the conditions for transforming quotes into their
  curly equivalents.  I keep this disabled, because curly quotes are
  distinct characters.  It is difficult to search for them.  Just note
  that on GNU/Linux you can type them directly by hitting the "compose"
  key and then an angled bracket (=<= or =>=) followed by a quote mark.

#+begin_src emacs-lisp
;;; Configure 'electric' behaviour
(prot-emacs-builtin-package 'electric
  (setq electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit)
  (setq electric-pair-preserve-balance t)
  (setq electric-pair-pairs
        '((8216 . 8217)
          (8220 . 8221)
          (171 . 187)))
  (setq electric-pair-skip-self 'electric-pair-default-skip-self)
  (setq electric-pair-skip-whitespace nil)
  (setq electric-pair-skip-whitespace-chars '(9 10 32))
  (setq electric-quote-context-sensitive t)
  (setq electric-quote-paragraph t)
  (setq electric-quote-string nil)
  (setq electric-quote-replace-double t)
  (electric-pair-mode -1)
  (electric-quote-mode -1)
  ;; I don't like auto indents in Org and related.
  (add-hook 'prog-mode-hook #'electric-indent-local-mode))
#+end_src

** Parentheses (show-paren-mode)
:PROPERTIES:
:CUSTOM_ID: h:3d374354-843f-4efa-aa38-1ba2c9ccc14c
:END:

Configure the mode that highlights matching delimiters or parentheses.
I consider this of utmost importance when working with languages such as
elisp.

Summary of what these do:

+ Activate the mode upon startup.
+ Show the matching delimiter/parenthesis if on screen, else show
  nothing.  It is possible to highlight the expression enclosed by the
  delimiters, by using either =mixed= or =expression=.  The latter always
  highlights the entire balanced expression, while the former will only
  do so if the matching delimiter is off screen.
+ =show-paren-when-point-in-periphery= lets you highlight parentheses even
  if the point is in their vicinity.  This means the beginning or end of
  the line, with space in between.  I used that for a long while and it
  server me well.  Now that I have a better understanding of Elisp, I
  disable it.
+ Do not highlight a match when the point is on the inside of the
  parenthesis.

#+begin_src emacs-lisp
;;; Parentheses (show-paren-mode)
(prot-emacs-builtin-package 'paren
  (setq show-paren-style 'parenthesis)
  (setq show-paren-when-point-in-periphery nil)
  (setq show-paren-when-point-inside-paren nil)
  (add-hook 'after-init-hook #'show-paren-mode))
#+end_src

** Tabs, indentation, and the TAB key
:PROPERTIES:
:CUSTOM_ID: h:d51d37df-4e58-4e0b-85a1-019ceda342f6
:END:

I believe tabs, in the sense of inserting the tab character, are best
suited for indentation.  While spaces are superior at precisely aligning
text.  However, I understand that elisp uses its own approach, which I
do not want to interfere with.  Also, Emacs tends to perform alignments
by mixing tabs with spaces, which /can actually lead to misalignments/
depending on certain variables such as the size of the tab.  As such, I
am disabling tabs by default.

If there ever is a need to use different settings in other modes, we can
customise them via hooks.  This is not an issue I have encountered yet
and am therefore refraining from solving a problem that does not affect
me.

Note that =tab-always-indent= will first do indentation and then try to
complete whatever you have typed in.

#+begin_src emacs-lisp
;;; Tabs, indentation, and the TAB key
(setq-default tab-always-indent 'complete)
(setq-default tab-first-completion 'word-or-paren-or-punct) ; Emacs 27
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)
#+end_src

** Flyspell and prot-spell.el (spell check)
:PROPERTIES:
:CUSTOM_ID: h:3f1b2856-c6b7-418a-9d7d-464bd1ebe69c
:END:

I need spell checking mostly for English, though I also install
dictionaries for Greek, French, and Spanish.  These are external to
Emacs and are provided by the =aspell= library.

In previous versions of this section I had configurations that would
automate spell checking.  It worked but was rather slow.  Upon further
inspection, I realised that I seldom need to work in mixed language
circumstances.  Moreover, I now understand that I do not need to have
spell checking always on: it is distracting.

My workflow is to call an interactive command to perform spell checking.
This is =prot-spell-spell-dwim=, which is part of my =prot-spell.el= library
(reproduced after the following package configurations).  What it does is
search for errors in the active region or, if that does not apply,
operate on the word at point.  Its fallback condition is a call to
=prot-spell-change-dictionary=, which I use to switch between languages
using minibuffer completion.

Also bear in mind that the key binding =C-;= that Flyspell uses by default
is disabled because I re-purpose it for a faster version of =C-x C-;=
(much more useful for my work—see the [[#h:fa56241c-6840-4a39-8f59-18460d37fc69][section on comments]]).

#+begin_src emacs-lisp
;;; Flyspell and prot-spell.el (spell check)
(prot-emacs-builtin-package 'flyspell
  (setq flyspell-issue-message-flag nil)
  (setq flyspell-issue-welcome-flag nil)
  (setq ispell-program-name "aspell")
  (setq ispell-dictionary "en_GB")
  (define-key flyspell-mode-map (kbd "C-;") nil))

(prot-emacs-builtin-package 'prot-spell
  (setq prot-spell-dictionaries
        '(("EN English" . "en")
          ("EL Ελληνικά" . "el")
          ("FR Français" . "fr")
          ("ES Espanõl" . "es")))
  (let ((map global-map))
    (define-key map (kbd "M-$") #'prot-spell-spell-dwim)
    (define-key map (kbd "C-M-$") #'prot-spell-change-dictionary)))
#+end_src

This is =prot-spell.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-spell.el src emacs-lisp :tangle no

** Code and text linters
:PROPERTIES:
:CUSTOM_ID: h:20448ad8-9371-4e00-b88b-6b93f4c654d9
:END:

*** Flymake
:PROPERTIES:
:CUSTOM_ID: h:b8bfcc05-c0d3-4093-b3fe-f06187d22c6a
:END:

This is a built-in linter interface.  It visualises in a buffer what you
would otherwise get on the command-line prompt (or compilation log),
while it also marks the line[s] where the note, warning, or error
occurs.  In short, it is quite a nice tool to have.

Several extensions to Flymake are already available, mostly targeted at
programmers.  For my case, there is no need for any of those, while
Flymake can lint Elisp without any further configuration.

The external =flymake-diagnostic-at-point= package provides a simple and
effective interface to displaying information about the warning at
point.

#+begin_src emacs-lisp
;;; Flymake
(prot-emacs-builtin-package 'flymake
  (setq flymake-fringe-indicator-position 'left-fringe)
  (setq flymake-suppress-zero-counters t)
  (setq flymake-start-on-flymake-mode t)
  (setq flymake-no-changes-timeout nil)
  (setq flymake-start-on-save-buffer t)
  (setq flymake-proc-compilation-prevents-syntax-check t)
  (setq flymake-wrap-around nil)
  (setq flymake-mode-line-format
        '("" flymake-mode-line-exception flymake-mode-line-counters))
  (setq flymake-mode-line-counter-format
        '(" " flymake-mode-line-error-counter
          flymake-mode-line-warning-counter
          flymake-mode-line-note-counter ""))

  (let ((map flymake-mode-map))
    (define-key map (kbd "C-c ! s") #'flymake-start)
    (define-key map (kbd "C-c ! d") #'flymake-show-buffer-diagnostics) ; Emacs28
    (define-key map (kbd "C-c ! n") #'flymake-goto-next-error)
    (define-key map (kbd "C-c ! p") #'flymake-goto-prev-error)))

(prot-emacs-elpa-package 'flymake-diagnostic-at-point
  (setq flymake-diagnostic-at-point-display-diagnostic-function
        'flymake-diagnostic-at-point-display-minibuffer))
#+end_src

**** Flymake + Shellcheck
:PROPERTIES:
:CUSTOM_ID: h:a45fd661-8cd7-4ee7-bff0-5f738d82b73b
:END:

The =flymake-shellcheck= package simply adds support for Shellcheck, the
linter for shell scripts.  It otherwise relies on the standard utilities
of =flymake-mode= (see [[#h:b8bfcc05-c0d3-4093-b3fe-f06187d22c6a][main Flymake configs]]).

#+begin_src emacs-lisp
;;; Flymake + Shellcheck
(prot-emacs-elpa-package 'flymake-shellcheck
  (add-hook 'sh-mode-hook 'flymake-shellcheck-load))
#+end_src

**** Flymake + Proselint
:PROPERTIES:
:CUSTOM_ID: h:2a954862-c532-43e9-afdf-4bacd152295f
:END:

Manuel Uberti has published [[https://github.com/manuel-uberti/flymake-proselint][flymake-proselint on Github]] and MELPA.  It
offers a Flymake interface to the external =proselint= executable (see
[[#h:6dff70a8-7eba-4b5d-982c-f13d13ed3b3b][Proselint configuration]]).

This comes in handy when I need to review some long-form text for common
inconsistencies and stylistic irregularities.  Errors will be marked on
the fringe, while you can quickly get an overview with pointers to the
precise line number by invoking =flymake-show-diagnostics-buffer= (check
my [[#h:b8bfcc05-c0d3-4093-b3fe-f06187d22c6a][configurations for Flymake]] and then also review what I have to
spelling in [[#h:3f1b2856-c6b7-418a-9d7d-464bd1ebe69c][Flyspell and prot-spell.el (spell check)]]).

To run the program, you just need to hook it to whatever major-mode you
use for prose.  Then you need to enable =flymake-mode= to start using it.
I prefer to do the final step manually, as I normally do not run a
linter while writing: it is too distracting.

#+begin_src emacs-lisp
;;; Flymake + Proselint
(prot-emacs-elpa-package 'flymake-proselint
  (add-hook 'markdown-mode-hook #'flymake-proselint-setup)
  (add-hook 'org-mode-hook #'flymake-proselint-setup)
  (add-hook 'text-mode-hook #'flymake-proselint-setup))
#+end_src

***** Proselint configuration
:PROPERTIES:
:CUSTOM_ID: h:6dff70a8-7eba-4b5d-982c-f13d13ed3b3b
:END:

This is my configuration for the external =proselint= executable (check
[[https://github.com/amperser/proselint][that project's README]]).  The following should be made available at
=~/.config/proselint/config=.

See [[#h:2a954862-c532-43e9-afdf-4bacd152295f][Flymake + Proselint]] for how I use this tool to review my long-form
writing.

#+include: ../../proselint/.config/proselint/config src conf :tangle no

*** Elisp packaging requirements
:PROPERTIES:
:CUSTOM_ID: h:d03342da-3035-409f-a5e7-5df1e614d507
:END:

With this in place we can perform checks that pertain to Emacs lisp
packaging.  I use it for my themes but also for any elisp library I may
want to send patches to.

#+begin_src emacs-lisp
;;; Elisp packaging requirements
(prot-emacs-elpa-package 'package-lint-flymake
  (add-hook 'flymake-diagnostic-functions #'package-lint-flymake))
#+end_src

** Eldoc (elisp live documentation feedback)
:PROPERTIES:
:CUSTOM_ID: h:d0f76937-4f54-401c-aae8-ffadf8697357
:END:

When editing elisp, this mode will display useful information about the
construct at point in the echo area.  For functions it will display the
list of arguments they accept.  While it will show the the first
sentence of a variable's documentation string.

At first, I dismissed this package.  Upon closer inspection, it does
offer a lightweight complementary facility to that of the standard help
commands: =C-h f FUNCTION=, =C-h v VARIABLE=.

#+begin_src emacs-lisp
;;; Eldoc (elisp live documentation feedback)
(prot-emacs-builtin-package 'eldoc
  (global-eldoc-mode 1))
#+end_src

** Tools for manual pages (manpages)
:PROPERTIES:
:CUSTOM_ID: h:ce420306-c40c-4d9a-bc01-205c5e49a5d1
:END:

Emacs offers a couple of commands for reading manual pages: =man= and
=woman=.  The former relies on the standard Unix tools, while the latter
is an elisp implementation of the same idea.  As I only ever run a
GNU/Linux system, I am okay with just =man=.

Why bother?

+ All the goodies of consistency: fonts, themes, operating on text with
  your familiar Emacs functionality, handling buffers…
+ Each manpage provides direct links to other items it references.

What you can do inside such a buffer (with minor tweaks by me):

+ Hit =i= to go to the information node you want using completion (same
  principle as with the Info pages of =C-h i= and the like).
+ =g= will generate the buffer anew.  Do it to reformat the text manually,
  though this should also happen automatically when adjusting a window's
  size.
+ =n= and =p= move between section headings.
+ Hit =RET= while over a referenced manpage to produce a new buffer with
  its contents.
+ =s= takes you directly to the familiar "See Also" section.
+ Use =m= to search for another manpage using your completion framework.
  If you invoke this command while point is over a referenced manpage,
  it becomes the default choice (same concept as with common help
  commands, =C-h f=, =C-h v=, and with many others like =find-library=).

Need to filter out those =man= buffers?  Check [[#h:06290f9c-491c-45b2-b213-0248f890c83d][my Ibuffer entry]].

While there are customisation options for this tool, I find the defaults
to work as expected.  Note that the capitalisation of those symbols is
canonical.

#+begin_src emacs-lisp
;;; Tools for manual pages (manpages)
(prot-emacs-builtin-package 'man
  (let ((map Man-mode-map))
    (define-key map (kbd "i") #'Man-goto-section)
    (define-key map (kbd "g") #'Man-update-manpage)))
#+end_src

* History and state
:PROPERTIES:
:CUSTOM_ID: h:1d9437fe-1355-4c2f-8ea7-6668b4d0399b
:END:

This section contains configurations for packages that are dedicated to
the task of recording the state of various Emacs tools, such as the
history of the minibuffer.

** Emacs server and desktop
:PROPERTIES:
:CUSTOM_ID: h:68d57dd2-4df1-4b7a-8766-231216e6cd9c
:END:

The following uses the first /running/ process of Emacs as the one others
may connect to.  This means that calling =emacsclient= (with or without
=--create-frame=), will share the same buffer list and data as the
original running process, aka "the server".  The server persists for as
long as there is an Emacs frame attached to it.

#+begin_src emacs-lisp
;;; Emacs server and desktop
(prot-emacs-builtin-package 'server
  (add-hook 'after-init-hook #'server-start))
#+end_src

With some exceptions aside, I only ever use Emacs in a single frame.
What I find more useful is the ability to save what Emacs calls the
=desktop=, which is an amalgamation of data such as the buffer list,
visited files, and some important data like the content of registers
(for various histories or other data see the following sections on
[[#h:ab868c1a-7ca6-4f54-83d8-eab49447da82][recording various types of history]]).

Because I can always access files I have visited before using completion
(see [[#h:5723c4bb-ff6c-449f-bb60-be66fab3f137][Completion for recent files and directories (prot-recentf.el)]]), I
opt to discard all files and buffers from the =desktop=.  Instead, I use
it to restore everything in the variable =desktop-globals-to-save=.

#+begin_src emacs-lisp
(prot-emacs-builtin-package 'desktop
  (setq desktop-auto-save-timeout 300)
  (setq desktop-path `(,user-emacs-directory))
  (setq desktop-base-file-name "desktop")
  (setq desktop-files-not-to-save ".*")
  (setq desktop-buffers-not-to-save ".*")
  (setq desktop-globals-to-clear nil)
  (setq desktop-load-locked-desktop t)
  (setq desktop-missing-file-warning nil)
  (setq desktop-restore-eager 0)
  (setq desktop-restore-frames nil)
  (setq desktop-save 'ask-if-new)
  (dolist (symbol '(kill-ring log-edit-comment-ring))
    (add-to-list 'desktop-globals-to-save symbol))

  (desktop-save-mode 1))
#+end_src

** Record various types of history
:PROPERTIES:
:CUSTOM_ID: h:ab868c1a-7ca6-4f54-83d8-eab49447da82
:END:
*** Record cursor position
:PROPERTIES:
:CUSTOM_ID: h:ae1cad56-c12c-4bd5-a5cc-e85c0ad4b978
:END:

Just remember where the point is in any given file.  This can often be a
subtle reminder of what you were doing the last time you visited that
file, allowing you to pick up from there.

#+begin_src emacs-lisp
;;; Record cursor position
(prot-emacs-builtin-package 'saveplace
  (setq save-place-file (locate-user-emacs-file "saveplace"))
  (setq save-place-forget-unreadable-files t)
  (save-place-mode 1))
#+end_src

*** Backups
:PROPERTIES:
:CUSTOM_ID: h:3d2e3e65-b860-4ad7-87d2-24e4e9d0e296
:END:

And here are some settings pertaining to backups.  I rarely need those,
but I prefer to be safe in the knowledge that if something goes awry
there is something to fall back to.

#+begin_src emacs-lisp
;;; Backups
(setq backup-directory-alist
      `(("." . ,(concat user-emacs-directory "backup/"))))
(setq backup-by-copying t)
(setq version-control t)
(setq delete-old-versions t)
(setq kept-new-versions 6)
(setq kept-old-versions 2)
(setq create-lockfiles nil)
#+end_src

* Frequently Asked Questions about this document
:PROPERTIES:
:CUSTOM_ID: h:4e73b827-cdf3-46a2-81c5-55b6e95701b7
:END:

There are some persistent questions that pop up in my email exchange, so
I thought I would cover them all in this section.

** How do you learn Emacs?
:PROPERTIES:
:CUSTOM_ID: h:83730fe8-d917-4d94-96f4-bbc5c900fe38
:END:

There is no one-size-fits-all approach to learning.  What one finds
satisfactory, another may consider insufficient.  In my opinion, the
best way to learn Emacs is to start small, be patient, and brace
yourself for a lot of reading and experimentation.

The best skill you can master, the one that will always help you in your
Emacs journey, is the built-in help system.  Learn to ask Emacs about
things you do not know about.  This section documents the essentials of
Emacs' /introspectable nature/.

Know that =C-h= is the universal key for help commands (broadly
understood).  It works both as a prefix and as a suffix.  Some common
help commands:

+ =C-h f= (=describe-function=) allows you to search for documentation about
  *functions*.
+ =C-h v= (=describe-variable=) is the same for *variables*.
+ =C-h o= (=describe-symbol=) is a wrapper of the above two, so you are
  searching for functions *or* variables.  The proper name for any of
  these items is called a "symbol" (think of =name-of-thing= as
  symbolising a definition in the source code).
+ =C-h k= (=describe-key=) will prompt you for a *key* binding.  Once you type
  it in you will get help about what command corresponds to that key (if
  any).  Note that this depends on the major mode you are in.  For
  example =C-c C-c= does something different in Org and Eshell buffers.
  Try =C-h k C-c C-c= to find about the different functions these will
  invoke in their respective major mode.
+ =C-h w= (=where-is=) asks you for the symbol of a command and tells you to
  which key binding it is assigned to.
+ =C-h l= (=view-lossage=) produces a log with your most recent key presses
  and the commands they call.  Emacs calls this the "lossage".  Ever
  mistyped something and got to the wrong place?  Use this as an
  opportunity to learn and, perhaps, a way to identify key sequences you
  would like to modify.  (*pro tip*: you can edit/convert your lossage
  into a keyboard macro with =C-x C-k l=---also watch [[https://protesilaos.com/codelog/2020-03-14-emacs-kmacro-edit/][Edit keyboard macros]]
  (2020-03-14)).

In the above scenaria we see how =C-h= is used as a prefix: you are
starting a key sequence with it.  Now here are some cases of using it as
a suffix:

+ For /every incomplete key sequence/ if you follow it up with =C-h= you
  will get a help buffer about all possible key combinations that
  complete that sequence.  For example, if you type =C-c C-h= inside of an
  Org buffer you will get all possible commands for Org mode and for all
  other minor modes you have active.
+ The =C-h= suffix can be appended to longer key sequences.  Indeed the
  length is irrelevant.  Suppose you want to learn more about some of
  the advanced features of registers.  =C-x r= is the common prefix for
  those commands, so you just do =C-x r C-h= and you get a buffer with
  more information.
+ And, as you may imagine, you can even append the =C-h= /suffix/ to the =C-h=
  /prefix/.  This is a fancy way of saying that =C-h C-h= will show you help
  about help commands themselves.  But because this is a special case,
  it comes with some extras.  Try it!

*All help buffers include links* to other parts of Emacs, from where you
can learn ever more information.  For example, the help for =C-c C-h=
includes links to the commands that correspond to each key chord.
Follow the link to get documentation about that symbol.

More generally, you will find that a symbol is linked to its source.
Look carefully at the top of the buffer that displays the symbol's
documentation and you will find a link to the source code (library) from
where the function/variable (symbol) comes from.

Also know that the source code can be accessed at any time by means of
=M-x find-library= followed by the name you are looking for.  Those are
called "features", by the way, and each library declares them using the
=provide= form at the end of the file (so when you use =require= you pass a
quoted feature symbol).

Help commands that ask you for a symbol to input can also be aware of
the context of the point (the cursor).  If you are over the name of a
function and you type =C-h f=, that function will be the default match.
Hitting RET (Enter) will take you to its documentation.  /This is a great
way to study source code/, because it will guide you to other libraries
or other parts of the same library from where you can understand how
things are pieced together.  And it also works with the =find-library=
command.

While browsing Elisp source code, there are two commands that can be of
great help to navigate definitions.  =xref-find-definitions=, bound to =M-.=
will take you to the definition of the symbol at point.  While its
counterpart, the =xref-pop-marker-stack= (=M-,=), will bring you back to
where you where before.  Similarly, the built-in Isearch tool can search
for the symbol at point with =M-s .= (the =isearch-forward-symbol-at-point=
command), which can then be followed up with =M-s o= to produce an "Occur"
buffer with all the results---use that as an index to move around (also
check: [[#h:b67687ee-25a3-4bf4-a924-180ccb63c629][Isearch, occur, and extras (prot-search.el)]]).

Finally, you should practice =C-h m= (=describe-mode=) as much as possible.
This is the help command for getting information about the major mode
you are in and for all the minor modes you have active and which are
pertinent to the current buffer.  It will show you some valuable
documentation as well as the main key bindings and their commands.  Try
it whenever you use something you have not mastered yet.  For example,
do it in a =dired= buffer to see the main operations you can perform
inside of it (see [[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][Dired (directory editor, file manager)]]).

** Why maintain all those 'prot-*.el' files?
:PROPERTIES:
:CUSTOM_ID: h:b9233089-5a3a-4e7a-81ef-3ad395a26036
:END:

Those contain my custom Elisp code.  Several of them provide extensions
to existing tools, while others introduce some new functionality.  They
are written in accordance with the best coding practices and are, for
all intents and purposes, regular packages even though they only target
my use-case.

The main benefits of packaging my code are thus:

+ Lexical scope :: The code is written in a way that does not introduce
  implicit dependencies on the environment.  Everything within the file
  has to be known so that the compiler can properly interpret it.

+ Byte compilation :: Because of the above, the code compiles cleanly.
  This allows me to execute my code a bit faster than it would otherwise
  be possible.  The more I write, the greater the otherwise marginal
  performance gains.

+ Transparency :: Users who copy my code are made aware of its
  dependencies, which saves me time answering emails why X or Y from my
  dotemacs does not work on another's setup.

+ Modularity :: Since my files render their dependencies and bindings
  explicit, it is easier to catch errors and debug them.

While my =prot-*.el= are distributed as packages, please understand that I
consider this an exercise in programming.  I develop them because I
believe they will be useful to me.  Do not unilaterally put them in some
package archive as I cannot promise that I will keep them around forever
(distributing a package implies a commitment to its users).

** What is the purpose of "prot/" and "contrib/"?
:PROPERTIES:
:CUSTOM_ID: h:0077f7e0-409f-4645-a040-018ee9b5b2f2
:END:

[Also read: [[#h:b9233089-5a3a-4e7a-81ef-3ad395a26036][Why maintain all those 'prot-*.el' files?]]]

The =prot/= prefix in some unpackaged symbols works as a namespace that
captures all my custom, yet-to-be-reviewed code.  These can be functions
or variables.  The utility of this prefix is two-fold:

1. It informs others that this symbol is not part of core Emacs or some
   other package.  Otherwise it can be difficult to understand why
   something you copied did not work.  Say, for example, I have a
   function that accepts an argument: =(prot/function prot/variable)=.  If
   none of these had the namespace you could be misled into thinking
   that your Emacs setup already includes those symbols (and then you
   would get an error message).

2. It makes it easier for me (and others) to quickly discover what
   additions I have made, for whatever reason that may.  For instance,
   =M-x prot/= will give me matches for all my interactive functions
   (depending on the completion framework, one can access those with
   just =M-x p/=).  This also means that I can do =M-x occur prot/= to
   produce an Occur buffer with all my symbols (pass a numeric argument
   to display N lines of context =C-u 5 M-s o=).  From there I can, say,
   browse them all easily or even edit them using the full array of
   Emacs' relevant powers (occur's results buffer is made editable with
   =e=, but you should be able to find that by using the information
   documented in [[#h:83730fe8-d917-4d94-96f4-bbc5c900fe38][How do you learn Emacs?]]).

The same principles apply to the =contrib/= namespace.  Whenever I copy
something from another user, I use that namespace to tell others that
this is not part of Emacs or any other package (and I always link to the
source).

Adding =contrib/= also has another longer-term benefit.  It informs my
future self that some bespoke configuration was needed to solve a
particular problem and, maybe, this has since been solved by a good
package, a newer version of Emacs, or I may eventually be able to
furnish my own alternative.

Again, =occur= or similar tools will filter those out when necessary.
Imagine having to do that without any namespaces…  You would need to
check each symbol one by one to determine its origin.

The convention of separating namespaces with a forward slash is not
particularly important, though the linter for Elisp packaging will
complain about it, if you ever go down that path.  It could be something
like =prot-= or =my-= or whatever.  What matters is to keep things
consistent and fairly easy to identify.

** Why do you use so many `setq'?
:PROPERTIES:
:CUSTOM_ID: h:ba373e0d-29d1-4224-b0f1-64b640ceeaae
:END:

To be clear, these are equivalent:

#+begin_example emacs-lisp
;; Style A
(setq var-1 'symbol)
(setq var-2 '(a b c))
(setq var-3 '((a . b) (c . d)))

;; Style B
(setq var-1 'symbol
      var-2 '(a b c)
      var-3 '((a . b) (c . d)))
#+end_example

You will notice that most of my configurations follow Style A.  I do so
for a couple of reasons:

+ It makes each variable easier to copy elsewhere, say, when sharing it
  online or to an =emacs -Q= scratch buffer.

+ It is trivial to run =C-x C-e= (=eval-last-sexp=) on each balanced
  expression individually (note that =C-M-x= (=eval-defun=) can be used in
  Elisp buffers to evaluate the expression at point).

There are some cases where I use a single =setq= to configure several
closely related variables (Style B), but those are the exception to the
norm.

Style B gives me more problems with copy-pasting, while it does not
solve any real issues (besides, I finalise style A using a keyboard
macro, so there is no real difference in typing).

I find that Style A consists of balanced expressions that are easier to
keep consistent.  This is especially true when you have a mixture of
values: boolean types, property lists, association lists…

** Why do you explicitly set variables the same as default?
:PROPERTIES:
:CUSTOM_ID: h:3e4fefda-c069-4403-a2ad-6d77ee8c0914
:END:

You may have realised that many of my configurations will use a =setq=
that declares a value that is the same as its original in the source
code.  I do this for two reasons:

1. To raise awareness of its existence.  If someone does not like how
   the defaults work, they know where to look.

2. I guard against future versions that could be changing the defaults.

Obviously point 2 is not particularly strong for built-in libraries that
are already very stable, though I find that, on the balance, nothing bad
comes out of it.

At any rate, one must always read the NEWS (=C-h n= for =view-emacs-news=)
whenever they upgrade to a new version of Emacs.  Though there is no
equivalent mechanism for individual packages…  So here we are.

By the way, the fastest way to find a package's customisation options is
to visit its source code and produce an Occur buffer for its =defcustom=
configurations (which extends the ideas in [[#h:83730fe8-d917-4d94-96f4-bbc5c900fe38][How do you learn Emacs?]]).

** Did you know XYZ package is better than the defaults?
:PROPERTIES:
:CUSTOM_ID: h:a654fcb5-0163-4dc6-977a-8c50175118a1
:END:

As a rule of thumb, I choose external packages only after I give a fair
chance to the defaults.  The idea is to take things slowly and learn
along the way, while consulting the official manual and relevant
documentation (I strongly encourage you to study the information I
provide in [[#h:83730fe8-d917-4d94-96f4-bbc5c900fe38][How do you learn Emacs?]]).

Without exposure to the built-in tools it is impossible to make an
informed decision about what is actually missing and what could be
improved further.  Additionally, it is difficult to appreciate the
underlying rationale that led to a given element of design without
actually trying to put yourself in that mindset or workflow.

Put differently, keep an open mind about the alternatives before
deciding to reproduce the thing you had before, else you are assuming
your prior knowledge to be true in advance of any possible evidence to
the contrary (a sign of dogmatism).

The process of learning the internals of Emacs means that I write my own
Elisp functions when I feel that a standard tool could be tweaked on the
margin of its core utility in order to do what I want (read my answer to
the question [[#h:b9233089-5a3a-4e7a-81ef-3ad395a26036][Why maintain all those 'prot-*.el' files?]] as well as the
one on [[#h:0077f7e0-409f-4645-a040-018ee9b5b2f2][What is the purpose of "prot/" and "contrib/"?]]).  External
packages that I do use are either a clear upgrade over the defaults or
otherwise extend the functionality of what is already available.

You will not find any superficialities herein: no rainbow-coloured mode
lines, no icons, no tool bars with bells and spinning wheels, nothing.
I respect the fact that they exist, but find that they do not contribute
to my productivity.

Though a former Vim user for ~3 years, I decided *not* to use =evil-mode= or
any kind of Vi emulation (remember the point about keeping an open
mind?).  I wanted to do things differently in order to ultimately set on
the best approach going forward.  I have eventually settled on a system
that builds on top of the "Emacs way" to key bindings, which I discuss
in my hour-long presentation about [[https://protesilaos.com/codelog/2019-12-20-vlog-switch-emacs/][Switching to Emacs]] (2019-12-20).  I
believe that a mnemonics-based set of keys is easier to get started
with.  It expands organically as you familiarise yourself with the
multitude of Emacs' functionalities: there is an entire world of
applications outside the narrow confines of editing code.

Since you read this (and the rest of my dotemacs, I presume), also
consider two highly valuable blog posts by Karthik Chikmagalur:

+ [[https://karthinks.com/software/batteries-included-with-emacs/][Batteries included with Emacs]] (2020-11-17).
+ [[https://karthinks.com/software/more-batteries-included-with-emacs/][More batteries included with Emacs]] (2020-12-11).

** Compare Gnus, Mu4e, Notmuch?
:PROPERTIES:
:CUSTOM_ID: h:7be4b564-4360-4905-aa10-1405fba6ea2a
:END:

This question is best answered in reference to one's background and the
intuitions made possible by it.  The short answer is that all three are
good in different ways: the best tool for the job is the one that makes
you most productive in the moment.

Now to the longer reply, which fleshes out this time-sensitive
subjectivity I am hinting at.

Before switching to Emacs in the summer of 2019, I used to use Mutt or
Thunderbird as a plan B (starting from mid 2016).  At that time I did
not receive a lot of email, maybe 2-3 per week or even less, and did not
follow any mailing lists.  My Mutt setup was just a basic front-end to
the IMAP server, meaning that I did not have anything like =offlineimap=
or =mbsync= set up.  My workflow back then was heavily focused on
elaborate directories/folders to store the mail I wanted.  For example,
I had an "archive" directory for each of my three email accounts and
inside of that I had yearly archives.  To cut the long story short, in
order to find an email I had to go looking for it at some exact
location.  It was not efficient, but I was okay with it as my mail
traffic was very low.

Once I became a full-time Emacs user, I decided to push the boundaries
of what I could do with email.  The most popular option seemed to be
Mu4e so I picked that one (autumn 2019).  It was easy for me to set up
and I liked its middle-of-the-road approach of combining a typical
directory-based structure with a potent search tool.  I had stopped
doing the complex directory structures with my archives and would keep
everything in my inbox.  Still, the volume of incoming mail was very
low: I was not really using the search features and was reverting to the
directory views instead.

Thus I decided to go with Gnus (early 2020) whose value proposition
seemed to be /"directories are first-class citizens here, same for
Newsgroup sources"/.  Gnus calls all of them "groups" based on its useful
metaphor of treating everything as ephemeral news.  What I learnt from
my time with Gnus is that:

1. Mailing lists are worth paying attention to as you can learn a lot
   from other people's input in various conversations (emacs-devel, bug
   reports, etc.).

2. It is good to use =mbsync= or equivalent as it removes the burden from
   Emacs and allows you to keep a copy of your mail correspondence.  I
   had started with Gnus' nnimap backend, which communicated directly
   with the IMAP server, but once my email traffic started to increase,
   I learnt the hard way that =mbsync= was better suited for the task, as
   it did not block Emacs.

3. Directory-based workflows do not scale.  As I started to get more
   email, I realised that I often needed to quickly retrieve some piece
   of information that was kept in one of my three inbox directories or
   some other location.  Gnus has search methods but there are
   inconsistencies between nntp, nnmaildir, etc. to the effect that I
   would need to have special rules for each case.  Maybe I did not read
   the manual very carefully?  Perhaps I did not understand something?
   At any rate, it did not feel like worth the effort.

The search engine I wanted to use with Gnus was =notmuch=, because it is
mentioned in the Gnus manual.  As I was looking for a way to be in full
control of my email setup, I thought it would be better to try Notmuch
without the layer of abstraction that Gnus added on top of it, stop
following a directory-based workflow, and embrace filtering and
narrowing (concepts I learnt to appreciate through my daily usage of
Emacs).

My few test on the command-line convinced me to refactor my email setup.
So I decided to read through all the manpages and then go with
notmuch.el (made the switch between 2021-05-13 and 2021-05-14).  I did
not want to revert to Mu4e because I had the feeling that its hybrid
approach to directories and search would push me back to my old
inefficient habits.  Whereas Notmuch is all about tagging and filtering,
which makes me believe that I can push myself into new territory (the
configs and docs: [[#h:a196812e-1644-4536-84ba-687366867def][Notmuch (mail indexer and mail user agent (MUA))]]).

This is not to say that any of these tools is inherently better/worse
than its peers.  You can be productive with all three of them (my old
configurations for Mu4e and Gnus can be found in [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]).
What matters is to identify your requirements, set your expectations or
ambitions, and pick the option that can optimise your productivity.  The
point is to not be dogmatic about it: just use what works for you the
same way I did in through journey to where I currently am.

** Have you tried Gnus for RSS feeds?
:PROPERTIES:
:CUSTOM_ID: h:7e4448ec-3878-4ea2-9cd6-75e9faaac373
:END:

*NOTE 2021-05-13:* This question used to pop up when I was using Gnus as
my mail client.  Though I have since switched to Notmuch, I think the
information provided here remains relevant.


For the relevant setup, refer to the mega-section on [[#h:5ad80664-3163-4d9d-be65-462637d77903][Email settings]].

I tried to make feeds work with Gnus because I generally like it and
wish to extend it further.  The issues I encountered are manifold.
These qualify as "problems" based on my expectations, so please do not
take this as a pretence of objectivity.

1. The ~nnrss~ backend does not support the Atom spec.  To make feeds work
   you need to pipe them through some other script that will convert
   them to the RSS format.  I do not like that, because it puts the
   burden on the user for something that should work out-of-the-box.
   The Atom spec has been around for a long time; long enough to expect
   feed readers to have caught up to the current state of affairs.

2. The ~nnrss-opml-import~ command prompts you twice for every feed.
   First to confirm it and then to add a name for it.  Try that for,
   say, 200 feeds.  Not pretty.  Maybe there is some way to bypass this
   and just do it programmatically.  I could not find it.  Again, this
   may be due to my false expectations, where I consider it a basic
   thing that should "just work" (because while I like customising
   everything, this is not a substitute for things working well by
   default).

3. Fetching feeds blocks Emacs entirely.  Especially when the list is
   long.  Again, think of a 200-long list.  I am fine with this
   happening for email when I choose to update things manually, because
   I only have three accounts and the interruption is barely noticeable.
   But it otherwise is a show-stopper.  This means that you must run the
   process externally.  Fine in principle, though I cannot avoid the
   fact that Elfeed already has an option for that (also refer to the
   section [[#h:0cd8ddab-55d1-40df-b3db-1234850792ba][Elfeed feed reader, prot-elfeed.el and prot-elfeed-bongo.el]]).

4. Updating feeds often produces duplicate items or fetches the same
   item again, even though it was already read.  The solution is to
   customise ~nnrss-ignore-article-fields~.  Its default value is an XML
   tag that you only learn about if you actually read a relevant feed's
   source code: "(slash:comments)".  So if you want to, say, ignore the
   published date, you need to check the XML and find the =pubDate= tag.
   Fine, I can do that, but it is not a good idea to expect users to
   know such technicalities.

5. Gwene is a good compromise in lieu of a genuine solution, namely:
   proper support for the Atom spec and the option to fetch feed updates
   through curl/wget (or equivalent).  However, I do not like the whole
   workflow around it.  It runs contrary to what I am doing with Emacs:
   which is to control things from inside of Emacs.  Gwene is a website
   facade and a public server.  You go to the website to upload your
   OPML file.  Where is the =M-x= command for that?  And why should a list
   of decentralised feeds be dependent on a centralised server, anyway?
   And why should the list be made public?  What about private feeds?

Apologies if this sounds too negative.  I am sure there are workarounds
and there is always a good chance that either I missed something, or I
simply am not knowledgeable enough to make Gnus+Feeds work properly.  I
also wish I had better Elisp skills to help patch those issues in core
Emacs, but I must work with what I have.

** What is the meaning of the `s-KEY' bindings?
:PROPERTIES:
:CUSTOM_ID: h:fbba4dea-9cc8-4e73-bffa-02aab10a6703
:END:

Some sections of this document assign functions to key combinations that
involve the "Super" key (also known as the "Windows key" on some
commercial keyboards).  This is represented as a lower case =s=.

Those key bindings typically are alternative ways of invoking /common
commands/ that are by default bound to longer key chords.  The original
keys will continue to function as intended (for example, =C-x o= is also
=s-o=).  Otherwise they are bound to my own custom commands.

To find all my keybindings of this sort in the source code version of
this document from inside of Emacs, do =M-s o= (or =M-x occur=) followed by
the pattern ="[a-zA-Z<]?-?s-.+?"= (please contact me if you know how to
improve this).

Note that your choice of desktop environment (or window manager) might
render some of those useless.  The DE/WM will simply intercept the key
chord before it is ever sent to Emacs.  For example, GNOME has a *hidden*
key mapping to =s-p=, which does something with monitors (last time I
checked on GNOME 3.30).  Such bindings are scattered throughout the
config database that is normally accessed with =gsettings= on the command
line or the graphical =dconf-editor= (not pretty either way).  For me this
is not a problem, because I disable all of the DE's key bindings (also
read: [[#h:044977f2-a909-4804-bf89-576dd429d405][What is your distro and/or window manager?]]).

** How to reproduce your dotemacs?
:PROPERTIES:
:CUSTOM_ID: h:0675f798-e2d9-4762-9df2-f47cd24cf00a
:END:

/Remember that I am not using Emacs 27 or some other stable release.  I
currently am on {{{emacs-development-version}}}./

First you must understand that this is my personal setup: I have never
tried to develop a framework that works out-of-the-box for other users.
It runs contrary to how I approach Emacs as a long-term investment that
involves learning everything from the basics to the more advanced
issues: which means starting from scratch while being patient,
persistent, and humble.

Furthermore, it is important to understand that the very nature of this
setup makes it highly opinionated and, thus, several of its components
may be predicated on implicit assumptions about preferences.  For
example, I only use my Modus themes because that is the design I want to
interface with, and will therefore not make any effort whatsoever to
provide options that can let someone pick a theme out of the multitude
that is on offer: this is not to say that those options are inherently
wrong, just that they make no sense in a /personal Emacs setup/.

As you may know from René Magritte's famous /Ceci n'est pas une pipe/
painting, what you think you are looking at is not equivalent to its
actuality.  You may be led to believe that my dotemacs is in fact an
"Emacs distro", or "starter kit", or whatnot, and that you can just
clone it and re-use it right away.  In truth /ceci n'est pas une
distribution Emacs/.  It is my personal setup.

With those granted, I understand that people may want to benefit from
what I already make public and, in turn, I want to help them to that
end.  It is not my intent to create impediments to one's progress as an
Emacs user, nor to obfuscate my otherwise readily available corpus of
labour.  I wish to make things easy and accessible, without prejudice to
the aforementioned points about what /this/ is.

To reproduce my setup, you first need to clone my dotfiles' repository.
This includes more stuff than just my Emacs files, though it is what I
use.  Let's say you plan to clone the repo at =~/Git/prot-dotfiles=.  You
invoke this command from your shell:

#+begin_example sh
git clone https://gitlab.com/protesilaos/dotfiles.git ~/Git/prot-dotfiles
#+end_example

If you do not want to copy the entire history of the project, you can
pass the =--depth= flag, like this:

#+begin_example sh
git clone --depth 1 https://gitlab.com/protesilaos/dotfiles.git ~/Git/prot-dotfiles
#+end_example

That one fetches just the latest commit and is considerably faster.
Though the full history is useful if you plan to retrieve some datum
from it.

My dotfiles are managed with the help of the GNU Stow program.  What
that does is create and handle symlinks from a source directory to a
destination.  The file structure of my dotfiles is designed to reflect
the expected end result at the =$HOME= directory.

Stow operates on what it calls a "package": a set of files whose file
structure will be reproduced at the target filesystem path.  Take a look
at the tree representation of my "emacs package", per Stow's parlance
(this output may not be exactly the same you will get depending on when
you review it, but that is beside the point).

#+begin_example sh
~/Git/prot-dotfiles $ tree -aF --dirsfirst emacs
emacs
└── .emacs.d/
    ├── modus-themes/
    │   ├── modus-operandi-theme.el
    │   ├── modus-themes.el
    │   └── modus-vivendi-theme.el
    ├── prot-lisp/
    │   ├── prot-bongo.el
    │   ├── prot-comment.el
    │   ├── prot-common.el
    │   ├── prot-consult.el
    │   ├── prot-cursor.el
    │   ├── prot-diff.el
    │   ├── prot-dired.el
    │   ├── prot-elfeed-bongo.el
    │   ├── prot-elfeed.el
    │   ├── prot-embark.el
    │   ├── prot-embark-extras.el
    │   ├── prot-eshell.el
    │   ├── prot-fill.el
    │   ├── prot-fonts.el
    │   ├── prot-mail.el
    │   ├── prot-ibuffer.el
    │   ├── prot-icomplete.el
    │   ├── prot-logos.el
    │   ├── prot-minibuffer.el
    │   ├── prot-moody.el
    │   ├── prot-orderless.el
    │   ├── prot-outline.el
    │   ├── prot-project.el
    │   ├── prot-pulse.el
    │   ├── prot-recentf.el
    │   ├── prot-search.el
    │   ├── prot-sideline.el
    │   ├── prot-simple.el
    │   ├── prot-spell.el
    │   ├── prot-tab.el
    │   ├── prot-text.el
    │   ├── prot-vc.el
    │   ├── tmr.el
    │   └── usls.el
    ├── basic-init.el
    ├── early-init.el
    ├── init.el
    ├── prot-emacs.org
    └── user-emacs.org

3 directories, 42 files
#+end_example

When we invoke a =stow= command on this =emacs= package we are instructing
the program to create symlinks to a directory called =.emacs.d= and to
place all relevant files/directories inside of it.  What we want is to
mirror this tree in our =$HOME= directory (I only use GNU/Linux, by the
way):

#+begin_example sh
~/Git/prot-dotfiles $ stow -t "$HOME" emacs
#+end_example

As you will learn from Stow's manpage, the =-t= flag points at the target
destination.  So we want to mirror the =.emacs.d= of my dotfiles to that
found in =~/.emacs.d=.  If the latter exists, only the relevant files will
be symlinked.  Otherwise it will be created outright as a symlink
itself.

If files that conflict with mine, like =init.el=, already exist at the
target path, then Stow will throw an error and abort its operation.
This is good: we do not want to overwrite existing data.  So make sure
to create backups of everything and move them to another location.

Whenever I add or remove a file, my "emacs package" needs to be updated
accordingly: the symlinks have to be generated anew.  Adding the =-R= flag
does the trick:

#+begin_example sh
~/Git/prot-dotfiles $ stow -t "$HOME" -R emacs
#+end_example

Similarly, if you ever want to delete those symlinks in a clean way,
pass the =-D= flag instead of =-R=:

#+begin_example sh
~/Git/prot-dotfiles $ stow -t "$HOME" -D emacs
#+end_example

The same is true for all other "packages" in my dotfiles' repo.

At this point you are ready to start using my Emacs setup.  But not
everything will work just yet.  As was already discussed in the section
about [[#h:584c3604-55a1-49d0-9c31-abe46cb1f028][Main macros and other contents of my init.el (for Emacs 28)]], I
have a policy of not auto-installing packages by default.  If you want
to do that when you first launch my Emacs, you must create a new file
called =basic-init.el= and place it in the same place where my =init.el= and
=prot-emacs.org= are found (the =basic-init.el= is read before initiating my
main configuration file).  In that file you must add the following:

#+begin_example emacs-lisp
(setq prot-emacs-autoinstall-elpa t)
#+end_example

This means that you explicitly opt in to automatically installing all my
defined packages that are found in GNU ELPA or MELPA.

If you do not create the =basic-init.el= with those contents, then the
default behaviour is to run my setup and produce a series of warnings
about missing packages that you need to install on your own.  The
resulting log's messages will explain how to do that in one go, though
you can always opt for another approach if you want.  This default
method offers you the opportunity to think carefully about what packages
you really need and proceed to remove the ones you do not want to keep
around.

Whatever you do with the installation of items from Emacs Lisp Package
Archives, you will always have to manually configure the few packages I
maintain through their source code.  Again, the warning messages will
tell you what they expect from you.  Basically, you will need to look up
their names in the =prot-emacs.org= file to find their repo's URL.  Then
you will have to clone that to the =contrib-elisp= path inside of your
=.emacs.d=.  Or comment out their code block (or delete it) if you do not
want them.

You are finally done and ready to start using what I develop.  And you
have realised by now that /this definitely is my personal Emacs setup and
I only target my use-case/ which means, among others, that I will never
add bells and whistles that I do not use just to satisfy demand for them
(e.g. icons).

To append your own configurations, you can create a new =user-emacs.org=
file and place it in the same path as my =prot-emacs.org=.  It must
include code blocks like the ones I provide in my Org config.  Those
will be evaluated at startup and everything will work as expected:
=user-emacs.org= is loaded after =prot-emacs.org= and you assume
responsibility for everything.

This hopefully covers it.  If you have any questions, either open an
issue in [[https://gitlab.com/protesilaos/dotfiles/][my dotfiles' repo]] or [[https://protesilaos.com/contact/][contact me directly]].  Remember that I wish
to be helpful, though I have no plan to turn this into yet another Emacs
distro.

** What is your distro and/or window manager?
:PROPERTIES:
:CUSTOM_ID: h:044977f2-a909-4804-bf89-576dd429d405
:END:

I have been on GNU/Linux since the summer of 2016.  For the most time I
have used Debian and Arch Linux, switching between the two.  As of
2020-05-03, I am back on Arch.

My criterion for picking a distro is that it is community-driven and has
a strong following to ensure its longer-term continuity and overall
stability.  This happens to be consistent with my current focus on
Emacs: I need things to work so that I may not be bothered by too many
administrative tasks (and yes, Arch is super-stable once you know what
you are doing---and, well, Debian is designed for that).

Given that I mostly live inside of Emacs, the desktop environment is not
super important to me.  Though I still like to configure things to my
liking, partially because it gives me a predictable environment but also
for the inherent fun of it.

I run a custom session centred around a tiling window manager.  Normally
this is bspwm (Binary Space Partitioning Window Manager), though my
dotfiles also include configurations for (i) swaywm and (ii)
herbstluftwm.  The former is a Wayland compositor.  I keep it as a
reliable solution for the inevitable Wayland future (Xorg is in
maintenance mode, but it still works perfectly fine for my needs).
While the latter is conceptually similar to bspwm, with the major
exception being how it handles monitors and workspaces.

As of 2021-11-08, I have an ultrawide display as part of a temporary
exchange.  My bspwm is not optimised for it, because contents start off
far to the left.  It is possible to make it behave in a desirable
fashion, but I don't want to adapt my setup to this monitor and then
revert back to what I had before.  So I am using herbstluftwm for the
time being, which lets me designate areas of the physical display as
virtual monitors.  So I divide the 2560x1080 area into two parts with
the right one being 1920x1080.  This means that my Emacs goes to the
right virtual monitor and its left window (the Emacs concept of
"window") is positioned closer to the centre of the display.  My setup
includes a shell script which splits the display in three, with the
largest area in the middle.

Herbstluftwm's virtual monitors are not mere workspaces.  They do
confine everything inside of them, as if they were physical displays.
Fullscreen mode, for example.

None of my tiling window managers is as well documented as my Emacs
setup.  I do plan to improve things at some point.  Until then, my
dotfiles are only intended for experienced users or, generally, those
who understand that they will handle everything on their own:
<https://gitlab.com/protesilaos/dotfiles>.

My Emacs is [[https://git.savannah.gnu.org/cgit/emacs.git/][built from source]], directly from trunk (i.e. the =master=
branch).

** What hardware do you use?
:PROPERTIES:
:CUSTOM_ID: h:e134a8b2-224e-4383-bf03-b080ab6659c7
:END:

I used to have a Lenovo Thinkpad X220 which I purchased in 2018 for ~80
EUR.  In early August 2021 its battery stopped working and, for reasons
I do not understand, it does not power up without it even though the
Internet tells me it should...

Watch: [[https://protesilaos.com/codelog/2021-08-29-emacs-community-new-pc/][The Emacs community bought me a new PC]] (2021-08-29).

After the [[https://protesilaos.com/news/2021-08-16-status-update-computer/][donations I received up until August 16 2021]], which amounted
to 430 EUR, I contacted a friend of mine who is tech-savvy and was able
to build a custom desktop computer with his help.  I don't have the full
picture of all the specs, as I know very little about hardware (the
first computer I ever owned was my laptop and now this one) and my
friend was the one who took care of everything.

In the following table the discepancy between the values in the column
"my cost" and "brand new" indicates that the component came second-hand.

| Component    | Specification                                       | My cost | Brand new |
|--------------+-----------------------------------------------------+---------+-----------|
| GPU          | VGA BIOSTAR AMD RADEON RX560 2GB VA5615RF21         |     100 |       140 |
| CPU          | AMD RYZEN 5 1600 AF 3.20GHZ 6-CORE                  |     120 |       180 |
| RAM          | TEAM GROUP TED416G2400C1601 ELITE 16GB DDR4 2400MHZ |      83 |        83 |
| MOTHERBOARD  | ASUS PRIME B450M - A II                             |      85 |        85 |
| Fans         | Don't know                                          |      10 |        10 |
| Power supply | Don't know                                          |      30 |        30 |
| Box          | Don't know                                          |      30 |        30 |
|--------------+-----------------------------------------------------+---------+-----------|
|              |                                                     |     458 |       558 |

Other components I already had: monitor, mouse, keyboard, speakers.  I
had acquired those over the years.  The keyboard is a generic Qwerty
layout that I got from a toy store for 7 EUR together with a small mouse
(the size of the mouse is about half that of a regular one).  The mouse
is annoying to work with (thankfully not often), though the keyboard
feels better than what its cost suggests---still toy-level though.  Same
for the speakers, which I think cost 8 or 10 EUR.  The monitor is
1920x1080 and the best part is that I got it free of charge from a
clearance several years ago, before I even had the Thinkpad.

As of 2021-11-08, I exchanged that monitor with a friend's ultrawide
one, which is 2560x1080.  I thought I would experiment with it for a
while to see what kind of software solutions can be applied to such an
otherwise awkward ratio ([[#h:044977f2-a909-4804-bf89-576dd429d405][What is your distro and/or window manager?]]).
While my friend needs to use a dual monitor setup for some work.

On the day I got the computer (August 6, 2021), I got a camera and
microphone for 40 EUR combined.  Now I have a good setup in place to do
live streams in addition to the prerecorded videos I would produce.

Since we are here: the recording software is OBS Studio, while I do no
video editing whatsoever.

* Other people's Emacs work
:PROPERTIES:
:CUSTOM_ID: h:7b39c38c-ae23-4385-b439-afca89baca52
:END:

Emacs is both a piece of software and a diverse community of people that
are brought together by their shared interest in this unique program.
Emacs' development unfolds through a distributed network of volunteers,
coordinated by members of the GNU project.  While the community at-large
develops and ultimately internalises lots of valuable ideas to a pool of
accumulated knowledge, such as configurations with custom Elisp code,
video or written tutorials on particular workflows, and packages that
cover a broad range of needs.

Outside the narrow confines of the computer, Emacs is its people.

Here is a non-exhaustive list of users that I have found to be helpful,
each in their own unique way---the order is not significant:

+ Omar Antolín Camarena :: Omar's work is mentioned several times in
  this document (author of Orderless, Embark, and co-author of
  Marginalia).  Apart from those inherently useful packages, Omar has
  helped me several times with various programming issues by sharing
  concrete code examples.  Make sure to check Omar's packages and also
  monitor [[https://github.com/oantolin/emacs-config][the personal Emacs configuration]] which doubles as a laboratory
  of experimentation for new packages or other useful ideas.

+ Daniel Mendler :: Daniel's name is referenced in a number of this
  document's sections (author of Consult, Corfu, Vertico, Recursion
  indicator, co-author of Marginalia together with Omar---you get the
  idea).  As far as I can tell, Daniel does not share an Emacs
  configuration, though one can still learn a lot by studying the code
  of the numerous repositories on [[https://github.com/minad][@minad's Github]].

+ Manuel Uberti :: Manuel's contributions have been of paramount
  importance to the development of my Modus themes.  Manuel offers a lot
  to the Emacs milieu through code contributions but also by reporting
  issues and communicating with package maintainers.  The domain name
  [[https://www.manueluberti.eu/][www.manueluberti.eu]] hosts a blog with Manuel's musings on Emacs.  For
  example, you will find articles that I have already referenced in this
  document, such as [[https://www.manueluberti.eu/emacs/2020/11/14/extending-project/][Extending project.el]].  If you are interested in
  cinema like Manuel, do not miss the reviews on [[https://www.filmsinwords.eu/][www.filmsinwords.eu]].

+ Nicolas De Jaeghere :: Nicolas is another contributor to my Modus
  themes and has helped me understand several Elisp concepts, such as by
  helping me refine the macros that are defined in my =init.el=.  Nicolas
  maintains [[https://github.com/Koekelas/dotfiles][a personal dotfiles repo]] where you can find an =emacs.org=
  file with lots of advanced code snippets.

+ Adam Porter (aka alphapapa, github-alphapapa) :: Adam is a prolific
  contributor to the Emacs packaging milieu and a prominent member of
  the community on the =r/emacs= subreddit.  [[https://github.com/alphapapa][Adam's packages on Github]]
  cover a wide range of needs and are designed using excellent coding
  practices.  These include a client for the Matrix communication
  protocol (=ement.el=), a robust query language for Org (=org-ql=), a code
  colouriser that applies colour based on the level of depth (=prism.el=),
  a powerful buffer-management system (=bufler.el=), a sticky header that
  shows the first line of the code's definition when that is outside the
  visible window (=topsy.el=), a tool that tracks your position across
  Emacs buffers so you can return exactly to where you need to be
  (=dogears.el=)...  You get the idea.  I still plan to incorporate some
  of those into my workflow, starting with dogears, topsy, and bufler.

+ Andrew Tropin :: Andrew is a programmer and contributor to free
  software who also produces [[https://www.youtube.com/channel/UCuj_loxODrOPxSsXDfJmpng][live streams on Youtube]] about various
  Emacs-related topics, as well as the Guix System.  You will find
  valuable information there, such as a Git workflow about pull requests
  as compared to patches, an advanced email setup with Emacs+Notmuch,
  and project management.  Andrew's =rde= is [[https://sr.ht/~abcdw/rde/][a suite of tools]] that manages
  computing environments in Guix.

+ Rainer König :: Rainer has [[https://www.youtube.com/playlist?list=PLVtKhBrRV_ZkPnBtt_TD1Cs9PJlU0IIdE][a series of video tutorials]] on how to
  organise your life using various Org features, such as check-lists and
  the agenda.  Each video covers a single utility or closely related
  concepts, while the whole playlist offers a progression from basic to
  more advanced workflows.  Highly recommended!

+ Mike Zamansky :: Mike is a computer science professor who has been
  doing [[https://www.youtube.com/channel/UCxkMDXQ5qzYOgXPRnOBrp1w][videos on Emacs]] for several years.  There is a wealth of
  information to parse from those presentations as well as the
  corresponding [[https://github.com/zamansky/dot-emacs][dot-emacs code repository]].

+ Emacs Elements :: This is [[https://www.youtube.com/channel/UCe5excZqMeG1CIW-YhMTCEQ][a channel on Youtube]] where Raoul Comninos
  shows how to get things done using Emacs.  There are tutorials on how
  to use the =diary=, =calendar=, and =org-agenda=, while you will also find
  more advanced topics such as how to install, use, and make sense of
  the powerful Icicles completion framework, as well as other useful
  packages.

+ System Crafters :: David Wilson's work on Emacs covers a broad range
  of themes, encapsulated in the [[https://github.com/daviwil/emacs-from-scratch][Emacs from scratch]] configuration.  The
  [[https://youtube.com/c/SystemCrafters][Youtube channel]] contains lots of videos on how to set up and use all
  sorts of packages in Emacs, such as Org and the Mu4e email client.  It
  is fair to say that if something is related to Emacs, David has either
  already done a video about it or is planning to do one in the near
  future.  The [[https://systemcrafters.cc/][System Crafters]] website includes references to all such
  work, while it also covers contributions by the community that David
  has helped foster.  The material on offer is top-notch.  It serves as
  an excellent resource and point of reference for new and experienced
  users alike.

+ Alain M. Lafon :: Alain is one of my early influences in my Emacs
  journey.  As soon as I had made the switch, I watched the video
  presentation [[https://www.youtube.com/watch?v=gfZDwYeBlO4][Play Emacs like an instrument]], which shows some advanced
  workflows of using Emacs in a seemingly effortless fashion.  I knew
  Emacs was good, but did not realise it could be /that good/.  Alain is a
  programmer as well as a Zen monk, who is the founder and CEO of the
  200ok consultancy.  The [[https://200ok.ch/blog.html][consultancy's blog]] contains a lot of articles
  and guides on Emacs, while you can find video tutorials on similar
  topics over at [[https://www.youtube.com/channel/UCIFJHWyIlN0XFrW2vMKG6QA][Alain's Youtube channel]].

+ Xah Lee :: Xah is a well-known member of the community through years
  of contributions either with packages or [[http://www.xahlee.info/][informational websites]] on
  various aspects of Emacs.  On [[https://www.youtube.com/channel/UCXEJNKH9I4xsoyUNN3IL96A][Xah's Youtube channel]] you will find
  videos about Emacs on all sorts of topics.  Those are live streamed.

+ Karthik Chikmagalur :: Karthik's [[https://karthinks.com/software/batteries-included-with-emacs/][Batteries included with Emacs]]
  (2020-11-17) and [[https://karthinks.com/software/more-batteries-included-with-emacs/][More batteries included with Emacs]] (2020-12-11) are
  essential reading for anyone wanting to gain an overview of some of
  Emacs' built-in capabilities and learn about its 'hidden gems'.
  Another excellent piece is [[https://karthinks.com/software/fifteen-ways-to-use-embark/][Fifteen ways to use Embark]] (2021-10-06).
  Karthik's website includes philosophical insights as well, such as
  those found in [[https://karthinks.com/blog/thoughts-on-strength-training/][Thoughts on Strength Training]] (2019-03-02).  You will
  also discover packages by Karthik in this document, such as
  =consult-dir= and =project-x=.

+ James Norman Vladimir Cash :: James produces videos on Emacs, such as
  this one [[https://occasionallycogent.com/custom_emacs_modeline_video_edition/index.html][on customising the modeline]] and writes about similar topics,
  like reading email in Emacs.  Though I also appreciate commentary of a
  political sort: [[https://occasionallycogent.com/against_mindless_minimalism/index.html][Against Mindless Software Minimalism]] (2019-03-24).

+ Karl Voit :: Karl is an expert in Personal Information Management
  (PIM) covering that and relevant topics over at [[https://karl-voit.at/][karl-voit.at]].  There
  are lots of interesting articles on offer, such as how to organise
  data with [[https://karl-voit.at/2020/01/25/avoid-complex-folder-hierarchies/][Don't Do Complex Folder Hierarchies]] and to keep a web
  presence with [[https://karl-voit.at/2020/10/23/avoid-web-forums/][Don't Contribute Anything Relevant in Web Forums]].  Karl
  also participated in the 2021 edition of the /Grazer Linuxtage/
  conference with [[https://karl-voit.at/2021/04/10/GLT21-emacs-org-features/][a talk on Org features and extras]].

+ Sacha Chua :: Sacha's work is instrumental to the Emacs community's
  self awareness.  The [[https://sachachua.com/blog/category/geek/emacs/][weekly "Emacs news" blog entries]] offers an
  overview of what is happening in our space---consider it essential
  reading.  While Sacha was among the organisers of the last two yearly
  Emacsconf events and has shared a lot of valuable insights throughout
  the years, such as hand-drawn guides to using Emacs, chats with
  prominent members of the Emacs community, and more.

+ Bozhidar Batsov :: Bozhidar is the maintainer of several popular Emacs
  packages (and not only), such as the [[https://github.com/bbatsov/projectile][Projectile library]] for
  interacting with projects (like a Git repo), the [[https://github.com/bbatsov/prelude][Prelude starter kit]]
  which tries to enhance---but otherwise remain faithful to---the
  standard Emacs experience, ports of the popular Zenburn and Solarized
  themes, as well as the informative [[https://emacsredux.com/][blog Emacs redux]].

+ Timothy (aka tecosaur) :: Timothy, better known as TEC or tecosaur, is
  the designer of the current iteration of the [[https://orgmode.org/][Org-mode web page]] and
  provides, among others, the blog [[https://blog.tecosaur.com/tmio/archive.html][This Month in Org]] which, as it name
  implies, offers a monthly overview of noteworthy new snippets that
  concern the development of the deservedly beloved Org-mode.

+ Irreal :: Jon Snader's [[https://irreal.org/blog/][Irreal blog]] is one of the best places to start
  learning about the people in the wider Emacs community and to continue
  keeping track of their projects.  Irreal offers curated summaries of
  our fellow Emacsers' contributions, as well as original entries.  Jon
  takes the time to cover the main points in one's work and, where
  appropriate, to highlight relevant information or offer a valuable
  insight.

+ Álvaro Ramírez (aka xenodium) :: Álvaro maintains a blog on Emacs and
  related programming topics: https://xenodium.com.  One of my favourite
  aspects about the posts you will find there are the high quality GIFs
  that capture some precise and very powerful Emacs motion, custom
  command, or workflow.  Álvaro is, among others, the developer of a
  mobile app that helps you track your habits: [[https://flathabits.com/][Flat Habits]].  And the
  best part is that it is all powered by Org mode!

Please note that this is a non-exhaustive list.  Lots of people
contribute to the betterment of Emacs proper and to specialised
packages, such as Jonas Bernoulli (developer of Magit, among many
others), Oleh Krehel (developer of Ivy, Counsel, Swiper, and more),
Thierry Volpiatto (maintainer of Helm), Bastien Guerry (Org maintainer),
Eli Zaretskii (Emacs maintainer), Lars Ingebrigtsen (author of Gnus,
co-maintainer of Emacs), Dmitry Gutov (maintainer of several built-in
subsystems like project.el, as well as external packages like Company,
diff-hl...), Henrik Lissner (author and maintainer of Doom Emacs), the
ever-resourceful maintainers and contributors to Org-roam, and many
others.

For my part, I wish to express my gratitude to all those who have
contributed to my own projects, including the ones who have sent patches
against my Emacs setup, but also users who have reported issues, shared
insights, provided code and suggestions for my Modus themes.  The
themes' manual (which is 27k words as of this writing on 2021-07-27)
contains an "Acknowledgements" section where everyone is included.  I
think the least we can do is acknowledge how much we as individuals
benefit from the communities that organically grow around our projects.

Every bit counts: a bug report, a blog post detailing one's workflow,
participation in a mailing list thread, etc.  Do not hesitate to add
your part and become a member of this wonderful community.

A big thank you to everyone!
